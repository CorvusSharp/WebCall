# Исправления проблем со звонками

## Обнаруженные проблемы

### 1. **Звонящий не видит статус звонка**

**Проблема**: В функции `startOutgoingCall` в `calls_signaling.js` состояние устанавливалось в `outgoing_invite` сразу, но когда приходило WebSocket сообщение `call_invite` от сервера, обработчик проверял `if (state.phase === 'idle')`, что уже было неверно.

**Код с ошибкой**:
```javascript
// В startOutgoingCall:
setState({ phase:'outgoing_invite', roomId: room, otherUserId: friend.user_id, otherUsername: friend.username });

// В handleWsMessage:
} else if (isMine){
  if (state.phase==='idle'){ // ❌ Это условие никогда не выполнялось!
    setState({ phase:'outgoing_invite', roomId: msg.roomId, otherUserId: msg.toUserId, otherUsername: msg.toUsername });
  }
}
```

### 2. **Рассинхронизация между старым и новым слоями звонков**

**Проблема**: 
- `friends_ui.js` использует `getActiveCall()` из старого `calls.js` (состояние в `appState.activeCall`)
- Новая система `calls_signaling.js` использует локальную переменную `state`
- Эти состояния не синхронизировались, поэтому UI не отображал правильное состояние

### 3. **Отсутствие обратной связи при ошибках**

**Проблема**: Если friends WebSocket не готов или API возвращает ошибку, пользователь не получал никаких уведомлений.

## Примененные исправления

### 1. Исправление обработки `call_invite` для звонящего

**Файл**: `calls_signaling.js`

```javascript
// Добавили обработку case когда состояние уже outgoing_invite
} else if (isMine){
  if (state.phase==='idle'){
    setState({ phase:'outgoing_invite', roomId: msg.roomId, otherUserId: msg.toUserId, otherUsername: msg.toUsername });
  } else if (state.phase==='outgoing_invite' && state.roomId === msg.roomId){
    // ✅ Обновляем информацию о получателе, когда приходит подтверждение от сервера
    setState({ otherUsername: msg.toUsername });
  }
}
```

### 2. Исправление логики инициации звонка

**Файл**: `calls_signaling.js`

```javascript
// Убрали преждевременную установку состояния
notifyCall(friend.user_id, room).then(()=> {
  dbg('notifyCall ok');
  // ✅ Устанавливаем состояние только после успешного API вызова
  if (state.phase === 'idle') {
    setState({ phase:'outgoing_invite', roomId: room, otherUserId: friend.user_id, otherUsername: friend.username });
  }
}).catch(e=> {
  dbg('notifyCall error', e);
  // ✅ Показываем ошибку пользователю
  try {
    if (window.showToast) {
    }
  } catch {}
});
```

### 3. Добавление синхронизации между слоями

**Файл**: `calls_signaling.js`

```javascript
// Добавили синхронизацию с legacy calls.js
function setState(patch){
  // ... existing code ...
  
  // ✅ Синхронизируем с legacy calls.js для совместимости UI
  try {
    syncWithLegacyCalls(state, prev);
  } catch (e) {
    dbg('legacy sync error', e);
  }
  
  emit();
}

// ✅ Функция синхронизации состояний
async function syncWithLegacyCalls(currentState, prevState) {
  if (typeof window === 'undefined' || !window.appState) return;
  
  try {
    const { setActiveOutgoingCall, setActiveIncomingCall, markCallAccepted, markCallDeclined, resetActiveCall } = await import('./calls.js');
    
    if (currentState.phase === 'outgoing_invite' && prevState.phase !== 'outgoing_invite' && currentState.otherUserId && currentState.roomId) {
      setActiveOutgoingCall(
        { user_id: currentState.otherUserId, username: currentState.otherUsername }, 
        currentState.roomId
      );
    } else if (currentState.phase === 'incoming_invite' && prevState.phase !== 'incoming_invite' && currentState.otherUserId && currentState.roomId) {
      setActiveIncomingCall(currentState.otherUserId, currentState.otherUsername, currentState.roomId);
    } else if (currentState.phase === 'active' && prevState.phase !== 'active' && currentState.roomId) {
      markCallAccepted(currentState.roomId);
    } else if (currentState.phase === 'ended' && prevState.phase !== 'ended' && currentState.roomId) {
      markCallDeclined(currentState.roomId);
    } else if (currentState.phase === 'idle' && prevState.phase !== 'idle') {
      resetActiveCall('idle');
    }
  } catch (e) {
    // Игнорируем ошибки import для совместимости
  }
}
```

### 4. Улучшение обратной связи

**Файл**: `calls_signaling.js`

```javascript
// Улучшили сообщение когда WebSocket не готов
if (!ws || ws.readyState !== WebSocket.OPEN){
  dbg('friends WS not ready, abort startOutgoingCall');
  try { window.__CALL_DEBUG && window.__CALL_DEBUG.push({ ts:Date.now(), warn:'friends_ws_not_ready' }); } catch {}
  
  // ✅ Показываем уведомление пользователю
  try {
    if (typeof window !== 'undefined' && window.showToast) {
      window.showToast('Подключение не готово. Попробуйте позже.', 'warning');
    } else {
      alert('Подключение не готово. Попробуйте позже.');
    }
  } catch {}
  return false;
}
```

**Файл**: `app_init.js`

```javascript
// ✅ Сделали showToast доступной глобально
try { window.showToast = showToast; } catch {}
```

## Диагностика проблем

### Сообщение "Подключение не готово. Попробуйте позже."

Это сообщение появляется когда WebSocket соединение для друзей не готово. Причины:

1. **Нет токена авторизации** - нужно войти в систему
2. **WebSocket не создан** - проблема с инициализацией
3. **WebSocket в состоянии CONNECTING** - соединение устанавливается
4. **WebSocket закрыт** - проблема с сервером или сетью
5. **Цикл переподключений** - WebSocket постоянно подключается и отключается (исправлено в v2)

### Сообщение "Устанавливается соединение. Попробуйте через несколько секунд."

Это улучшенное сообщение означает, что система попытается восстановить соединение автоматически.

### Диагностика через консоль браузера

Выполните в консоли браузера:
```javascript
window.debugWebSocket()
```

Или более подробную диагностику:
```javascript
// Скопируйте и выполните содержимое файла debug_websocket.js
```

### Возможные решения

1. **Обновите страницу** - перезапустится WebSocket подключение
2. **Проверьте авторизацию** - выйдите и войдите заново
3. **Проверьте консоль** - ищите ошибки WebSocket
4. **Принудительное переподключение**:
   ```javascript
   window.appState.friendsWs = null;
   window.startFriendsWs();
   ```

## Тестирование

Для тестирования исправлений создан файл `test_call_fixes.html`, который можно открыть в браузере для проверки:

1. Исходящие звонки теперь правильно обрабатываются 
2. Входящие звонки работают корректно
3. Ошибки WebSocket подключения показывают уведомления
4. Состояния синхронизируются между новым и старым слоями

## Ожидаемый результат

После применения исправлений:

1. ✅ **Звонящий видит статус звонка** - состояние правильно обновляется при получении подтверждения от сервера
2. ✅ **Получатель получает уведомления о звонке** - входящие звонки обрабатываются корректно  
3. ✅ **UI отображает правильное состояние** - синхронизация между слоями работает
4. ✅ **Пользователь получает обратную связь об ошибках** - показываются уведомления при проблемах

## Исправления v2 (проблема бесконечных переподключений)

### Обнаруженная проблема
Из серверных логов видно, что WebSocket соединения постоянно открываются и сразу закрываются, создавая бесконечный цикл переподключений:

```
INFO: connection open
INFO: connection closed
WS_REPLACE user=... old_ws=... new_ws=...
```

Также появилась ошибка "Устанавливается соединение. Попробуйте через несколько секунд" при попытках звонков.

### Примененные исправления v2

1. **Предотвращение множественных подключений** - добавлен флаг `friendsWsConnecting`
2. **Ограничение попыток переподключения** - максимум 10 попыток
3. **Увеличение интервалов переподключения** - от 5 до 30 секунд с экспоненциальным ростом
4. **Улучшенная логика onclose** - не переподключаться при нормальном закрытии или скрытой странице
5. **Обработчик beforeunload** - предотвращение переподключений при закрытии страницы


### Дополнительные проблемы
- Флаг `friendsWsConnecting` иногда не сбрасывался, блокируя звонки
- Отсутствовал таймаут для подключений, что могло приводить к зависанию
- Недостаточно информативные сообщения об ошибках
### Примененные исправления v3

1. **Улучшенная логика состояний WebSocket**:
   - Проверка активности соединения перед созданием нового
   - Принудительное закрытие старых соединений
   - Таймаут подключения (10 секунд) с автоматическим сбросом флагов

2. **Исправление обработчиков ошибок**:
   - Упрощена логика onerror - не создает дополнительных переподключений
   - Корректное освобождение ресурсов при ошибках
   - Отмена автоматических ретраев при ошибках создания соединения

3. **Улучшенная проверка готовности в calls_signaling.js**:
   - Учет состояния `friendsWsConnecting` при проверке готовности
   - Более информативные сообщения пользователю
   - Предотвращение повторных попыток переподключения

4. **Расширенная диагностика**:
   - `window.debugWebSocket()` - детальная информация о состоянии
   - `window.debugCalls()` - полная системная диагностика
   - `window.forceReconnectWebSocket()` - безопасное переподключение

### Новые функции диагностики

- `window.debugWebSocket()` - показывает состояние соединения и счетчик попыток
- `window.debugCalls()` - полная диагностика системы звонков
- `window.forceReconnectWebSocket()` - принудительное переподключение с сбросом счетчика
- `websocket_debug_v2.html` - расширенная диагностическая страница

## Измененные файлы

1. `webcall/app/presentation/static/js/modules/calls_signaling.js` - **v3**: улучшенная логика проверки готовности WebSocket, учет состояния подключения
2. `webcall/app/presentation/static/js/modules/core/app_init.js` - **v3**: полная переработка логики WebSocket с таймаутами, корректным управлением состояниями и расширенной диагностикой
3. `webcall/app/presentation/static/test_call_fixes.html` - тестовая страница (новый файл)
4. `webcall/app/presentation/static/debug_websocket.js` - скрипт диагностики WebSocket (новый файл)
5. `webcall/app/presentation/static/websocket_test.html` - базовый тест WebSocket подключения (новый файл)
6. `webcall/app/presentation/static/reconnection_test.html` - тест логики переподключений (новый файл)
7. `webcall/app/presentation/static/websocket_debug_v2.html` - **НОВЫЙ**: расширенная диагностическая страница с автоматическими тестами

Добавлены улучшения диагностики и UX для списка друзей и поиска пользователей:

1. Расширенные сообщения об ошибках в `friends_ui.js` при загрузке друзей и заявок: показывается `Ошибка загрузки: <деталь>` вместо общего слова.
2. В `api.js` функции `listFriends`, `listFriendRequests`, `findUsers` теперь формируют человеко-понятные тексты ошибок (401 → «Не авторизован», 422 → «некорректный запрос» и т.д.).
3. Поиск отображает: `Поиск...`, затем либо результаты, либо `Ничего не найдено`, либо конкретную причину ошибки (`Ошибка поиска: <деталь>` / `Неверный ответ сервера`).
4. Консольные предупреждения (`console.warn`) помогают оперативно увидеть формат ответов backend при аномалиях.
5. Улучшена устойчивость к неожиданному формату ответа (проверка `Array.isArray`).

Как диагностировать:
* Откройте DevTools → Network. Убедитесь, что `/api/v1/friends/` и `/api/v1/friends/requests` возвращают 200.
* При 401: истёк токен — выполните повторный вход, проверьте `localStorage.wc_token`.
* При 422 на поиске: длина запроса меньше минимальной (валидируется backend). Увеличьте запрос.
* Вкладка Console: ищите префикс `[friends_ui]` для технических подробностей.

Идеи на будущее (пока не реализованы):
* Debounce поиска (300–400мс) + отмена предыдущего запроса.
* Кнопка «Повторить» при сетевой ошибке.
* Авто-logout при повторном 401.
* Пагинация друзей / lazy load.

---

### Edge-case: 400 Username must be 3-32 chars

Если backend отвечает 400 (detail: `Username must be 3-32 chars [A-Za-z0-9_.-]`) на запросы `/api/v1/friends/` или `/api/v1/friends/requests`, причина в том, что при сборке DTO дергается доменный value object `Username`, а в таблице `users` есть записи с невалидным username.

Проверка: 
```sql
SELECT id, username FROM users WHERE username !~ '^[A-Za-z0-9_.-]{3,32}$';
```

Варианты решения:
1. Миграция: нормализовать (`LOWER`, заменить пробелы на `_`, обрезать до 32, удалить запрещённые символы) и обновить.
2. Временный ручной фикс проблемных записей через UPDATE.
3. (Опционально) внедрить fallback при чтении: если regex не проходит — подставлять `user_<первые8символов id>` (пока не реализовано, чтобы явно подсветить несоответствия).

UI теперь показывает кнопку «Исправить профиль», ведущую на `profile.html`, если ловит эту ошибку при загрузке друзей.

Рекомендация: выполнить миграцию до продакшена, чтобы не держать невалидные данные.

---

### Возможности
1. Кнопки медиа с иконками: `🎥 Камера`, `🖥 Экран`. Активное состояние подсвечено классом `.btn-media-active`.
2. Мини-индикатор `🖥 Экран шарится` поверх локального превью при активном screen share.
3. Горячая смена устройства камеры без renegotiation: селект камеры вызывает `switchCamera()` если активна камера.
4. Ограничения качества:
  - Камера: 1280x720 @ ~24fps (max 30)
  - Экран: 15fps
  Определяются через объект `videoConstraints` в `webrtc.js`.
5. Колбэк состояния видео `onVideoState(kind, track)` обновляет UI (badge, активные кнопки, видимость локальной карточки).
6. Автовозврат к камере после завершения демонстрации экрана (если возможно), иначе полное отключение видео.

### Использование
— Включить/выключить камеру: кнопка `🎥 Камера`.
— Начать/остановить шаринг: кнопка `🖥 Экран` (во время трансляции текст меняется на `🛑 Остановить`).
— Сменить камеру: выбрать устройство в селекте — трек подменяется через `RTCRtpSender.replaceTrack` без разрыва соединений.

### Технические детали
— При смене источника прежние `MediaStreamTrack` останавливаются для экономии ресурсов.
— Badge адаптируется под тему (зелёная / красная палитра).
— Локальная карточка скрывается при отсутствии активного видеоконтента.
— Screen share использует отдельный stream, но трек маппится в общий `localStream` для унификации.

### Потенциальные улучшения (TODO)
— Одновременное отображение камеры (PiP) вместе с экраном.
— Динамическая адаптация fps при высокой потере пакетов.
— UI индикатор текущей частоты кадров / разрешения.

### Fullscreen и фиксы локального видео
Добавлено:
 - Кнопки ⛶ для разворачивания как локального, так и любого peer видео на весь экран (Fullscreen API).
 - Делегирование событий в `app_init.js` (по `data-action="fullscreen"`).
 - Класс `.fullscreen-active` (обводка активного контейнера).
 - Принудительные `video.play()` вызовы после установки `srcObject` (и обработчик `loadedmetadata`) — снижает риск черного экрана при строгих autoplay политиках браузера.
 - Если элемент уже в fullscreen и нажать кнопку снова — выход из полноэкранного режима.

Причина проблемы «черный экран»: в ряде случаев браузер откладывает воспроизведение до gesture или требуется явный `play()`. Теперь это компенсировано.

## Страницы профиля и смены пароля (новые)

Добавлены страницы управления учётной записью:

- `profile.html` — изменение Email и имени пользователя.
  - Запрос: `GET /api/v1/auth/me` для автозаполнения полей.
  - Сохранение: `PATCH /api/v1/auth/me` (частичное — можно отправлять только email или username).
  - LocalStorage синхронизация (`wc_email`, `wc_username`) обновляет бейдж в шапке.
  - Ошибки: 400 (валидация), 409 (конфликт), 401 (нет авторизации).

- `password.html` — смена пароля в отдельной странице.
  - Поля: текущий, новый, подтверждение нового.
  - Запрос: `POST /api/v1/auth/me/password` (ответ `{ "status": "ok" }`).
  - Ошибка 400: «Старый пароль неверен или новый некорректен».

Навигация:
 - Из главной через панель настроек → «Изменить данные».
 - С `profile.html` переход на смену пароля и обратно.
 - На `password.html` ссылки назад: главная и профиль.

Backend детали:
 - `PgUserRepository.update_profile` и `update_password` коммитят транзакции, возвращают актуальные данные.
 - Эндпоинт смены пароля изменён на `200 OK` вместо `204`, чтобы избежать `AssertionError` FastAPI о теле ответа.

Идеи на будущее:
 - Подтверждение email при изменении.
 - Аватар / загрузка изображения.
 - История смен пароля или журнал входов.

## Одновременная трансляция камеры и экрана + очистка последнего кадра

Проблемы (до фикса):
* Включение демонстрации экрана заменяло камеру — нельзя транслировать оба потока.
* После остановки видеопотока оставался «замороженный» последний кадр локально.
* Нельзя было переключить окно/вкладку без полного выключения screen share.

Решения:
1. Введены отдельные сущности `_cameraTrack/_cameraSender` и `_screenTrack/_screenSender`.
2. Разрешено существование двух активных видеотреков (камера + экран); приоритет отображения в локальном превью — экран.
3. `stopCamera()` и `stopScreenShare()` останавливают/отвязывают только соответствующий трек, legacy `stopVideo()` выключает оба.
4. Очищается превью при отсутствии активных треков (`video.srcObject=null; video.load()`), убирая последний кадр.
5. `switchScreenShareWindow()` выполняет повторный `getDisplayMedia` и `replaceTrack`, позволяя сменить окно без разрыва.
6. `_currentVideoKind`: `none | camera | screen | multi` — при двух треках устанавливается `multi` (для UI/статуса).
7. Автоматическая renegotiation остаётся через `negotiationneeded`; при необходимости fallback форс-оффер также покрывает второй видеотрек.

API обновления (WebRTCManager):
* `startCamera() / stopCamera()`
* `startScreenShare() / stopScreenShare()`
* `switchScreenShareWindow()`
* `toggleCameraStream()` / `toggleScreenShare()` (поведение обновлено под новую модель)

Визуализация локального превью:
* Отдельный комбинированный поток не микшируется (для упрощения). В будущем возможен Canvas микшер для PiP камеры над экраном.

Edge cases:
* Ограничение браузера по количеству одновременных видео-сендов: тогда второй трек может потребовать renegotiation с удалением первого.
* Safari иногда задерживает `negotiationneeded` — компенсируется уже существующим таймерным форсом.

Планы на улучшения:
* Canvas-композиция (экран + миникамера) без второго RTP потока.
* Динамический bitrate adaptation: снижение fps камеры при активном screen share.
* UI-индикатор «multi» состояния и отдельные кнопки отключения каждого канала.

## Расширения (PiP, Adaptive, Multi Badges, Canvas Mix)

### Что добавлено сверх ранее описанного
1. Два одновременных видеотрека отправляются параллельно (камера + экран) с отдельными `RTCRtpSender` (`_cameraSender`, `_screenSender`).
2. PiP (картинка‑в‑картинке) UX:
  - Локально: при `multi` состояние на карточке появляется badge `🎥+🖥` и отдельные кнопки `✖︎ Кам` / `✖︎ Экран`.
  - Удалённо: плитка участника содержит стек из основного видео (`peer-main`) и PiP наложения (`peer-pip`). Эвристика: экран определяется по `label` (`screen|display|share`).
3. Adaptive понижение качества камеры при активном screen share: метод `_adaptVideoQualities()` снижает камеру до ~960x540 @12fps, возвращает исходные constraints после остановки экрана.
4. Кнопки мгновенной остановки отдельных источников (`stopCamera()`, `stopScreenShare()`).
5. Индикатор `multi` вместо двух отдельных badge, если активны оба трека.
6. Canvas-композиция (опционально): локальный скрытый `<canvas id="localCompositeCanvas">` рисует экран + камеру (PiP) единым кадром. Включается кнопкой `🧩 Mix` при состоянии `multi`.

### Canvas Mix (архитектура)
* Не отправляет композицию в сеть: это только локальный визуальный слой для пользователя.
* Метод `enableComposite(canvas)` запускает рендер‑петлю `_runCompositeLoop()`.
* Приоритет: фон = экран, PiP = камера (22% ширины, 16:9, с белой рамкой) в правом нижнем углу.
* Автоматическое отключение композиции, если исчезли оба трека.

### API дополняющие
```
// webrtc.js
enableComposite(canvas: HTMLCanvasElement)
disableComposite()
toggleComposite(canvas?)
```

### UI / Состояния
| State | local badge | Кнопка Mix | Поведение превью |
|-------|-------------|------------|------------------|
| none  | скрыто      | скрыта     | нет видео        |
| camera| скрыто      | скрыта     | камера           |
| screen| 🖥 badge    | скрыта     | экран            |
| multi | 🎥+🖥 badge  | показана   | экран (основное) + кнопки stop | 

### Ограничения и соображения
* Safari: может игнорировать часть `applyConstraints`; деградация камеры необязательна, но попытка безопасна.
* Дополнительный второй RTP поток увеличивает uplink; Canvas Mix может служить основой для будущего режима «один поток наружу» (нужен `canvas.captureStream()`). Пока не активировано осознанно, чтобы не ломать текущие peer соединения.
* При переключении окна шаринга `switchScreenShareWindow()` сохраняет камеру без мигания.

### Возможные следующие шаги
* Добавить настройку «Отправлять один композиционный поток вместо двух» (замена senders на `canvas.captureStream()` + отключение `_screenTrack/_cameraTrack`).
* Динамический выбор позиции PiP (drag & drop + сохранение в localStorage).
* Отображение текущих фактических параметров (реальное разрешение, fps) через `getStats()`.

## Shortcuts & Metrics

Горячие клавиши (когда фокус не в поле ввода):
* `m` — toggle микрофон
* `c` — toggle камера
* `s` — toggle демонстрация экрана
* `x` — принудительно остановить экран
* `k` — принудительно остановить камеру
* `Shift+M` (буква `M`) — включить/выключить локальную Canvas композицию (кнопка `🧩 Mix`)

Оверлей метрик (`#localVideoMetrics`):
* Показывает текущее состояние (`camera|screen|multi`) + `width x height @fps`.
* Обновление 1 раз в секунду через `track.getSettings()`.
* Автоматически скрывается при отсутствии видеотреков.


