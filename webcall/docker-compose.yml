services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000" # для локальной проверки, Nginx ходит на 127.0.0.1:8000
    depends_on:
      - postgres
      - redis
      - coturn
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000"]
    # NOTE: In production we intentionally DO NOT mount the host source into the container
    # because it would overwrite files that were copied into the image during build (including bundle.js).
    # For local development you can add a volume mapping manually (e.g. - ./:/app) in your compose override.

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: webcall
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - redisdata:/data

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    environment:
      - TURN_REALM=${TURN_REALM}
      - TURN_USERNAME=${TURN_USERNAME}
      - TURN_PASSWORD=${TURN_PASSWORD}
      - TURN_PUBLIC_IP=${TURN_PUBLIC_IP}
      - TURN_CLI_PASSWORD=${TURN_CLI_PASSWORD:-changeme}
    # Передаём параметры явно через CLI, чтобы переменные окружения применялись напрямую.
    # Убрали -n (no config) + статический конфиг с плейсхолдерами.
    # Включаем long-term credentials и fingerprint.
    command:
      - turnserver
      - --lt-cred-mech
      - --realm
      - ${TURN_REALM}
      - --user
      - ${TURN_USERNAME}:${TURN_PASSWORD}
      - --listening-port
      - "3478"
      - --min-port
      - "49152"
      - --max-port
      - "49200"
      - --external-ip
      - ${TURN_PUBLIC_IP}
      - --fingerprint
      - --log-file
      - stdout
      - --no-tlsv1
      - --no-tlsv1_1
      - --no-loopback-peers
      - --no-loopback-relays
      - --cli-password
      - ${TURN_CLI_PASSWORD:-changeme}
      # - --verbose  # раскомментируй для отладки
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49200:49152-49200/udp"
      # - "9641:9641" # (опционально) Prometheus metrics if enabled
    # При желании можно вернуть файл и убрать часть параметров — тогда не используйте -n и обеспечьте подстановку значений.
    # volumes:
    #   - ./docker/turnserver.conf:/etc/coturn/turnserver.conf:ro
    #   - ./certs:/certs:ro  # (опционально) TLS certs for TURN

  prometheus:
    image: prom/prometheus:v2.53.0
    restart: unless-stopped
    depends_on:
      - api
    command:
      - --config.file=/etc/prometheus/prometheus.yml
      # Уменьшаем retention по времени и ограничиваем размер БД, чтобы не съесть весь диск на малом VPS
      - --storage.tsdb.retention.time=3d
      - --storage.tsdb.retention.size=512MB
      # (Опционально можно ещё добавить: --query.lookback-delta=30m для снижения нагрузки)
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      # Выделяем отдельный именованный volume для данных Prometheus (по умолчанию /prometheus)
      - prometheus-data:/prometheus
    ports:
      - "127.0.0.1:9090:9090"

  grafana:
    image: grafana/grafana:11.2.0
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    depends_on:
      - prometheus
    ports:
      - "3000:3000"
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro

volumes:
  pgdata:
  redisdata:
  grafana-data:
  prometheus-data:
