=== Dump started: 05.09.2025 14:39:05,13
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   README.md
|   |   
|   \---v
|       \---cache
|               lastfailed
|               nodeids
|               
+---alembic
|   |   env.py
|   |   
|   \---versions
|           0001_init.py
|           
+---app
|   |   __init__.py
|   |   
|   +---application
|   |   |   __init__.py
|   |   |   
|   |   +---dto
|   |   |       auth.py
|   |   |       messages.py
|   |   |       rooms.py
|   |   |       __init__.py
|   |   |       
|   |   \---use_cases
|   |           auth.py
|   |           messages.py
|   |           participants.py
|   |           rooms.py
|   |           signals.py
|   |           __init__.py
|   |           
|   +---bootstrap
|   |       asgi.py
|   |       main.py
|   |       __init__.py
|   |       
|   +---core
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---domain
|   |   |       models.py
|   |   |       values.py
|   |   |       __init__.py
|   |   |       
|   |   +---ports
|   |   |       repositories.py
|   |   |       services.py
|   |   |       __init__.py
|   |   |       
|   |   \---services
|   |           room_service.py
|   |           __init__.py
|   |           
|   +---infrastructure
|   |   |   config.py
|   |   |   logging.py
|   |   |   __init__.py
|   |   |   
|   |   +---db
|   |   |   |   base.py
|   |   |   |   models.py
|   |   |   |   session.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---repositories
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           users.py
|   |   |           __init__.py
|   |   |           
|   |   +---ice
|   |   |       provider.py
|   |   |       __init__.py
|   |   |       
|   |   +---messaging
|   |   |       inmemory_bus.py
|   |   |       redis_bus.py
|   |   |       __init__.py
|   |   |       
|   |   \---security
|   |           jwt_provider.py
|   |           password_hasher.py
|   |           __init__.py
|   |           
|   +---presentation
|   |   |   docs.py
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---api
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---deps
|   |   |   |       auth.py
|   |   |   |       containers.py
|   |   |   |       db.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---routers
|   |   |           auth.py
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           webrtc.py
|   |   |           __init__.py
|   |   |           
|   |   +---schemas
|   |   |       api.py
|   |   |       
|   |   +---static
|   |   |   |   app.js
|   |   |   |   index.html
|   |   |   |   styles.css
|   |   |   |   
|   |   |   \---js
|   |   |           api.js
|   |   |           main.js
|   |   |           signal.js
|   |   |           ui.js
|   |   |           webrtc.js
|   |   |           
|   |   \---ws
|   |           rooms.py
|   |           
|   +---scripts
|   |       create_superuser.py
|   |       wait_for_db.py
|   |       
|   \---tests
|           conftest.py
|           test_auth.py
|           test_rooms.py
|           test_ws_basic.py
|           
+---docker
|       api.Dockerfile
|       
\---tests
        test_health.py
        

=== FILE CONTENTS =======================================

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env ---
# FastAPI / App
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# Security
JWT_SECRET=change_me
JWT_EXPIRES_MIN=60

# Database
DATABASE_URL=postgresql+asyncpg://webcall:secret@postgres:5432/webcall

# Redis
REDIS_URL=redis://redis:6379/0

# CORS (JSON array)
CORS_ORIGINS=["http://localhost:5173","http://localhost:8000"]

# WebRTC ICE (JSON array)
STUN_SERVERS=["stun:stun.l.google.com:19302"]
# TURN (coturn) — must match docker-compose coturn settings
# Use your VPS DNS or public IP; port 3478 is exposed in compose
TURN_URL=turn:vpn.bandjshoos.ru:3478
TURN_USERNAME=webcall
TURN_PASSWORD=secret

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env.example ---
# FastAPI / App
APP_NAME=WebCall
APP_ENV=dev
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# Security
JWT_SECRET=change_me
JWT_EXPIRES_MIN=60

# Database
DATABASE_URL=postgresql+asyncpg://webcall:secret@postgres:5432/webcall

# Redis
REDIS_URL=redis://redis:6379/0

# CORS
CORS_ORIGINS=http://localhost:5173,http://localhost:8000

# WebRTC ICE
STUN_SERVERS=stun:stun.l.google.com:19302
TURN_URL=
TURN_USERNAME=
TURN_PASSWORD=

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore ---
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.venv/
.poetry/
.mypy_cache/
.pytest_cache/
.coverage
htmlcov/
.cache/

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini ---
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml ---
services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
  # - coturn  # uncomment if you add depends requirement
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload"]
    volumes:
      - ./:/app

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: webcall
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

  # TURN server (coturn)
  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    command:
      - -n
      - --log-file=stdout
      - --min-port=49152
      - --max-port=49200
      - --realm=bandjshoos.ru
      - --listening-ip=0.0.0.0
      - --relay-ip=0.0.0.0
      - --listening-port=3478
      - --external-ip=104.238.24.120
      - --lt-cred-mech
      - --user=webcall:secret
      - --fingerprint
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
  - "49152-49200:49152-49200/udp"
      # Optional TLS TURN on 5349 if you configure certs
      # - "5349:5349/tcp"

volumes:
  pgdata:
  redisdata:

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\dump.bat ---
@echo off
chcp 65001 >nul
setlocal EnableDelayedExpansion

:: Игнорируемые папки
set "SKIP_DIRS=\venv\;.git\;__pycache__\;.mypy_cache\;.idea\;.vscode\;node_modules\;.pytest_cache\"

:: Игнорируемые файлы
set "SKIP_FILES=CACHEDIR.TAG"

set "OUT=project_dump.txt"

(
  echo === Dump started: %date% %time%
  echo Root: %cd%
  echo.
  echo === DIRECTORY TREE =======================================
  tree /F /A
  echo.
  echo === FILE CONTENTS =======================================
) > "%OUT%"

:: Обход файлов
for /R %%F in (*) do (
    set "FILE=%%~fF"
    call :ShouldSkip "%%F"
    if errorlevel 1 (
        REM skip
    ) else (
        >>"%OUT%" echo.
        >>"%OUT%" echo --- %%F ---
        >>"%OUT%" type "%%F"
    )
)

>>"%OUT%" echo.
>>"%OUT%" echo === Dump finished: %date% %time%

echo Структура и содержимое файлов сохранены в %OUT%
exit /b


:ShouldSkip
setlocal
set "FN=%~1"

:: Проверяем папки
for %%D in (%SKIP_DIRS%) do (
    echo "%FN%" | findstr /I "%%D" >nul && (exit /b 1)
)

:: Проверяем файлы
for %%X in (%SKIP_FILES%) do (
    if /I "%~nx1"=="%%X" exit /b 1
)

exit /b 0

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile ---
.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\project_dump.txt ---
=== Dump started: 05.09.2025 14:39:05,13
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   README.md
|   |   
|   \---v
|       \---cache
|               lastfailed
|               nodeids
|               
+---alembic
|   |   env.py
|   |   
|   \---versions
|           0001_init.py
|           
+---app
|   |   __init__.py
|   |   
|   +---application
|   |   |   __init__.py
|   |   |   
|   |   +---dto
|   |   |       auth.py
|   |   |       messages.py
|   |   |       rooms.py
|   |   |       __init__.py
|   |   |       
|   |   \---use_cases
|   |           auth.py
|   |           messages.py
|   |           participants.py
|   |           rooms.py
|   |           signals.py
|   |           __init__.py
|   |           
|   +---bootstrap
|   |       asgi.py
|   |       main.py
|   |       __init__.py
|   |       
|   +---core
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---domain
|   |   |       models.py
|   |   |       values.py
|   |   |       __init__.py
|   |   |       
|   |   +---ports
|   |   |       repositories.py
|   |   |       services.py
|   |   |       __init__.py
|   |   |       
|   |   \---services
|   |           room_service.py
|   |           __init__.py
|   |           
|   +---infrastructure
|   |   |   config.py
|   |   |   logging.py
|   |   |   __init__.py
|   |   |   
|   |   +---db
|   |   |   |   base.py
|   |   |   |   models.py
|   |   |   |   session.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---repositories
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           users.py
|   |   |           __init__.py
|   |   |           
|   |   +---ice
|   |   |       provider.py
|   |   |       __init__.py
|   |   |       
|   |   +---messaging
|   |   |       inmemory_bus.py
|   |   |       redis_bus.py
|   |   |       __init__.py
|   |   |       
|   |   \---security
|   |           jwt_provider.py
|   |           password_hasher.py
|   |           __init__.py
|   |           
|   +---presentation
|   |   |   docs.py
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---api
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---deps
|   |   |   |       auth.py
|   |   |   |       containers.py
|   |   |   |       db.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---routers
|   |   |           auth.py
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           webrtc.py
|   |   |           __init__.py
|   |   |           
|   |   +---schemas
|   |   |       api.py
|   |   |       
|   |   +---static
|   |   |   |   app.js
|   |   |   |   index.html
|   |   |   |   styles.css
|   |   |   |   
|   |   |   \---js
|   |   |           api.js
|   |   |           main.js
|   |   |           signal.js
|   |   |           ui.js
|   |   |           webrtc.js
|   |   |           
|   |   \---ws
|   |           rooms.py
|   |           
|   +---scripts
|   |       create_superuser.py
|   |       wait_for_db.py
|   |       
|   \---tests
|           conftest.py
|           test_auth.py
|           test_rooms.py
|           test_ws_basic.py
|           
+---docker
|       api.Dockerfile
|       
\---tests
        test_health.py
        

=== FILE CONTENTS =======================================

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env ---
# FastAPI / App
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# Security
JWT_SECRET=change_me
JWT_EXPIRES_MIN=60

# Database
DATABASE_URL=postgresql+asyncpg://webcall:secret@postgres:5432/webcall

# Redis
REDIS_URL=redis://redis:6379/0

# CORS (JSON array)
CORS_ORIGINS=["http://localhost:5173","http://localhost:8000"]

# WebRTC ICE (JSON array)
STUN_SERVERS=["stun:stun.l.google.com:19302"]
# TURN (coturn) — must match docker-compose coturn settings
# Use your VPS DNS or public IP; port 3478 is exposed in compose
TURN_URL=turn:vpn.bandjshoos.ru:3478
TURN_USERNAME=webcall
TURN_PASSWORD=secret

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env.example ---
# FastAPI / App
APP_NAME=WebCall
APP_ENV=dev
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# Security
JWT_SECRET=change_me
JWT_EXPIRES_MIN=60

# Database
DATABASE_URL=postgresql+asyncpg://webcall:secret@postgres:5432/webcall

# Redis
REDIS_URL=redis://redis:6379/0

# CORS
CORS_ORIGINS=http://localhost:5173,http://localhost:8000

# WebRTC ICE
STUN_SERVERS=stun:stun.l.google.com:19302
TURN_URL=
TURN_USERNAME=
TURN_PASSWORD=

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore ---
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.venv/
.poetry/
.mypy_cache/
.pytest_cache/
.coverage
htmlcov/
.cache/

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini ---
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml ---
services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000"
    depends_on:
      - postgres
      - redis
  # - coturn  # uncomment if you add depends requirement
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload"]
    volumes:
      - ./:/app

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: secret
      POSTGRES_DB: webcall
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

  # TURN server (coturn)
  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    command:
      - -n
      - --log-file=stdout
      - --min-port=49152
      - --max-port=49200
      - --realm=bandjshoos.ru
      - --listening-ip=0.0.0.0
      - --relay-ip=0.0.0.0
      - --listening-port=3478
      - --external-ip=104.238.24.120
      - --lt-cred-mech
      - --user=webcall:secret
      - --fingerprint
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
  - "49152-49200:49152-49200/udp"
      # Optional TLS TURN on 5349 if you configure certs
      # - "5349:5349/tcp"

volumes:
  pgdata:
  redisdata:

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\dump.bat ---
@echo off
chcp 65001 >nul
setlocal EnableDelayedExpansion

:: Игнорируемые папки
set "SKIP_DIRS=\venv\;.git\;__pycache__\;.mypy_cache\;.idea\;.vscode\;node_modules\;.pytest_cache\"

:: Игнорируемые файлы
set "SKIP_FILES=CACHEDIR.TAG"

set "OUT=project_dump.txt"

(
  echo === Dump started: %date% %time%
  echo Root: %cd%
  echo.
  echo === DIRECTORY TREE =======================================
  tree /F /A
  echo.
  echo === FILE CONTENTS =======================================
) > "%OUT%"

:: Обход файлов
for /R %%F in (*) do (
    set "FILE=%%~fF"
    call :ShouldSkip "%%F"
    if errorlevel 1 (
        REM skip
    ) else (
        >>"%OUT%" echo.
        >>"%OUT%" echo --- %%F ---
        >>"%OUT%" type "%%F"
    )
)

>>"%OUT%" echo.
>>"%OUT%" echo === Dump finished: %date% %time%

echo Структура и содержимое файлов сохранены в %OUT%
exit /b


:ShouldSkip
setlocal
set "FN=%~1"

:: Проверяем папки
for %%D in (%SKIP_DIRS%) do (
    echo "%FN%" | findstr /I "%%D" >nul && (exit /b 1)
)

:: Проверяем файлы
for %%X in (%SKIP_FILES%) do (
    if /I "%~nx1"=="%%X" exit /b 1
)

exit /b 0

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile ---
.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\project_dump.txt ---
=== Dump started: 05.09.2025 14:39:05,13
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyprojec
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\pyproject.toml ---
[tool.poetry]
name = "webcall"
version = "0.1.0"
description = "WebRTC call backend with FastAPI (onion architecture)"
authors = ["You <you@example.com>"]
readme = "README.md"
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.111.0"
uvicorn = {extras=["standard"], version="^0.30.0"}
pydantic = "^2.8.2"
pydantic-settings = "^2.4.0"
SQLAlchemy = "^2.0.30"
asyncpg = "^0.29.0"
alembic = "^1.13.2"
redis = "^5.0.6"
passlib = {version = "^1.7.4", extras=["bcrypt"]}
python-jose = {version = "^3.3.0", extras=["cryptography"]}
httpx = "^0.27.0"
structlog = "^24.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^8.2.2"
pytest-asyncio = "^0.23.8"
httpx = {version="^0.27.0", extras=["http2"]}
ruff = "^0.6.3"
black = "^24.8.0"
isort = "^5.13.2"
pre-commit = "^3.8.0"
mypy = "^1.11.1"

[tool.ruff]
line-length = 100
extend-select = ["I"]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 100

[tool.pytest.ini_options]
asyncio_mode = "auto"
filterwarnings = [
  "ignore::DeprecationWarning",
]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\README.md ---
# WebCall

Бэкенд для веб-созвонов на FastAPI с WebSocket-сигналингом (onion/clean architecture).

Слои: presentation → application → core. Инфраструктура внедряется через порты.

## Быстрый старт (Docker)

1. Создайте `.env` из примера:

```
cp .env.example .env
```

2. Поднимите стэк:

```
docker compose up --build
```

3. Примените миграции (в другом терминале):

```
docker compose exec api alembic upgrade head
```

4. Откройте Swagger: http://localhost:8000/docs

5. Демо-клиент: http://localhost:8000/static/index.html

## Локальный запуск

Требуется Python 3.11+ и Poetry.

```
poetry install
poetry run uvicorn app.bootstrap.asgi:app --reload
```

Миграции:

```
poetry run alembic upgrade head
```

## Структура

См. дерево в задаче. Важные части:
- app/bootstrap: создание приложения
- core: доменные сущности/порты/сервисы
- application: use-cases
- infrastructure: реализация портов (DB, Redis, JWT, bcrypt, ICE)
- presentation: REST и WS, схемы, ошибки, статика

## Definition of Done
- docker compose up поднимает Postgres, Redis, API
- alembic upgrade head проходит
- /docs доступен
- Регистрация/логин работают
- Создание комнат работает
- WS сигналинг показывает обмен сообщениями

## Примечания
- Rate limit для REST помечен как TODO
- Метрики/Prometheus — TODO хуки
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\.gitignore ---
# Created by pytest automatically.
*
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\README.md ---
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\v\cache\lastfailed ---
{}.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\v\cache\nodeids ---
[
  "app/tests/test_auth.py::test_dummy_auth",
  "app/tests/test_rooms.py::test_dummy_rooms",
  "app/tests/test_ws_basic.py::test_ws_basic",
  "tests/test_health.py::test_healthz"
].
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\env.py ---
from __future__ import annotations

import asyncio
from logging.config import fileConfig
import os
import sys

# Ensure project root is on PYTHONPATH so `import app` works when running alembic
CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

from app.infrastructure.config import get_settings
from app.infrastructure.db.base import Base
from app.infrastructure.db import models  # noqa: F401

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


def get_url() -> str:
    return get_settings().DATABASE_URL


def run_migrations_offline() -> None:
    url = get_url()
    context.configure(
        url=url,
        target_metadata=Base.metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=Base.metadata, compare_type=True)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    connectable = create_async_engine(get_url(), poolclass=pool.NullPool)

    async def run_migrations() -> None:
        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

    asyncio.run(run_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0001_init.py ---
from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = "0001_init"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "users",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("email", sa.String(254), nullable=False, unique=True, index=True),
        sa.Column("username", sa.String(50), nullable=False, unique=True, index=True),
        sa.Column("password_hash", sa.String(255), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "rooms",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("name", sa.String(100), nullable=False),
        sa.Column("owner_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("is_private", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "participants",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("user_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("role", sa.String(20), nullable=False),
        sa.Column("muted", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("joined_at", sa.DateTime(timezone=False), nullable=False),
        sa.Column("left_at", sa.DateTime(timezone=False), nullable=True),
    )

    op.create_table(
        "messages",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("author_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("content", sa.Text(), nullable=False),
        sa.Column("sent_at", sa.DateTime(timezone=False), nullable=False, index=True),
    )


def downgrade() -> None:
    op.drop_table("messages")
    op.drop_table("participants")
    op.drop_table("rooms")
    op.drop_table("users")
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\auth.py ---
from __future__ import annotations

from pydantic import BaseModel, EmailStr, Field


class RegisterInput(BaseModel):
    email: EmailStr
    username: str = Field(min_length=3, max_length=50)
    password: str = Field(min_length=6, max_length=128)


class RegisterOutput(BaseModel):
    id: str
    email: EmailStr
    username: str


class LoginInput(BaseModel):
    email: EmailStr
    password: str


class TokenOutput(BaseModel):
    access_token: str
    token_type: str = "bearer"
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\messages.py ---
from __future__ import annotations

from datetime import datetime
from pydantic import BaseModel, Field


class PostMessageInput(BaseModel):
    room_id: str
    author_id: str
    content: str = Field(min_length=1, max_length=2000)


class MessageDTO(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\rooms.py ---
from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class CreateRoomInput(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomDTO(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class ListRoomsInput(BaseModel):
    owner_id: Optional[str] = None
    skip: int = 0
    limit: int = 50
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\auth.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import User
from ...core.errors import AuthError, ConflictError, NotFoundError
from ...core.ports.repositories import UserRepository
from ...core.ports.services import PasswordHasher, TokenProvider


class RegisterUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher) -> None:
        self.users = users
        self.hasher = hasher

    async def execute(self, email: str, username: str, password: str) -> User:
        if await self.users.get_by_email(email):
            raise ConflictError("Email already registered")
        if await self.users.get_by_username(username):
            raise ConflictError("Username already taken")
        pwd_hash = self.hasher.hash(password)
        user = User.create(email=email, username=username, password_hash=pwd_hash)
        await self.users.add(user)
        return user


class LoginUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher, tokens: TokenProvider) -> None:
        self.users = users
        self.hasher = hasher
        self.tokens = tokens

    async def execute(self, email: str, password: str) -> str:
        user = await self.users.get_by_email(email)
        if not user or not self.hasher.verify(password, str(user.password_hash)):
            raise AuthError("Invalid credentials")
        return self.tokens.create_access_token(str(user.id), None)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\messages.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Message
from ...core.ports.repositories import MessageRepository


class PostMessage:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, author_id: UUID, content: str) -> Message:
        msg = Message.post(room_id=room_id, author_id=author_id, content=content)
        await self.messages.add(msg)
        return msg


class ListMessages:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        return await self.messages.list(room_id=room_id, skip=skip, limit=limit)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\participants.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Participant, Role
from ...core.errors import NotFoundError
from ...core.ports.repositories import ParticipantRepository, RoomRepository
from ...core.services.room_service import RoomService


class JoinRoom:
    def __init__(self, participants: ParticipantRepository, rooms: RoomRepository, policy: RoomService) -> None:
        self.participants = participants
        self.rooms = rooms
        self.policy = policy

    async def execute(self, room_id: UUID, user_id: UUID, role: Role = Role.member) -> Participant:
        room = await self.rooms.get(room_id)
        if not room:
            raise NotFoundError("Room not found")
        active = await self.participants.list_active(room_id)
        self.policy.can_join(room, active)
        participant = Participant.join(user_id=user_id, room_id=room_id, role=role)
        await self.participants.add(participant)
        return participant


class LeaveRoom:
    def __init__(self, participants: ParticipantRepository) -> None:
        self.participants = participants

    async def execute(self, room_id: UUID, user_id: UUID) -> None:
        p = await self.participants.get(room_id, user_id)
        if p:
            p.left_at = p.left_at or p.joined_at
            await self.participants.update(p)


class KickParticipant:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_kick(actor.role, target.role)
        await self.participants.remove(room_id, target_id)


class ToggleMute:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_toggle_mute(actor.role, target.role)
        target.muted = not target.muted
        await self.participants.update(target)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\rooms.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from ...core.domain.models import Room
from ...core.ports.repositories import RoomRepository


class CreateRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, name: str, owner_id: UUID, is_private: bool = False) -> Room:
        room = Room.create(name=name, owner_id=owner_id, is_private=is_private)
        await self.rooms.add(room)
        return room


class ListRooms:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, owner_id: Optional[UUID] = None, skip: int = 0, limit: int = 50) -> list[Room]:
        return await self.rooms.list(owner_id=owner_id, skip=skip, limit=limit)


class GetRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> Optional[Room]:
        return await self.rooms.get(room_id)


class DeleteRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> None:
        await self.rooms.delete(room_id)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\signals.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class PublishSignal:
    def __init__(self, bus: SignalBus) -> None:
        self.bus = bus

    async def execute(
        self, *, room_id: UUID, sender_id: UUID, type: str, sdp: str | None = None, candidate: dict | None = None, target_id: UUID | None = None
    ) -> None:
        signal = Signal.create(type=type, sender_id=sender_id, room_id=room_id, sdp=sdp, candidate=candidate, target_id=target_id)
        await self.bus.publish(room_id, signal)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\asgi.py ---
from __future__ import annotations

from .main import create_app

app = create_app()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\main.py ---
from __future__ import annotations

import logging
from contextlib import asynccontextmanager

from fastapi import Depends, FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

from ..infrastructure.config import get_settings
from ..infrastructure.logging import configure_logging
from ..presentation.docs import get_openapi_tags
from ..presentation.api.routers import auth as auth_router
from ..presentation.api.routers import rooms as rooms_router
from ..presentation.api.routers import participants as participants_router
from ..presentation.api.routers import messages as messages_router
from ..presentation.api.routers import webrtc as webrtc_router
from ..presentation.api.deps.containers import (
    get_user_repo,
    get_room_repo,
    get_participant_repo,
    get_message_repo,
    get_password_hasher,
    get_token_provider,
    get_signal_bus,
    get_ice_provider,
)
from ..presentation.ws import rooms as ws_rooms
from ..presentation.api.deps.db import get_db_session
from ..infrastructure.db.repositories.users import PgUserRepository
from ..infrastructure.db.repositories.rooms import PgRoomRepository
from ..infrastructure.db.repositories.participants import PgParticipantRepository
from ..infrastructure.db.repositories.messages import PgMessageRepository
from ..infrastructure.security.jwt_provider import JoseTokenProvider
from ..infrastructure.security.password_hasher import BcryptPasswordHasher
from ..infrastructure.messaging.redis_bus import RedisSignalBus
from ..infrastructure.ice.provider import EnvIceConfigProvider
from ..presentation.errors import setup_error_handlers


@asynccontextmanager
async def lifespan(app: FastAPI):
    # here we could init DB/Redis connections if needed globally
    yield


def create_app() -> FastAPI:
    settings = get_settings()
    configure_logging(logging.INFO)

    app = FastAPI(
        title=settings.APP_NAME,
        description="WebRTC signaling server with REST and WebSocket",
        version="0.1.0",
        docs_url="/docs",
        redoc_url="/redoc",
        openapi_tags=get_openapi_tags(),
        lifespan=lifespan,
    )

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    setup_error_handlers(app)

    # Routers
    app.include_router(auth_router.router)
    app.include_router(rooms_router.router)
    app.include_router(participants_router.router)
    app.include_router(messages_router.router)
    app.include_router(webrtc_router.router)

    # WS
    app.include_router(ws_rooms.router)

    # Static demo
    app.mount("/static", StaticFiles(directory="app/presentation/static"), name="static")

    @app.get("/healthz", tags=["health"])
    async def healthz():
        return {"status": "ok"}

    return app
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\errors.py ---
from dataclasses import dataclass


class DomainError(Exception):
    """Базовая доменная ошибка."""


class ValidationError(DomainError):
    pass


class AuthError(DomainError):
    pass


class NotFoundError(DomainError):
    pass


class PermissionDenied(DomainError):
    pass


class ConflictError(DomainError):
    pass


@dataclass(slots=True)
class ErrorResponse:
    detail: str
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\models.py ---
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from .values import Email, PasswordHash, RoomName


class Role(str, Enum):
    owner = "owner"
    moderator = "moderator"
    member = "member"


@dataclass(slots=True)
class User:
    id: UUID
    email: Email
    username: str
    password_hash: PasswordHash
    created_at: datetime

    @staticmethod
    def create(email: str, username: str, password_hash: str) -> "User":
        return User(
            id=uuid4(),
            email=Email(email),
            username=username,
            password_hash=PasswordHash(password_hash),
            created_at=datetime.utcnow(),
        )


@dataclass(slots=True)
class Room:
    id: UUID
    name: RoomName
    owner_id: UUID
    is_private: bool
    created_at: datetime

    @staticmethod
    def create(name: str, owner_id: UUID, is_private: bool = False) -> "Room":
        return Room(id=uuid4(), name=RoomName(name), owner_id=owner_id, is_private=is_private, created_at=datetime.utcnow())


@dataclass(slots=True)
class Participant:
    id: UUID
    user_id: UUID
    room_id: UUID
    role: Role
    muted: bool
    joined_at: datetime
    left_at: Optional[datetime] = None

    @staticmethod
    def join(user_id: UUID, room_id: UUID, role: Role) -> "Participant":
        return Participant(id=uuid4(), user_id=user_id, room_id=room_id, role=role, muted=False, joined_at=datetime.utcnow())


@dataclass(slots=True)
class Message:
    id: UUID
    room_id: UUID
    author_id: UUID
    content: str
    sent_at: datetime

    @staticmethod
    def post(room_id: UUID, author_id: UUID, content: str) -> "Message":
        return Message(id=uuid4(), room_id=room_id, author_id=author_id, content=content[:2000], sent_at=datetime.utcnow())


class SignalType(str, Enum):
    offer = "offer"
    answer = "answer"
    ice_candidate = "ice-candidate"


@dataclass(slots=True)
class Signal:
    type: SignalType
    sender_id: UUID
    room_id: UUID
    sent_at: datetime
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    target_id: Optional[UUID] = None

    @staticmethod
    def create(type: str, sender_id: UUID, room_id: UUID, sdp: Optional[str] = None, candidate: Optional[dict] = None, target_id: Optional[UUID] = None) -> "Signal":
        st = SignalType(type)
        return Signal(type=st, sender_id=sender_id, room_id=room_id, sent_at=datetime.utcnow(), sdp=sdp, candidate=candidate, target_id=target_id)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\values.py ---
from __future__ import annotations

import re
from dataclasses import dataclass

from ..errors import ValidationError


EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")


@dataclass(frozen=True, slots=True)
class Email:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip().lower()
        if not EMAIL_RE.match(v):
            raise ValidationError("Invalid email format")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:  # for convenience
        return self.value


@dataclass(frozen=True, slots=True)
class RoomName:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip()
        if not (1 <= len(v) <= 100):
            raise ValidationError("Room name must be 1..100 chars")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:
        return self.value


@dataclass(frozen=True, slots=True)
class PasswordHash:
    value: str

    def __post_init__(self) -> None:
        if not self.value or len(self.value) < 10:
            # bcrypt hashes are long; minimal sanity check
            raise ValidationError("Password hash looks invalid")

    def __str__(self) -> str:
        return self.value
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\repositories.py ---
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Optional
from uuid import UUID

from ..domain.models import Message, Participant, Room, User


class UserRepository(ABC):
    @abstractmethod
    async def get_by_email(self, email: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_username(self, username: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_id(self, user_id: UUID) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, user: User) -> None:
        raise NotImplementedError


class RoomRepository(ABC):
    @abstractmethod
    async def add(self, room: Room) -> None:
        raise NotImplementedError

    @abstractmethod
    async def get(self, room_id: UUID) -> Optional[Room]:
        raise NotImplementedError

    @abstractmethod
    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:
        raise NotImplementedError

    @abstractmethod
    async def delete(self, room_id: UUID) -> None:
        raise NotImplementedError


class ParticipantRepository(ABC):
    @abstractmethod
    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def list_active(self, room_id: UUID) -> list[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def update(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def remove(self, room_id: UUID, user_id: UUID) -> None:
        raise NotImplementedError


class MessageRepository(ABC):
    @abstractmethod
    async def add(self, message: Message) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        raise NotImplementedError
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\services.py ---
from __future__ import annotations

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any
from uuid import UUID

from ..domain.models import Signal


class SignalBus(ABC):
    @abstractmethod
    async def publish(self, room_id: UUID, signal: Signal) -> None:
        raise NotImplementedError

    @abstractmethod
    async def subscribe(self, room_id: UUID):
        """Возвращает асинхронный итератор по сообщениям Signal."""
        raise NotImplementedError

    @abstractmethod
    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        raise NotImplementedError


class PasswordHasher(ABC):
    @abstractmethod
    def hash(self, password: str) -> str:
        raise NotImplementedError

    @abstractmethod
    def verify(self, password: str, password_hash: str) -> bool:
        raise NotImplementedError


class TokenProvider(ABC):
    @abstractmethod
    def create_access_token(self, subject: str, expires_minutes: int) -> str:
        raise NotImplementedError

    @abstractmethod
    def decode_token(self, token: str) -> dict:
        raise NotImplementedError


class Clock(ABC):
    @abstractmethod
    def now(self) -> datetime:
        raise NotImplementedError


class IceConfigProvider(ABC):
    @abstractmethod
    async def get_servers(self) -> list[dict]:
        raise NotImplementedError
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\room_service.py ---
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Iterable
from uuid import UUID

from ..domain.models import Participant, Role, Room
from ..errors import PermissionDenied, ValidationError


@dataclass(slots=True)
class RoomPolicy:
    max_participants: int = 16


class RoomService:
    def __init__(self, policy: RoomPolicy | None = None) -> None:
        self.policy = policy or RoomPolicy()

    def can_join(self, room: Room, participants: Iterable[Participant]) -> None:
        count = sum(1 for p in participants if p.left_at is None)
        if count >= self.policy.max_participants:
            raise ValidationError("Room is full")

    def ensure_can_kick(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can kick")
        if actor_role == Role.moderator and target_role in {Role.owner, Role.moderator}:
            raise PermissionDenied("Moderator cannot kick owner/moderator")

    def ensure_can_toggle_mute(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can mute")

    def leave(self, participant: Participant) -> Participant:
        if participant.left_at is None:
            participant.left_at = datetime.utcnow()
        return participant
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\config.py ---
from __future__ import annotations

from functools import lru_cache
from typing import List

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)

    # App
    APP_NAME: str = "WebCall"
    APP_ENV: str = "dev"
    API_PREFIX: str = "/api/v1"
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Security
    JWT_SECRET: str = "change_me"
    JWT_EXPIRES_MIN: int = 60

    # Databases
    DATABASE_URL: str
    REDIS_URL: str

    # CORS
    CORS_ORIGINS: List[str] = Field(default_factory=lambda: ["http://localhost:5173", "http://localhost:8000"])  # type: ignore[assignment]

    # WebRTC ICE
    STUN_SERVERS: List[str] = Field(default_factory=lambda: ["stun:stun.l.google.com:19302"])  # type: ignore[assignment]
    TURN_URL: str | None = None
    TURN_USERNAME: str | None = None
    TURN_PASSWORD: str | None = None


@lru_cache()
def get_settings() -> Settings:
    s = Settings()
    # allow comma-separated env for lists
    if isinstance(s.CORS_ORIGINS, str):  # type: ignore[unreachable]
        s.CORS_ORIGINS = [x.strip() for x in s.CORS_ORIGINS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if isinstance(s.STUN_SERVERS, str):  # type: ignore[unreachable]
        s.STUN_SERVERS = [x.strip() for x in s.STUN_SERVERS.split(",") if x.strip()]  # type: ignore[attr-defined]
    return s
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\logging.py ---
import json
import logging
from typing import Any


class JsonFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:  # type: ignore[override]
        data: dict[str, Any] = {
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        if record.exc_info:
            data["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(data, ensure_ascii=False)


def configure_logging(level: int = logging.INFO) -> None:
    handler = logging.StreamHandler()
    handler.setFormatter(JsonFormatter())
    root = logging.getLogger()
    root.handlers.clear()
    root.addHandler(handler)
    root.setLevel(level)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\base.py ---
from __future__ import annotations

from sqlalchemy.orm import DeclarativeBase, declared_attr


class Base(DeclarativeBase):
    __abstract__ = True

    @declared_attr.directive
    def __tablename__(cls) -> str:  # type: ignore[override]
        return cls.__name__.lower()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\models.py ---
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from sqlalchemy import Boolean, DateTime, ForeignKey, String, Text
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import Base


class Users(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    email: Mapped[str] = mapped_column(String(254), unique=True, index=True, nullable=False)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    rooms = relationship("Rooms", back_populates="owner")


class Rooms(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    owner_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    is_private: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    owner = relationship("Users", back_populates="rooms")


class Participants(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    user_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    role: Mapped[str] = mapped_column(String(20), nullable=False)
    muted: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    joined_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    left_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False), nullable=True)


class Messages(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    author_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    sent_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False, index=True)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\session.py ---
from __future__ import annotations

from contextlib import asynccontextmanager
from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from ..config import get_settings


_settings = get_settings()
ENGINE: AsyncEngine = create_async_engine(_settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = sessionmaker(bind=ENGINE, class_=AsyncSession, expire_on_commit=False)


@asynccontextmanager
async def get_session() -> AsyncIterator[AsyncSession]:
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        yield session
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\messages.py ---
from __future__ import annotations

from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Message
from ....core.ports.repositories import MessageRepository
from ..models import Messages


class PgMessageRepository(MessageRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, message: Message) -> None:  # type: ignore[override]
        self.session.add(
            Messages(
                id=message.id,
                room_id=message.room_id,
                author_id=message.author_id,
                content=message.content,
                sent_at=message.sent_at,
            )
        )
        await self.session.commit()

    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:  # type: ignore[override]
        stmt = select(Messages).where(Messages.room_id == room_id).order_by(Messages.sent_at.asc()).offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Message(id=r.id, room_id=r.room_id, author_id=r.author_id, content=r.content, sent_at=r.sent_at) for r in rows]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\participants.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Participant, Role
from ....core.ports.repositories import ParticipantRepository
from ..models import Participants


class PgParticipantRepository(ParticipantRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return Participant(
                id=row.id,
                user_id=row.user_id,
                room_id=row.room_id,
                role=Role(row.role),
                muted=row.muted,
                joined_at=row.joined_at,
                left_at=row.left_at,
            )
        return None

    async def list_active(self, room_id: UUID) -> list[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.left_at.is_(None))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [
            Participant(id=r.id, user_id=r.user_id, room_id=r.room_id, role=Role(r.role), muted=r.muted, joined_at=r.joined_at, left_at=r.left_at)
            for r in rows
        ]

    async def add(self, participant: Participant) -> None:  # type: ignore[override]
        self.session.add(
            Participants(
                id=participant.id,
                user_id=participant.user_id,
                room_id=participant.room_id,
                role=participant.role.value,
                muted=participant.muted,
                joined_at=participant.joined_at,
                left_at=participant.left_at,
            )
        )
        await self.session.commit()

    async def update(self, participant: Participant) -> None:  # type: ignore[override]
        await self.session.execute(
            update(Participants)
            .where(Participants.id == participant.id)
            .values(muted=participant.muted, left_at=participant.left_at)
        )
        await self.session.commit()

    async def remove(self, room_id: UUID, user_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(
            delete(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        )
        await self.session.commit()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\rooms.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Room
from ....core.domain.values import RoomName
from ....core.ports.repositories import RoomRepository
from ..models import Rooms


class PgRoomRepository(RoomRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, room: Room) -> None:  # type: ignore[override]
        self.session.add(
            Rooms(id=room.id, name=str(room.name), owner_id=room.owner_id, is_private=room.is_private, created_at=room.created_at)
        )
        await self.session.commit()

    async def get(self, room_id: UUID) -> Optional[Room]:  # type: ignore[override]
        row = await self.session.get(Rooms, room_id)
        if not row:
            return None
        return Room(id=row.id, name=RoomName(row.name), owner_id=row.owner_id, is_private=row.is_private, created_at=row.created_at)

    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:  # type: ignore[override]
        stmt = select(Rooms)
        if owner_id:
            stmt = stmt.where(Rooms.owner_id == owner_id)
        stmt = stmt.offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Room(id=r.id, name=RoomName(r.name), owner_id=r.owner_id, is_private=r.is_private, created_at=r.created_at) for r in rows]

    async def delete(self, room_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(delete(Rooms).where(Rooms.id == room_id))
        await self.session.commit()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\users.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import User
from ....core.domain.values import Email, PasswordHash
from ....core.ports.repositories import UserRepository
from ..models import Users
from ....core.errors import ConflictError


class PgUserRepository(UserRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_email(self, email: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.email == email)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_id(self, user_id: UUID) -> Optional[User]:  # type: ignore[override]
        row = await self.session.get(Users, user_id)
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_username(self, username: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.username == username)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def add(self, user: User) -> None:  # type: ignore[override]
        self.session.add(Users(id=user.id, email=str(user.email), username=user.username, password_hash=str(user.password_hash), created_at=user.created_at))
        try:
            await self.session.commit()
        except IntegrityError as e:
            await self.session.rollback()
            # Переводим БД-ошибку в доменную 409
            raise ConflictError("User with same email or username already exists") from e
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\provider.py ---
from __future__ import annotations

from ...core.ports.services import IceConfigProvider
from ..config import get_settings


class EnvIceConfigProvider(IceConfigProvider):
    async def get_servers(self) -> list[dict]:  # type: ignore[override]
        s = get_settings()
        servers: list[dict] = []
        if s.STUN_SERVERS:
            servers.append({"urls": s.STUN_SERVERS})
        if s.TURN_URL and s.TURN_USERNAME and s.TURN_PASSWORD:
            servers.append(
                {
                    "urls": [s.TURN_URL],
                    "username": s.TURN_USERNAME,
                    "credential": s.TURN_PASSWORD,
                }
            )
        return servers
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\inmemory_bus.py ---
from __future__ import annotations

import asyncio
from collections import defaultdict
from typing import AsyncIterator, Dict, List
from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class InMemorySignalBus(SignalBus):
    def __init__(self) -> None:
        self.queues: Dict[UUID, List[asyncio.Queue[Signal]]] = defaultdict(list)
        self._presence: Dict[UUID, set[str]] = defaultdict(set)

    async def publish(self, room_id: UUID, signal: Signal) -> None:  # type: ignore[override]
        for q in list(self.queues[room_id]):
            await q.put(signal)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:  # type: ignore[override]
        q: asyncio.Queue[Signal] = asyncio.Queue()
        self.queues[room_id].append(q)
        try:
            while True:
                try:
                    s = await q.get()
                except asyncio.CancelledError:
                    # нормальный выход при отмене таска-подписчика
                    break
                else:
                    yield s
        finally:
            self.queues[room_id].remove(q)

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:  # type: ignore[override]
        if present:
            self._presence[room_id].add(str(user_id))
        else:
            self._presence[room_id].discard(str(user_id))

    async def list_presence(self, room_id: UUID) -> List[dict]:  # type: ignore[override]
        return [{"user_id": uid, "present": True} for uid in self._presence[room_id]]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\redis_bus.py ---
from __future__ import annotations

import asyncio
import json
from typing import Any, AsyncIterator
from uuid import UUID

import redis.asyncio as aioredis

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus
from ..config import get_settings


class RedisSignalBus(SignalBus):
    def __init__(self, redis: aioredis.Redis | None = None) -> None:
        self.settings = get_settings()
        self.redis = redis or aioredis.from_url(self.settings.REDIS_URL, decode_responses=True)

    def _channel(self, room_id: UUID) -> str:
        return f"room:{room_id}:signals"

    def _presence_key(self, room_id: UUID) -> str:
        return f"room:{room_id}:presence"

    async def publish(self, room_id: UUID, signal: Signal) -> None:
        payload = json.dumps(
            {
                "type": signal.type.value,
                "sender_id": str(signal.sender_id),
                "target_id": str(signal.target_id) if signal.target_id else None,
                "room_id": str(signal.room_id),
                "sdp": signal.sdp,
                "candidate": signal.candidate,
                "sent_at": signal.sent_at.isoformat(),
            }
        )
        await self.redis.publish(self._channel(room_id), payload)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:
        pubsub = self.redis.pubsub()
        await pubsub.subscribe(self._channel(room_id))
        try:
            async for msg in pubsub.listen():
                if msg["type"] != "message":
                    continue
                data = json.loads(msg["data"])  # type: ignore[arg-type]
                yield Signal.create(
                    type=data["type"],
                    sender_id=UUID(data["sender_id"]),
                    room_id=UUID(data["room_id"]),
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["target_id"]) if data.get("target_id") else None,
                )
        finally:
            await pubsub.unsubscribe(self._channel(room_id))
            await pubsub.close()

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        key = self._presence_key(room_id)
        if present:
            await self.redis.hset(key, str(user_id), json.dumps({"present": True}))
        else:
            await self.redis.hdel(key, str(user_id))
        await self.redis.expire(key, 60 * 60)

    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        key = self._presence_key(room_id)
        data = await self.redis.hgetall(key)
        result: list[dict[str, Any]] = []
        for uid, v in data.items():
            try:
                obj = json.loads(v)
            except Exception:
                obj = {"present": True}
            obj["user_id"] = uid
            result.append(obj)
        return result
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\jwt_provider.py ---
from __future__ import annotations

from datetime import datetime, timedelta, timezone

from jose import JWTError, jwt

from ...core.ports.services import TokenProvider
from ..config import get_settings


class JoseTokenProvider(TokenProvider):
    def __init__(self) -> None:
        self.settings = get_settings()
        self.algorithm = "HS256"

    def create_access_token(self, subject: str, expires_minutes: int | None = None) -> str:  # type: ignore[override]
        expires_minutes = expires_minutes or self.settings.JWT_EXPIRES_MIN
        now = datetime.now(tz=timezone.utc)
        payload = {"sub": subject, "iat": int(now.timestamp()), "exp": int((now + timedelta(minutes=expires_minutes)).timestamp())}
        return jwt.encode(payload, self.settings.JWT_SECRET, algorithm=self.algorithm)

    def decode_token(self, token: str) -> dict:  # type: ignore[override]
        try:
            return jwt.decode(token, self.settings.JWT_SECRET, algorithms=[self.algorithm])
        except JWTError as e:
            raise ValueError("Invalid token") from e
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\password_hasher.py ---
from __future__ import annotations

from passlib.context import CryptContext

from ...core.ports.services import PasswordHasher


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class BcryptPasswordHasher(PasswordHasher):
    def hash(self, password: str) -> str:
        return pwd_context.hash(password)

    def verify(self, password: str, password_hash: str) -> bool:
        return pwd_context.verify(password, password_hash)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\docs.py ---
from __future__ import annotations

from typing import List


def get_openapi_tags() -> List[dict]:
    return [
        {"name": "auth", "description": "Аутентификация"},
        {"name": "rooms", "description": "Комнаты"},
        {"name": "participants", "description": "Участники"},
        {"name": "messages", "description": "Сообщения"},
        {"name": "webrtc", "description": "WebRTC вспомогательные"},
        {"name": "health", "description": "Health checks"},
    ]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\errors.py ---
from __future__ import annotations

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

from ..core.errors import AuthError, ConflictError, DomainError, NotFoundError, PermissionDenied, ValidationError


def setup_error_handlers(app: FastAPI) -> None:
    @app.exception_handler(ValidationError)
    async def _validation(_: Request, exc: ValidationError):
        return JSONResponse(status_code=400, content={"detail": str(exc)})

    @app.exception_handler(AuthError)
    async def _auth(_: Request, exc: AuthError):
        return JSONResponse(status_code=401, content={"detail": str(exc)})

    @app.exception_handler(NotFoundError)
    async def _not_found(_: Request, exc: NotFoundError):
        return JSONResponse(status_code=404, content={"detail": str(exc)})

    @app.exception_handler(ConflictError)
    async def _conflict(_: Request, exc: ConflictError):
        return JSONResponse(status_code=409, content={"detail": str(exc)})

    @app.exception_handler(PermissionDenied)
    async def _forbidden(_: Request, exc: PermissionDenied):
        return JSONResponse(status_code=403, content={"detail": str(exc)}).
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\auth.py ---
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

from ....core.errors import NotFoundError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import TokenProvider
from .containers import get_user_repo, get_token_provider


bearer_scheme = HTTPBearer(auto_error=False)


async def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials | None, Depends(bearer_scheme)],
    users: UserRepository = Depends(get_user_repo),
    tokens: TokenProvider = Depends(get_token_provider),
):
    if not credentials:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    try:
        payload = tokens.decode_token(credentials.credentials)
        sub = payload.get("sub")
        user = await users.get_by_id(UUID(sub))
        if not user:
            raise NotFoundError()
        return user
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\containers.py ---
from __future__ import annotations

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session
from ....infrastructure.db.session import get_session as _get_session
from ....infrastructure.db.repositories.users import PgUserRepository
from ....infrastructure.db.repositories.rooms import PgRoomRepository
from ....infrastructure.db.repositories.participants import PgParticipantRepository
from ....infrastructure.db.repositories.messages import PgMessageRepository
from ....infrastructure.security.password_hasher import BcryptPasswordHasher
from ....infrastructure.security.jwt_provider import JoseTokenProvider
from ....infrastructure.ice.provider import EnvIceConfigProvider


# DB session
# DB session provider
async def get_db_session() -> AsyncSession:
    async with _get_session() as s:  # type: ignore[misc]
        return s
from ....infrastructure.messaging.redis_bus import RedisSignalBus
from ....infrastructure.messaging.inmemory_bus import InMemorySignalBus
from ....infrastructure.config import get_settings
from functools import lru_cache


# Repositories
async def get_user_repo(session: AsyncSession = Depends(get_db_session)):
    return PgUserRepository(session)


async def get_room_repo(session: AsyncSession = Depends(get_db_session)):
    return PgRoomRepository(session)


async def get_participant_repo(session: AsyncSession = Depends(get_db_session)):
    return PgParticipantRepository(session)


async def get_message_repo(session: AsyncSession = Depends(get_db_session)):
    return PgMessageRepository(session)


# Services
def get_password_hasher():
    return BcryptPasswordHasher()


def get_token_provider():
    return JoseTokenProvider()


def get_signal_bus():
    # Singleton SignalBus per process to ensure all WS share the same bus
    return _get_signal_bus_singleton()


@lru_cache(maxsize=1)
def _get_signal_bus_singleton():
    s = get_settings()
    # Use in-memory bus by default for local/dev/testing; switch to Redis via env
    if s.APP_ENV in {"dev", "test"}:
        return InMemorySignalBus()
    return RedisSignalBus()


def get_ice_provider():
    return EnvIceConfigProvider()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\db.py ---
from __future__ import annotations

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session


async def get_db_session() -> AsyncIterator[AsyncSession]:
    async with get_session() as session:
        yield session
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\auth.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from ....application.dto.auth import LoginInput, RegisterInput, RegisterOutput, TokenOutput
from ....core.domain.models import User
from ....core.errors import ConflictError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import PasswordHasher, TokenProvider
from ..deps.containers import get_password_hasher, get_token_provider, get_user_repo

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])


@router.post("/register", response_model=RegisterOutput, status_code=status.HTTP_201_CREATED)
async def register(
    data: RegisterInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
) -> RegisterOutput:  # type: ignore[override]
    from ....application.use_cases.auth import RegisterUser

    use = RegisterUser(users, hasher)
    user = await use.execute(email=data.email, username=data.username, password=data.password)
    return RegisterOutput(id=str(user.id), email=str(user.email), username=user.username)


@router.post("/login", response_model=TokenOutput)
async def login(
    data: LoginInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
    tokens: TokenProvider = Depends(get_token_provider),
) -> TokenOutput:  # type: ignore[override]
    from ....application.use_cases.auth import LoginUser

    use = LoginUser(users, hasher, tokens)
    access = await use.execute(email=data.email, password=data.password)
    return TokenOutput(access_token=access)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\messages.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.messages import MessageDTO, PostMessageInput
from ....application.use_cases.messages import ListMessages, PostMessage
from ....core.ports.repositories import MessageRepository
from ..deps.containers import get_message_repo

router = APIRouter(prefix="/api/v1/rooms/{room_id}/messages", tags=["messages"])


@router.post("", response_model=MessageDTO)
async def post_message(room_id: str, data: PostMessageInput, messages: MessageRepository = Depends(get_message_repo)) -> MessageDTO:  # type: ignore[override]
    use = PostMessage(messages)
    msg = await use.execute(room_id=UUID(room_id), author_id=UUID(data.author_id), content=data.content)
    return MessageDTO(id=str(msg.id), room_id=str(msg.room_id), author_id=str(msg.author_id), content=msg.content, sent_at=msg.sent_at)


@router.get("", response_model=list[MessageDTO])
async def list_messages(room_id: str, skip: int = 0, limit: int = 50, messages: MessageRepository = Depends(get_message_repo)):  # type: ignore[override]
    use = ListMessages(messages)
    items = await use.execute(room_id=UUID(room_id), skip=skip, limit=limit)
    return [MessageDTO(id=str(m.id), room_id=str(m.room_id), author_id=str(m.author_id), content=m.content, sent_at=m.sent_at) for m in items]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\participants.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException

from ....application.use_cases.participants import JoinRoom, KickParticipant, LeaveRoom, ToggleMute
from ....core.domain.models import Role
from ....core.errors import NotFoundError
from ....core.ports.repositories import ParticipantRepository, RoomRepository
from ..deps.containers import get_participant_repo, get_room_repo
from ....core.services.room_service import RoomService

router = APIRouter(prefix="/api/v1/rooms/{room_id}", tags=["participants"])


@router.post("/join")
async def join_room(
    room_id: str,
    user_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
    rooms: RoomRepository = Depends(get_room_repo),
) -> dict:  # type: ignore[override]
    use = JoinRoom(participants, rooms, RoomService())
    p = await use.execute(room_id=UUID(room_id), user_id=UUID(user_id), role=Role.member)
    return {"status": "ok", "participantId": str(p.id)}


@router.post("/leave")
async def leave_room(room_id: str, user_id: str, participants: ParticipantRepository = Depends(get_participant_repo)) -> dict:  # type: ignore[override]
    use = LeaveRoom(participants)
    await use.execute(room_id=UUID(room_id), user_id=UUID(user_id))
    return {"status": "ok"}


@router.post("/kick/{target_id}")
async def kick(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = KickParticipant(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}


@router.post("/toggle-mute/{target_id}")
async def toggle_mute(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = ToggleMute(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\rooms.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.rooms import CreateRoomInput, ListRoomsInput, RoomDTO
from ....application.use_cases.rooms import CreateRoom, GetRoom, ListRooms
from ....core.ports.repositories import RoomRepository
from ..deps.containers import get_room_repo
from ..deps.auth import get_current_user

router = APIRouter(prefix="/api/v1/rooms", tags=["rooms"])


@router.post("", response_model=RoomDTO)
async def create_room(
    data: CreateRoomInput,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = CreateRoom(rooms)
    room = await use.execute(name=data.name, owner_id=UUID(str(current_user.id)), is_private=data.is_private)
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.get("", response_model=list[RoomDTO])
async def list_rooms(
    owner_id: str | None = None,
    skip: int = 0,
    limit: int = 50,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    use = ListRooms(rooms)
    rid = UUID(owner_id) if owner_id else None
    items = await use.execute(owner_id=rid, skip=skip, limit=limit)
    return [RoomDTO(id=str(r.id), name=str(r.name), owner_id=str(r.owner_id), is_private=r.is_private, created_at=r.created_at) for r in items]


@router.get("/{room_id}", response_model=RoomDTO)
async def get_room(
    room_id: str,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = GetRoom(rooms)
    room = await use.execute(UUID(room_id))
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.delete("/{room_id}")
async def delete_room(
    room_id: str,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    from ....application.use_cases.rooms import DeleteRoom, GetRoom

    getter = GetRoom(rooms)
    room = await getter.execute(UUID(room_id))
    if not room or str(room.owner_id) != str(current_user.id):
        from fastapi import HTTPException, status

        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only owner can delete room")
    deleter = DeleteRoom(rooms)
    await deleter.execute(UUID(room_id))
    return {"status": "deleted"}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\webrtc.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends

from ....core.ports.services import IceConfigProvider
from ..deps.containers import get_ice_provider

router = APIRouter(prefix="/api/v1/webrtc", tags=["webrtc"])


@router.get("/ice-servers")
async def ice_servers(provider: IceConfigProvider = Depends(get_ice_provider)) -> dict:  # type: ignore[override]
    servers = await provider.get_servers()
    return {"iceServers": servers}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\schemas\api.py ---
from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class ErrorResponse(BaseModel):
    detail: str


class UserOut(BaseModel):
    id: str
    email: str
    username: str


class RoomCreateIn(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomOut(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class MessageIn(BaseModel):
    content: str = Field(min_length=1, max_length=2000)


class MessageOut(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime


class SignalIn(BaseModel):
    signalType: str
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    targetUserId: Optional[str] = None


class PresenceOut(BaseModel):
    users: list[dict]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\app.js ---
// Модульная версия UI подключается через /static/js/main.js
// Этот файл оставлен пустым намеренно.
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\index.html ---
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebCall Demo</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <header class="app-header">
      <div class="container header-inner">
        <div class="brand">
          <span class="logo" aria-hidden>●</span>
          <span class="title">WebCall</span>
        </div>
        <nav class="actions">
          <button class="btn ghost" id="btnToggleTheme" title="Переключить тему">🌓</button>
          <a class="btn ghost" href="/docs" target="_blank" rel="noreferrer">Docs</a>
        </nav>
      </div>
    </header>

    <main class="container app-main">
      <section class="panel grid-2">
        <div class="card">
          <h2>Авторизация</h2>
          <div class="form-grid">
            <label>
              <span>Email</span>
              <input id="email" type="email" placeholder="you@example.com" value="user@example.com" />
            </label>
            <label>
              <span>Пароль</span>
              <input id="password" type="password" placeholder="••••••••" value="string" />
            </label>
            <button id="btnLogin" class="btn primary">Войти</button>
            <div class="muted" id="loginNote">Демо-логин возвращает тестовый токен.</div>
          </div>
        </div>

        <div class="card">
          <h2>Комната</h2>
          <div class="form-grid">
            <label>
              <span>Room ID</span>
              <input id="roomId" placeholder="room-123" />
            </label>
            <div class="row">
              <button id="btnConnect" class="btn success">Подключиться</button>
              <button id="btnLeave" class="btn" disabled>Выйти</button>
              <button id="btnCopyLink" class="btn ghost">Скопировать ссылку</button>
            </div>
            <div class="muted" id="connStatus">Не подключено</div>
          </div>
        </div>
      </section>

      <section class="panel grid-3">
        <div class="card video-card">
          <div class="video-wrap">
            <video id="localVideo" autoplay playsinline muted></video>
          </div>
          <div class="controls">
            <button id="btnToggleMic" class="btn" disabled>🎤 Вкл/Выкл</button>
            <button id="btnToggleCam" class="btn" disabled>🎥 Вкл/Выкл</button>
          </div>
        </div>

        <div class="card video-card">
          <div class="video-wrap">
            <video id="remoteVideo" autoplay playsinline></video>
          </div>
          <div class="controls">
            <span class="muted">Удалённое видео</span>
          </div>
        </div>

        <div class="card chat-card">
          <h2>Чат</h2>
          <div id="chat" class="chat-log" aria-live="polite"></div>
          <div class="chat-input">
            <input id="chatInput" placeholder="Напишите сообщение..." />
            <button id="btnSend" class="btn" disabled>Отправить</button>
          </div>
        </div>
      </section>

      <section class="card panel">
        <h2>Логи</h2>
        <div id="logs" class="logs"></div>
      </section>
    </main>

    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>

    <script type="module" src="/static/js/main.js"></script>
  </body>
  </html>
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\styles.css ---
/* Theme */
:root{
  --bg:#0f172a; /* slate-900 */
  --panel:#111827; /* gray-900 */
  --card:#0b1220; /* custom */
  --text:#e5e7eb; /* gray-200 */
  --muted:#9ca3af; /* gray-400 */
  --primary:#6366f1; /* indigo-500 */
  --success:#22c55e; /* green-500 */
  --border:#1f2937; /* gray-800 */
  --ring:rgba(99,102,241,0.3);
}

html,body{height:100%}
body{
  margin:0; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  background:linear-gradient(180deg, #0f172a 0%, #0b1220 100%); color:var(--text);
}
.container{max-width:1200px;margin:0 auto;padding:16px}
.app-header{position:sticky;top:0;backdrop-filter: blur(6px);background:rgba(15,23,42,0.6);border-bottom:1px solid var(--border);}
.header-inner{display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;align-items:center;gap:10px}
.logo{display:inline-grid;place-items:center;width:24px;height:24px;border-radius:50%;background:conic-gradient(from 180deg, var(--primary), #14b8a6);box-shadow:0 0 20px rgba(99,102,241,0.5)}
.title{font-weight:700;letter-spacing:0.4px}
.actions{display:flex;gap:8px}

.app-main{display:flex;flex-direction:column;gap:16px}
.panel{background:transparent;border-radius:12px}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
.grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
@media(max-width:1000px){.grid-3{grid-template-columns:1fr 1fr}}
@media(max-width:700px){.grid-2,.grid-3{grid-template-columns:1fr}}

.card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid var(--border);border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,0.25)}
.card h2{margin:0 0 12px 0;font-size:18px}

.form-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.form-grid .row{grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap}
label{display:flex;flex-direction:column;gap:6px;font-size:14px;color:var(--muted)}
input{background:#0b1220;border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:8px;outline:none}
input:focus{border-color:var(--primary);box-shadow:0 0 0 4px var(--ring)}

.btn{background:#111827;border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:8px;cursor:pointer}
.btn:hover{border-color:#2a3347}
.btn:disabled{opacity:0.6;cursor:not-allowed}
.btn.primary{background:var(--primary);border-color:var(--primary)}
.btn.success{background:var(--success);border-color:var(--success)}
.btn.ghost{background:transparent}

.video-card .video-wrap{position:relative;aspect-ratio:16/9;background:#000;border-radius:10px;overflow:hidden;border:1px solid var(--border)}
video{width:100%;height:100%;object-fit:cover}
.controls{display:flex;gap:8px;margin-top:8px}

.chat-card{display:flex;flex-direction:column;gap:8px}
.chat-log{height:260px;overflow:auto;border:1px dashed var(--border);border-radius:8px;padding:8px;background:#0b1220}
.chat-input{display:flex;gap:8px}

.logs{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#0b1220;border:1px solid var(--border);border-radius:8px;min-height:120px;max-height:200px;overflow:auto;padding:8px;color:#cbd5e1}
.log-line{display:flex;gap:8px}
.log-line .time{color:#64748b}
.log-line .msg{flex:1}

.muted{color:var(--muted)}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\api.js ---
// api.js - REST helpers
const base = '';

export async function getIceServers() {
  const res = await fetch(`${base}/api/v1/webrtc/ice-servers`);
  if (!res.ok) throw new Error('Failed to fetch ICE servers');
  return res.json();
}

export async function login(email, password) {
  const res = await fetch(`${base}/api/v1/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Login failed: ${res.status} ${text}`);
  }
  return res.json(); // { access_token }
}

export function buildWs(roomId, token) {
  const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
  const qp = token ? `?token=${encodeURIComponent(token)}` : '';
  return new WebSocket(`${wsProto}://${location.host}/ws/rooms/${encodeURIComponent(roomId)}${qp}`);
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\main.js ---
// main.js - entry
import { buildWs, login as loginApi } from './api.js';
import { sendChat } from './signal.js';
import { WebRTCManager } from './webrtc.js';
import { bind, setText, setEnabled, appendLog, appendChat } from './ui.js';

let token = null;
let ws = null;
let rtc = null;
let outputDeviceId = null;
let userId = null;

const els = {
  email: document.getElementById('email'),
  password: document.getElementById('password'),
  btnLogin: document.getElementById('btnLogin'),
  roomId: document.getElementById('roomId'),
  btnConnect: document.getElementById('btnConnect'),
  btnLeave: document.getElementById('btnLeave'),
  btnCopyLink: document.getElementById('btnCopyLink'),
  btnSend: document.getElementById('btnSend'),
  chatInput: document.getElementById('chatInput'),
  connStatus: document.getElementById('connStatus'),
  logs: document.getElementById('logs'),
  chat: document.getElementById('chat'),
  btnToggleMic: document.getElementById('btnToggleMic'),
  btnToggleCam: document.getElementById('btnToggleCam'),
  localVideo: document.getElementById('localVideo'),
  remoteVideo: document.getElementById('remoteVideo'),
  btnToggleTheme: document.getElementById('btnToggleTheme'),
};

function log(msg){ appendLog(els.logs, msg); }

function setConnectedState(connected){
  setText(els.connStatus, connected ? 'Подключено' : 'Не подключено');
  setEnabled(els.btnSend, connected);
  setEnabled(els.btnLeave, connected);
  setEnabled(els.btnToggleMic, connected);
  setEnabled(els.btnToggleCam, connected);
}

async function login(){
  const email = els.email.value.trim();
  const password = els.password.value;
  try{
    const data = await loginApi(email, password);
    token = data.access_token;
  try{ userId = JSON.parse(atob(token.split('.')[1])).sub; }catch{}
    log('Вход выполнен');
  }catch(e){
    log(String(e));
  }
}

async function connect(){
  const roomId = els.roomId.value.trim();
  if (!roomId){ log('Введите Room ID'); return; }
  // Диагностика устройств перед подключением и выбор аудио-выхода
  if (navigator.mediaDevices?.enumerateDevices) {
    try {
      const devs = await navigator.mediaDevices.enumerateDevices();
      const summary = devs.map(d => `${d.kind}:${d.label||'(no label)'}:${(d.deviceId||'').slice(0,6)}`).join(' | ');
      log(`Devices: ${summary}`);
      const outs = devs.filter(d => d.kind === 'audiooutput');
      const concrete = outs.find(d => d.deviceId && !['default','communications'].includes(d.deviceId));
      outputDeviceId = (concrete || outs[0] || {}).deviceId || null;
      if (outputDeviceId) {
        const chosen = concrete || outs.find(d => d.deviceId === outputDeviceId) || {};
        log(`Using audiooutput: ${chosen.label || outputDeviceId}`);
      }
    } catch(e){ log(`enumerateDevices error: ${e?.name||e}`); }
  }
  ws = buildWs(roomId, token);
  ws.onopen = async () => {
    log('WS connected');
    setConnectedState(true);
    rtc = new WebRTCManager({
      localVideo: els.localVideo,
      remoteVideo: els.remoteVideo,
      outputDeviceId,
      onLog: log,
      onConnected: ()=>log('P2P connected'),
      onDisconnected: ()=>log('P2P disconnected'),
    });
    if (!userId){
      // dev/test: временный случайный id (для работы без логина)
      userId = crypto.randomUUID();
    }
    try {
      await rtc.start(ws, userId);
    } catch (e) {
      log(`Ошибка старта WebRTC: ${e?.name || e}`);
    }
  };
  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);
    if (msg.type === 'signal') {
      await rtc?.handleSignal(msg);
    } else if (msg.type === 'chat') {
      appendChat(els.chat, msg.authorId || 'system', msg.content || msg.echo || '');
    }
  };
  ws.onclose = () => { log('WS closed'); setConnectedState(false); };
}

function leave(){
  rtc?.close();
  setConnectedState(false);
}

function copyLink(){
  const url = new URL(location.href);
  url.searchParams.set('room', els.roomId.value.trim());
  navigator.clipboard.writeText(url.toString());
  log('Ссылка скопирована');
}

function send(){
  const text = els.chatInput.value.trim();
  if (!text) return;
  sendChat(ws, text, userId);
  // Не добавляем сразу в чат: сервер пришлёт широковещательное сообщение с authorId
  els.chatInput.value='';
}

function toggleMic(){
  const on = rtc?.toggleMic();
  log(`Микрофон: ${on ? 'вкл' : 'выкл'}`);
}

function toggleCam(){
  const on = rtc?.toggleCam();
  log(`Камера: ${on ? 'вкл' : 'выкл'}`);
}

function restoreFromUrl(){
  const url = new URL(location.href);
  const rid = url.searchParams.get('room');
  if (rid) els.roomId.value = rid;
}

function toggleTheme(){
  document.documentElement.classList.toggle('light');
}

// Events
bind(els.btnLogin, 'click', login);
bind(els.btnConnect, 'click', connect);
bind(els.btnLeave, 'click', leave);
bind(els.btnCopyLink, 'click', copyLink);
bind(els.btnSend, 'click', send);
bind(els.btnToggleMic, 'click', toggleMic);
bind(els.btnToggleCam, 'click', toggleCam);
bind(els.btnToggleTheme, 'click', toggleTheme);

// Init
restoreFromUrl();
log('Готово. Введите Room ID и нажмите Подключиться.');
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\signal.js ---
// signal.js - signaling helpers
export function sendSignal(ws, type, payload, fromUserId, targetUserId) {
  const body = { type: 'signal', signalType: type, fromUserId, ...payload };
  if (targetUserId) body.targetUserId = targetUserId;
  ws?.send(JSON.stringify(body));
}

export function sendChat(ws, content, fromUserId) {
  ws?.send(JSON.stringify({ type: 'chat', content, fromUserId }));
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\ui.js ---
// ui.js - UI helpers
export function bind(el, event, fn){ el?.addEventListener(event, fn); }

export function setText(el, text){ if (el) el.textContent = text; }
export function setEnabled(el, enabled){ if (el) el.disabled = !enabled; }

export function appendLog(container, msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  container.appendChild(node);
  container.scrollTop = container.scrollHeight;
}

export function appendChat(container, who, text){
  const line = document.createElement('div');
  line.innerHTML = `<strong>${who}:</strong> ${escapeHtml(text)}`;
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc.js ---
// webrtc.js - RTCPeerConnection handling
import { sendSignal } from './signal.js';
import { getIceServers } from './api.js';

export class WebRTCManager {
  constructor(opts) {
    this.localVideo = opts.localVideo;
    this.remoteVideo = opts.remoteVideo;
  this.outputDeviceId = opts.outputDeviceId || null;
    this.onLog = opts.onLog || (()=>{});
    this.onConnected = opts.onConnected || (()=>{});
    this.onDisconnected = opts.onDisconnected || (()=>{});
  // signaling helpers
  this._remoteSet = false;
  this._candidateQueue = [];
  this._started = false;
  }

  async getMediaStreamWithFallback() {
    // Пытаемся получить и аудио, и видео; при ошибке пробуем по отдельности
    const tryGet = async (constraints) => {
      try {
        return await navigator.mediaDevices.getUserMedia(constraints);
      } catch (e) {
  this.onLog(`getUserMedia error: ${e?.name || e}`);
        return null;
      }
    };

    // 1) audio+video (с разумными констрейнтами для голоса)
    this.onLog('Trying getUserMedia: audio+video');
    let stream = await tryGet({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
      video: true,
    });
    if (stream) return stream;

  // 2) только аудио
  this.onLog('Trying getUserMedia: audio only');
  stream = await tryGet({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, video: false });
    if (stream) return stream;

    // 3) только видео
    this.onLog('Trying getUserMedia: video only');
    stream = await tryGet({ audio: false, video: true });
    if (stream) return stream;

    // 4) ничего — продолжаем без локальных треков
    this.onLog('Нет доступных устройств. Продолжаем без микрофона/камеры.');
    return null;
  }

  async init(ws, userId) {
    this.ws = ws;
    this.userId = userId;
    if (!this.pc) {
      const { iceServers } = await getIceServers().catch(()=>({iceServers:[{urls:['stun:stun.l.google.com:19302']}]}));
      this.pc = new RTCPeerConnection({ iceServers });

      const stream = await this.getMediaStreamWithFallback();
      this.localStream = stream;
      if (stream) {
        this.onLog(`Local tracks: a=${stream.getAudioTracks().length} v=${stream.getVideoTracks().length}`);
        if (this.localVideo) this.localVideo.srcObject = stream;
        for (const track of stream.getTracks()) {
          this.onLog(`Add local track: kind=${track.kind} id=${track.id}`);
          this.pc.addTrack(track, stream);
        }
      }
      // Гарантируем приём аудио даже без локального микрофона
      const hasLocalAudio = this.pc.getSenders().some(s => s.track && s.track.kind === 'audio');
      if (!hasLocalAudio) {
        try { this.pc.addTransceiver('audio', { direction: 'recvonly' }); } catch {}
        this.onLog('No local mic: added audio transceiver recvonly');
      }
      // Гарантируем приём видео даже без локальной камеры
      const hasLocalVideo = this.pc.getSenders().some(s => s.track && s.track.kind === 'video');
      if (!hasLocalVideo) {
        try { this.pc.addTransceiver('video', { direction: 'recvonly' }); } catch {}
        this.onLog('No local camera: added video transceiver recvonly');
      }

      this.pc.onicecandidate = (e) => {
        if (e.candidate) sendSignal(this.ws, 'ice-candidate', { candidate: e.candidate }, this.userId);
      };
      this.pc.onconnectionstatechange = () => {
        this.onLog(`PC state: ${this.pc.connectionState}`);
        if (this.pc.connectionState === 'connected') this.onConnected();
        if (['disconnected','failed','closed'].includes(this.pc.connectionState)) this.onDisconnected();
      };
      this.pc.ontrack = (e) => {
        this.onLog(`ontrack: kind=${e.track?.kind} id=${e.track?.id} streams=${e.streams?.length||0}`);
        const stream = e.streams && e.streams[0] ? e.streams[0] : new MediaStream([e.track]);
        this.remoteVideo.srcObject = stream;
        // На некоторых платформах требуется явный вызов play()
        try {
          this.remoteVideo.muted = false;
          this.remoteVideo.volume = 1.0;
          // Направляем звук на выбранный аудиовыход, если поддерживается
          if (this.outputDeviceId && typeof this.remoteVideo.setSinkId === 'function') {
            this.remoteVideo.setSinkId(this.outputDeviceId).catch(err=>this.onLog(`setSinkId error: ${err?.name||err}`));
          }
          const p = this.remoteVideo.play();
          if (p && typeof p.then === 'function') p.catch(err=>this.onLog(`remote play error: ${err?.name||err}`));
        } catch (e) { this.onLog(`remote playback setup error: ${e?.name||e}`); }
      };
    }
  }

  async start(ws, userId){
    if (this._started) return;
    this._started = true;
    await this.init(ws, userId);
    const offer = await this.pc.createOffer();
    await this.pc.setLocalDescription(offer);
    sendSignal(this.ws, 'offer', { sdp: offer.sdp }, this.userId);
  }

  async handleSignal(msg){
    if (msg.signalType === 'offer') {
      await this.init(this.ws, this.userId);
      const offer = { type: 'offer', sdp: msg.sdp };
      // Если это эхо нашего же оффера (шина вернула обратно), игнорируем
      if (this.pc.localDescription?.type === 'offer' && this.pc.localDescription?.sdp === msg.sdp) {
        this.onLog('Self-offer echo ignored');
        return;
      }
      // Glare handling: if not stable, rollback our local offer before applying remote offer
      if (this.pc.signalingState !== 'stable') {
        try { await this.pc.setLocalDescription({ type: 'rollback' }); }
        catch (e) { this.onLog(`rollback failed: ${e?.name||e}`); }
      }
      // If already have this remote offer applied, ignore
      if (this.pc.currentRemoteDescription && this.pc.currentRemoteDescription.sdp === msg.sdp) {
        this.onLog('Duplicate offer ignored');
        return;
      }
      await this.pc.setRemoteDescription(offer);
      this._remoteSet = true;
      // flush queued ICE
      await this._flushQueuedCandidates();
      const answer = await this.pc.createAnswer();
      await this.pc.setLocalDescription(answer);
      sendSignal(this.ws, 'answer', { sdp: answer.sdp }, this.userId);
  } else if (msg.signalType === 'answer') {
      // Apply answer only when we have local offer pending
      if (!this.pc) return;
      if (this.pc.signalingState !== 'have-local-offer') {
        this.onLog(`Ignore answer in state ${this.pc.signalingState}`);
        return;
      }
      if (this.pc.currentRemoteDescription?.type === 'answer') {
        this.onLog('Duplicate answer ignored');
        return;
      }
      await this.pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
      this._remoteSet = true;
      await this._flushQueuedCandidates();
    } else if (msg.signalType === 'ice-candidate') {
  if (fromSelf) { /* игнорируем собственные ICE */ return; }
      // Buffer ICE until remote description is set
      if (!this._remoteSet) {
        this._candidateQueue.push(msg.candidate);
      } else if (this.pc) {
        try { await this.pc.addIceCandidate(msg.candidate); }
        catch (e) { this.onLog(`addIceCandidate failed: ${e?.name||e}`); }
      }
    }
  }

  async _flushQueuedCandidates(){
    if (!this.pc) return;
    while (this._candidateQueue.length) {
      const c = this._candidateQueue.shift();
      try { await this.pc.addIceCandidate(c); }
      catch (e) { this.onLog(`flush ICE failed: ${e?.name||e}`); }
    }
  }

  toggleMic(){
    if (!this.localStream) return false;
    const audio = this.localStream.getAudioTracks()[0];
    if (!audio) return false;
    audio.enabled = !audio.enabled;
    return audio.enabled;
  }

  toggleCam(){
    if (!this.localStream) return false;
    const video = this.localStream.getVideoTracks()[0];
    if (!video) return false;
    video.enabled = !video.enabled;
    return video.enabled;
  }

  async close(){
    try{ this.ws?.close(); }catch{}
    try{ this.pc?.close(); }catch{}
    this.pc = null; this.ws = null;
    if (this.localStream){ this.localStream.getTracks().forEach(t=>t.stop()); }
  this.localStream = null;
  this._remoteSet = false;
  this._candidateQueue = [];
  this._started = false;
  }
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\rooms.py ---
from __future__ import annotations

import asyncio
import json
from typing import Any
from collections import defaultdict
import contextlib
from uuid import UUID, uuid5, NAMESPACE_URL

from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect
from ...infrastructure.config import get_settings

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus, TokenProvider
from ..api.deps.containers import get_signal_bus, get_token_provider
from ...infrastructure.messaging.redis_bus import RedisSignalBus  # for type-check to enable Redis chat broadcast

router = APIRouter()

# In-process registry of room connections for chat broadcast (dev/test)
_room_clients: dict[UUID, set[WebSocket]] = defaultdict(set)


@router.websocket("/ws/rooms/{room_id}")
async def ws_room(
    websocket: WebSocket,
    room_id: str,
    bus: SignalBus = Depends(get_signal_bus),
    tokens: TokenProvider = Depends(get_token_provider),
):  # type: ignore[override]
    settings = get_settings()
    token = websocket.query_params.get("token")
    allow_unauth = settings.APP_ENV in {"dev", "test"}
    if token:
        try:
            tokens.decode_token(token)
        except Exception:
            if not allow_unauth:
                await websocket.close(code=4401)
                return
    else:
        if not allow_unauth:
            await websocket.close(code=4401)
            return
    await websocket.accept()
    # Поддержка человекочитаемых room_id: если не UUID, маппим в стабильный UUID v5
    try:
        room_uuid = UUID(room_id)
    except Exception:
        room_uuid = uuid5(NAMESPACE_URL, f"webcall:{room_id}")

    async def sender():
        async for signal in bus.subscribe(room_uuid):
            await websocket.send_json(
                {
                    "type": "signal",
                    "fromUserId": str(signal.sender_id),
                    "signalType": signal.type.value,
                    "sdp": signal.sdp,
                    "candidate": signal.candidate,
                }
            )

    send_task = asyncio.create_task(sender())
    # If Redis is used, also subscribe to chat channel to receive messages from other processes
    chat_task: asyncio.Task | None = None
    chat_channel = f"room:{room_uuid}:chat"
    if isinstance(bus, RedisSignalBus):
        async def chat_listener() -> None:
            pubsub = bus.redis.pubsub()
            await pubsub.subscribe(chat_channel)
            try:
                async for msg in pubsub.listen():
                    if msg.get("type") != "message":
                        continue
                    try:
                        data = json.loads(msg["data"])  # type: ignore[arg-type]
                    except Exception:
                        continue
                    await websocket.send_json({"type": "chat", "authorId": data.get("authorId"), "content": data.get("content")})
            finally:
                with contextlib.suppress(Exception):
                    await pubsub.unsubscribe(chat_channel)
                    await pubsub.close()

        chat_task = asyncio.create_task(chat_listener())
    # register connection in room for chat broadcast
    _room_clients[room_uuid].add(websocket)

    try:
        while True:
            msg = await websocket.receive_text()
            data: dict[str, Any] = json.loads(msg)
            if data.get("type") == "signal":
                s = Signal.create(
                    type=data.get("signalType"),
                    sender_id=UUID(data.get("fromUserId")),
                    room_id=room_uuid,
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["targetUserId"]) if data.get("targetUserId") else None,
                )
                await bus.publish(room_uuid, s)
            elif data.get("type") == "join":
                # presence update could be here
                pass
            elif data.get("type") == "leave":
                break
            elif data.get("type") == "chat":
                # Broadcast chat to all participants in room (including sender)
                content = data.get("content")
                author = data.get("fromUserId")
                if isinstance(bus, RedisSignalBus):
                    # Publish to Redis channel so all processes deliver the message
                    await bus.redis.publish(chat_channel, json.dumps({"authorId": author, "content": content}))
                else:
                    # In-process fallback (dev/test)
                    payload = {"type": "chat", "authorId": author, "content": content}
                    # Backward compat for older UIs relying on 'echo'
                    payload_with_echo = {**payload, "echo": content}
                    dead: list[WebSocket] = []
                    for ws in list(_room_clients.get(room_uuid, set())):
                        try:
                            await ws.send_json(payload_with_echo)
                        except Exception:
                            dead.append(ws)
                    # cleanup dead connections
                    for ws in dead:
                        with contextlib.suppress(KeyError):
                            _room_clients[room_uuid].remove(ws)
            else:
                await websocket.send_json({"type": "error", "message": "Unknown message"})
    except WebSocketDisconnect:
        pass
    finally:
        send_task.cancel()
        if chat_task:
            chat_task.cancel()
        # В Python 3.11 CancelledError наследуется от BaseException — подавляем явно
        with contextlib.suppress(asyncio.CancelledError):
            await send_task
        if chat_task:
            with contextlib.suppress(asyncio.CancelledError):
                await chat_task
        # unregister connection
        with contextlib.suppress(KeyError):
            _room_clients[room_uuid].remove(websocket)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\create_superuser.py ---
import asyncio
from uuid import UUID

from app.infrastructure.db.session import AsyncSessionLocal
from app.infrastructure.db.repositories.users import PgUserRepository
from app.infrastructure.security.password_hasher import BcryptPasswordHasher


async def main():
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        users = PgUserRepository(session)
        hasher = BcryptPasswordHasher()
        # minimal example: ensure user exists
        from app.core.domain.models import User

        u = User.create("admin@example.com", "admin", hasher.hash("admin"))
        await users.add(u)
        print("Created:", u.id)


if __name__ == "__main__":
    asyncio.run(main())
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\wait_for_db.py ---
from __future__ import annotations

import asyncio
import os
import sys
from typing import Optional

import asyncpg


def _to_asyncpg_dsn(url: str) -> str:
    # Convert SQLAlchemy async URL (postgresql+asyncpg://...) to asyncpg-compatible DSN
    if url.startswith("postgresql+asyncpg://"):
        return "postgresql://" + url.split("postgresql+asyncpg://", 1)[1]
    return url


async def wait_for_db(dsn: str, timeout: float = 60.0, interval: float = 1.0) -> None:
    deadline = asyncio.get_event_loop().time() + timeout
    last_err: Optional[BaseException] = None
    while True:
        try:
            conn = await asyncpg.connect(dsn)
        except Exception as e:  # pragma: no cover - best effort utility
            last_err = e
            if asyncio.get_event_loop().time() >= deadline:
                break
            await asyncio.sleep(interval)
        else:
            await conn.close()
            return
    # Timed out
    if last_err:
        print(f"wait_for_db: failed to connect within {timeout}s: {last_err}", file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":  # pragma: no cover
    dsn = _to_asyncpg_dsn(os.environ.get("DATABASE_URL", "postgresql://postgres@postgres:5432/postgres"))
    asyncio.run(wait_for_db(dsn))
import asyncio

import asyncpg


async def main():
    dsn = "postgresql://webcall:secret@postgres:5432/webcall"
    for _ in range(30):
        try:
            conn = await asyncpg.connect(dsn)
            await conn.close()
            print("db ready")
            return
        except Exception:
            await asyncio.sleep(1)
    raise SystemExit(1)


if __name__ == "__main__":
    asyncio.run(main())
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\conftest.py ---
import asyncio
import os
import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.fixture(scope="session")
def anyio_backend():
    return 'asyncio'


@pytest.fixture()
async def client():
    # httpx>=0.27: pass ASGITransport instead of deprecated app= argument
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_auth.py ---
import pytest


@pytest.mark.asyncio
async def test_dummy_auth():
    assert True
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_rooms.py ---
import pytest


@pytest.mark.asyncio
async def test_dummy_rooms():
    assert True
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_ws_basic.py ---
import asyncio
import json

import pytest
from starlette.testclient import TestClient

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_ws_basic():
    client = TestClient(app)
    with client.websocket_connect("/ws/rooms/00000000-0000-0000-0000-000000000001") as ws:
        ws.send_json({"type": "chat", "content": "hi"})
        msg = ws.receive_json()
        assert msg["type"] == "chat"
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.Dockerfile ---
# syntax=docker/dockerfile:1
FROM python:3.11-slim AS base

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=on \
    PYTHONPATH=/app

WORKDIR /app

# System deps
RUN apt-get update && apt-get install -y --no-install-recommends build-essential libpq-dev curl && rm -rf /var/lib/apt/lists/*

# Install Poetry
ENV POETRY_HOME=/opt/poetry \
    POETRY_VERSION=1.8.3
ENV PATH="$POETRY_HOME/bin:$PATH"
RUN curl -sSL https://install.python-poetry.org | python3 - && poetry --version

# Copy project files
COPY pyproject.toml README.md ./
RUN poetry config virtualenvs.create false \
    && poetry install --no-interaction --no-ansi --with dev

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.bootstrap.asgi:app", "--host", "0.0.0.0", "--port", "8000"]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_health.py ---
import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_healthz():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
        r = await client.get("/healthz")
        assert r.status_code == 200
        assert r.json() == {"status": "ok"}

=== Dump finished: 05.09.2025 14:39:16,68
