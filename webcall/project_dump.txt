=== Dump started: 05.09.2025 20:08:58,84
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   README.md
|   |   
|   \---v
|       \---cache
|               lastfailed
|               nodeids
|               
+---alembic
|   |   env.py
|   |   
|   \---versions
|           0001_init.py
|           
+---app
|   |   __init__.py
|   |   
|   +---application
|   |   |   __init__.py
|   |   |   
|   |   +---dto
|   |   |       auth.py
|   |   |       messages.py
|   |   |       rooms.py
|   |   |       __init__.py
|   |   |       
|   |   \---use_cases
|   |           auth.py
|   |           messages.py
|   |           participants.py
|   |           rooms.py
|   |           signals.py
|   |           __init__.py
|   |           
|   +---bootstrap
|   |       asgi.py
|   |       main.py
|   |       __init__.py
|   |       
|   +---core
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---domain
|   |   |       models.py
|   |   |       values.py
|   |   |       __init__.py
|   |   |       
|   |   +---ports
|   |   |       repositories.py
|   |   |       services.py
|   |   |       __init__.py
|   |   |       
|   |   \---services
|   |           room_service.py
|   |           __init__.py
|   |           
|   +---infrastructure
|   |   |   config.py
|   |   |   logging.py
|   |   |   __init__.py
|   |   |   
|   |   +---db
|   |   |   |   base.py
|   |   |   |   models.py
|   |   |   |   session.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---repositories
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           users.py
|   |   |           __init__.py
|   |   |           
|   |   +---ice
|   |   |       provider.py
|   |   |       __init__.py
|   |   |       
|   |   +---messaging
|   |   |       inmemory_bus.py
|   |   |       redis_bus.py
|   |   |       __init__.py
|   |   |       
|   |   \---security
|   |           jwt_provider.py
|   |           password_hasher.py
|   |           __init__.py
|   |           
|   +---presentation
|   |   |   docs.py
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---api
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---deps
|   |   |   |       auth.py
|   |   |   |       containers.py
|   |   |   |       db.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---routers
|   |   |           auth.py
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           webrtc.py
|   |   |           __init__.py
|   |   |           
|   |   +---schemas
|   |   |       api.py
|   |   |       
|   |   +---static
|   |   |   |   auth.html
|   |   |   |   index.html
|   |   |   |   styles.css
|   |   |   |   
|   |   |   \---js
|   |   |           api.js
|   |   |           auth.js
|   |   |           main.js
|   |   |           signal.js
|   |   |           ui.js
|   |   |           webrtc.js
|   |   |           
|   |   \---ws
|   |           rooms.py
|   |           
|   +---scripts
|   |       create_superuser.py
|   |       wait_for_db.py
|   |       
|   \---tests
|           conftest.py
|           test_auth.py
|           test_rooms.py
|           test_ws_basic.py
|           
+---docker
|       api.Dockerfile
|       
\---tests
        test_health.py
        

=== FILE CONTENTS =======================================

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env.example ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore ---
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.venv/
.poetry/
.mypy_cache/
.pytest_cache/
.coverage
htmlcov/
.cache/

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini ---
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml ---
services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000"         # для локальной проверки, Nginx ходит на 127.0.0.1:8000
    depends_on:
      - postgres
      - redis
      - coturn
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000"]
    volumes:
      - ./:/app

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: Mousa     # ← совпадает с .env
      POSTGRES_DB: webcall
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    command:
      - -n
      - --log-file=stdout
      - --min-port=49152
      - --max-port=49200
      - --realm=turn.bandjshoos.ru
      - --listening-ip=0.0.0.0
      - --relay-ip=0.0.0.0
      - --listening-port=3478
      - --external-ip=104.238.24.120          # ← публичный IP твоего VPS
      - --lt-cred-mech
      - --user=webcall:Mousa   # ← совпадает с .env
      - --fingerprint
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49200:49152-49200/udp"

volumes:
  pgdata:
  redisdata:

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\dump.bat ---
@echo off
chcp 65001 >nul
setlocal EnableDelayedExpansion

:: Игнорируемые папки
set "SKIP_DIRS=\venv\;.git\;__pycache__\;.mypy_cache\;.idea\;.vscode\;node_modules\;.pytest_cache\"

:: Игнорируемые файлы
set "SKIP_FILES=CACHEDIR.TAG"

set "OUT=project_dump.txt"

(
  echo === Dump started: %date% %time%
  echo Root: %cd%
  echo.
  echo === DIRECTORY TREE =======================================
  tree /F /A
  echo.
  echo === FILE CONTENTS =======================================
) > "%OUT%"

:: Обход файлов
for /R %%F in (*) do (
    set "FILE=%%~fF"
    call :ShouldSkip "%%F"
    if errorlevel 1 (
        REM skip
    ) else (
        >>"%OUT%" echo.
        >>"%OUT%" echo --- %%F ---
        >>"%OUT%" type "%%F"
    )
)

>>"%OUT%" echo.
>>"%OUT%" echo === Dump finished: %date% %time%

echo Структура и содержимое файлов сохранены в %OUT%
exit /b


:ShouldSkip
setlocal
set "FN=%~1"

:: Проверяем папки
for %%D in (%SKIP_DIRS%) do (
    echo "%FN%" | findstr /I "%%D" >nul && (exit /b 1)
)

:: Проверяем файлы
for %%X in (%SKIP_FILES%) do (
    if /I "%~nx1"=="%%X" exit /b 1
)

exit /b 0

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile ---
.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\project_dump.txt ---
=== Dump started: 05.09.2025 20:08:58,84
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   README.md
|   |   
|   \---v
|       \---cache
|               lastfailed
|               nodeids
|               
+---alembic
|   |   env.py
|   |   
|   \---versions
|           0001_init.py
|           
+---app
|   |   __init__.py
|   |   
|   +---application
|   |   |   __init__.py
|   |   |   
|   |   +---dto
|   |   |       auth.py
|   |   |       messages.py
|   |   |       rooms.py
|   |   |       __init__.py
|   |   |       
|   |   \---use_cases
|   |           auth.py
|   |           messages.py
|   |           participants.py
|   |           rooms.py
|   |           signals.py
|   |           __init__.py
|   |           
|   +---bootstrap
|   |       asgi.py
|   |       main.py
|   |       __init__.py
|   |       
|   +---core
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---domain
|   |   |       models.py
|   |   |       values.py
|   |   |       __init__.py
|   |   |       
|   |   +---ports
|   |   |       repositories.py
|   |   |       services.py
|   |   |       __init__.py
|   |   |       
|   |   \---services
|   |           room_service.py
|   |           __init__.py
|   |           
|   +---infrastructure
|   |   |   config.py
|   |   |   logging.py
|   |   |   __init__.py
|   |   |   
|   |   +---db
|   |   |   |   base.py
|   |   |   |   models.py
|   |   |   |   session.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---repositories
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           users.py
|   |   |           __init__.py
|   |   |           
|   |   +---ice
|   |   |       provider.py
|   |   |       __init__.py
|   |   |       
|   |   +---messaging
|   |   |       inmemory_bus.py
|   |   |       redis_bus.py
|   |   |       __init__.py
|   |   |       
|   |   \---security
|   |           jwt_provider.py
|   |           password_hasher.py
|   |           __init__.py
|   |           
|   +---presentation
|   |   |   docs.py
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---api
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---deps
|   |   |   |       auth.py
|   |   |   |       containers.py
|   |   |   |       db.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---routers
|   |   |           auth.py
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           webrtc.py
|   |   |           __init__.py
|   |   |           
|   |   +---schemas
|   |   |       api.py
|   |   |       
|   |   +---static
|   |   |   |   auth.html
|   |   |   |   index.html
|   |   |   |   styles.css
|   |   |   |   
|   |   |   \---js
|   |   |           api.js
|   |   |           auth.js
|   |   |           main.js
|   |   |           signal.js
|   |   |           ui.js
|   |   |           webrtc.js
|   |   |           
|   |   \---ws
|   |           rooms.py
|   |           
|   +---scripts
|   |       create_superuser.py
|   |       wait_for_db.py
|   |       
|   \---tests
|           conftest.py
|           test_auth.py
|           test_rooms.py
|           test_ws_basic.py
|           
+---docker
|       api.Dockerfile
|       
\---tests
        test_health.py
        

=== FILE CONTENTS =======================================

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env.example ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore ---
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.venv/
.poetry/
.mypy_cache/
.pytest_cache/
.coverage
htmlcov/
.cache/

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini ---
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml ---
services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000"         # для локальной проверки, Nginx ходит на 127.0.0.1:8000
    depends_on:
      - postgres
      - redis
      - coturn
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000"]
    volumes:
      - ./:/app

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: Mousa     # ← совпадает с .env
      POSTGRES_DB: webcall
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    command:
      - -n
      - --log-file=stdout
      - --min-port=49152
      - --max-port=49200
      - --realm=turn.bandjshoos.ru
      - --listening-ip=0.0.0.0
      - --relay-ip=0.0.0.0
      - --listening-port=3478
      - --external-ip=104.238.24.120          # ← публичный IP твоего VPS
      - --lt-cred-mech
      - --user=webcall:Mousa   # ← совпадает с .env
      - --fingerprint
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49200:49152-49200/udp"

volumes:
  pgdata:
  redisdata:

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\dump.bat ---
@echo off
chcp 65001 >nul
setlocal EnableDelayedExpansion

:: Игнорируемые папки
set "SKIP_DIRS=\venv\;.git\;__pycache__\;.mypy_cache\;.idea\;.vscode\;node_modules\;.pytest_cache\"

:: Игнорируемые файлы
set "SKIP_FILES=CACHEDIR.TAG"

set "OUT=project_dump.txt"

(
  echo === Dump started: %date% %time%
  echo Root: %cd%
  echo.
  echo === DIRECTORY TREE =======================================
  tree /F /A
  echo.
  echo === FILE CONTENTS =======================================
) > "%OUT%"

:: Обход файлов
for /R %%F in (*) do (
    set "FILE=%%~fF"
    call :ShouldSkip "%%F"
    if errorlevel 1 (
        REM skip
    ) else (
        >>"%OUT%" echo.
        >>"%OUT%" echo --- %%F ---
        >>"%OUT%" type "%%F"
    )
)

>>"%OUT%" echo.
>>"%OUT%" echo === Dump finished: %date% %time%

echo Структура и содержимое файлов сохранены в %OUT%
exit /b


:ShouldSkip
setlocal
set "FN=%~1"

:: Проверяем папки
for %%D in (%SKIP_DIRS%) do (
    echo "%FN%" | findstr /I "%%D" >nul && (exit /b 1)
)

:: Проверяем файлы
for %%X in (%SKIP_FILES%) do (
    if /I "%~nx1"=="%%X" exit /b 1
)

exit /b 0

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile ---
.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\project_dump.txt ---
=== Dump started: 05.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\pyproject.toml ---
[tool.poetry]
name = "webcall"
version = "0.1.0"
description = "WebRTC call backend with FastAPI (onion architecture)"
authors = ["You <you@example.com>"]
readme = "README.md"
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.111.0"
uvicorn = {extras=["standard"], version="^0.30.0"}
pydantic = "^2.8.2"
pydantic-settings = "^2.4.0"
SQLAlchemy = "^2.0.30"
asyncpg = "^0.29.0"
alembic = "^1.13.2"
redis = "^5.0.6"
passlib = {version = "^1.7.4", extras=["bcrypt"]}
python-jose = {version = "^3.3.0", extras=["cryptography"]}
httpx = "^0.27.0"
structlog = "^24.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^8.2.2"
pytest-asyncio = "^0.23.8"
httpx = {version="^0.27.0", extras=["http2"]}
ruff = "^0.6.3"
black = "^24.8.0"
isort = "^5.13.2"
pre-commit = "^3.8.0"
mypy = "^1.11.1"

[tool.ruff]
line-length = 100
extend-select = ["I"]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 100

[tool.pytest.ini_options]
asyncio_mode = "auto"
filterwarnings = [
  "ignore::DeprecationWarning",
]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\README.md ---
# WebCall

Бэкенд для веб-созвонов на FastAPI с WebSocket-сигналингом (onion/clean architecture).

Слои: presentation → application → core. Инфраструктура внедряется через порты.

## Быстрый старт (Docker)

1. Создайте `.env` из примера:

```
cp .env.example .env
```

2. Поднимите стэк:

```
docker compose up --build
```

3. Примените миграции (в другом терминале):

```
docker compose exec api alembic upgrade head
```

4. Откройте Swagger: http://localhost:8000/docs

5. Демо-клиент: http://localhost:8000/static/index.html

## Локальный запуск

Требуется Python 3.11+ и Poetry.

```
poetry install
poetry run uvicorn app.bootstrap.asgi:app --reload
```

Миграции:

```
poetry run alembic upgrade head
```

## Структура

См. дерево в задаче. Важные части:
- app/bootstrap: создание приложения
- core: доменные сущности/порты/сервисы
- application: use-cases
- infrastructure: реализация портов (DB, Redis, JWT, bcrypt, ICE)
- presentation: REST и WS, схемы, ошибки, статика

## Definition of Done
- docker compose up поднимает Postgres, Redis, API
- alembic upgrade head проходит
- /docs доступен
- Регистрация/логин работают
- Создание комнат работает
- WS сигналинг показывает обмен сообщениями

## Примечания
- Rate limit для REST помечен как TODO
- Метрики/Prometheus — TODO хуки
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\.gitignore ---
# Created by pytest automatically.
*
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\README.md ---
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\v\cache\lastfailed ---
{}.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\v\cache\nodeids ---
[
  "app/tests/test_auth.py::test_dummy_auth",
  "app/tests/test_rooms.py::test_dummy_rooms",
  "app/tests/test_ws_basic.py::test_ws_basic",
  "tests/test_health.py::test_healthz"
].
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\env.py ---
from __future__ import annotations

import asyncio
from logging.config import fileConfig
import os
import sys

# Ensure project root is on PYTHONPATH so `import app` works when running alembic
CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

from app.infrastructure.config import get_settings
from app.infrastructure.db.base import Base
from app.infrastructure.db import models  # noqa: F401

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


def get_url() -> str:
    return get_settings().DATABASE_URL


def run_migrations_offline() -> None:
    url = get_url()
    context.configure(
        url=url,
        target_metadata=Base.metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=Base.metadata, compare_type=True)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    connectable = create_async_engine(get_url(), poolclass=pool.NullPool)

    async def run_migrations() -> None:
        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

    asyncio.run(run_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0001_init.py ---
from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = "0001_init"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "users",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("email", sa.String(254), nullable=False, unique=True, index=True),
        sa.Column("username", sa.String(50), nullable=False, unique=True, index=True),
        sa.Column("password_hash", sa.String(255), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "rooms",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("name", sa.String(100), nullable=False),
        sa.Column("owner_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("is_private", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "participants",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("user_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("role", sa.String(20), nullable=False),
        sa.Column("muted", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("joined_at", sa.DateTime(timezone=False), nullable=False),
        sa.Column("left_at", sa.DateTime(timezone=False), nullable=True),
    )

    op.create_table(
        "messages",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("author_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("content", sa.Text(), nullable=False),
        sa.Column("sent_at", sa.DateTime(timezone=False), nullable=False, index=True),
    )


def downgrade() -> None:
    op.drop_table("messages")
    op.drop_table("participants")
    op.drop_table("rooms")
    op.drop_table("users")
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\auth.py ---
from __future__ import annotations

from pydantic import BaseModel, EmailStr, Field


class RegisterInput(BaseModel):
    email: EmailStr
    username: str = Field(min_length=3, max_length=50)
    password: str = Field(min_length=6, max_length=128)


class RegisterOutput(BaseModel):
    id: str
    email: EmailStr
    username: str


class LoginInput(BaseModel):
    email: EmailStr
    password: str


class TokenOutput(BaseModel):
    access_token: str
    token_type: str = "bearer"
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\messages.py ---
from __future__ import annotations

from datetime import datetime
from pydantic import BaseModel, Field


class PostMessageInput(BaseModel):
    room_id: str
    author_id: str
    content: str = Field(min_length=1, max_length=2000)


class MessageDTO(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\rooms.py ---
from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class CreateRoomInput(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomDTO(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class ListRoomsInput(BaseModel):
    owner_id: Optional[str] = None
    skip: int = 0
    limit: int = 50
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\auth.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import User
from ...core.errors import AuthError, ConflictError, NotFoundError
from ...core.ports.repositories import UserRepository
from ...core.ports.services import PasswordHasher, TokenProvider


class RegisterUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher) -> None:
        self.users = users
        self.hasher = hasher

    async def execute(self, email: str, username: str, password: str) -> User:
        if await self.users.get_by_email(email):
            raise ConflictError("Email already registered")
        if await self.users.get_by_username(username):
            raise ConflictError("Username already taken")
        pwd_hash = self.hasher.hash(password)
        user = User.create(email=email, username=username, password_hash=pwd_hash)
        await self.users.add(user)
        return user


class LoginUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher, tokens: TokenProvider) -> None:
        self.users = users
        self.hasher = hasher
        self.tokens = tokens

    async def execute(self, email: str, password: str) -> str:
        user = await self.users.get_by_email(email)
        if not user or not self.hasher.verify(password, str(user.password_hash)):
            raise AuthError("Invalid credentials")
        return self.tokens.create_access_token(str(user.id), None)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\messages.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Message
from ...core.ports.repositories import MessageRepository


class PostMessage:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, author_id: UUID, content: str) -> Message:
        msg = Message.post(room_id=room_id, author_id=author_id, content=content)
        await self.messages.add(msg)
        return msg


class ListMessages:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        return await self.messages.list(room_id=room_id, skip=skip, limit=limit)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\participants.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Participant, Role
from ...core.errors import NotFoundError
from ...core.ports.repositories import ParticipantRepository, RoomRepository
from ...core.services.room_service import RoomService


class JoinRoom:
    def __init__(self, participants: ParticipantRepository, rooms: RoomRepository, policy: RoomService) -> None:
        self.participants = participants
        self.rooms = rooms
        self.policy = policy

    async def execute(self, room_id: UUID, user_id: UUID, role: Role = Role.member) -> Participant:
        room = await self.rooms.get(room_id)
        if not room:
            raise NotFoundError("Room not found")
        active = await self.participants.list_active(room_id)
        self.policy.can_join(room, active)
        participant = Participant.join(user_id=user_id, room_id=room_id, role=role)
        await self.participants.add(participant)
        return participant


class LeaveRoom:
    def __init__(self, participants: ParticipantRepository) -> None:
        self.participants = participants

    async def execute(self, room_id: UUID, user_id: UUID) -> None:
        p = await self.participants.get(room_id, user_id)
        if p:
            p.left_at = p.left_at or p.joined_at
            await self.participants.update(p)


class KickParticipant:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_kick(actor.role, target.role)
        await self.participants.remove(room_id, target_id)


class ToggleMute:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_toggle_mute(actor.role, target.role)
        target.muted = not target.muted
        await self.participants.update(target)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\rooms.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from ...core.domain.models import Room
from ...core.ports.repositories import RoomRepository


class CreateRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, name: str, owner_id: UUID, is_private: bool = False) -> Room:
        room = Room.create(name=name, owner_id=owner_id, is_private=is_private)
        await self.rooms.add(room)
        return room


class ListRooms:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, owner_id: Optional[UUID] = None, skip: int = 0, limit: int = 50) -> list[Room]:
        return await self.rooms.list(owner_id=owner_id, skip=skip, limit=limit)


class GetRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> Optional[Room]:
        return await self.rooms.get(room_id)


class DeleteRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> None:
        await self.rooms.delete(room_id)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\signals.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class PublishSignal:
    def __init__(self, bus: SignalBus) -> None:
        self.bus = bus

    async def execute(
        self, *, room_id: UUID, sender_id: UUID, type: str, sdp: str | None = None, candidate: dict | None = None, target_id: UUID | None = None
    ) -> None:
        signal = Signal.create(type=type, sender_id=sender_id, room_id=room_id, sdp=sdp, candidate=candidate, target_id=target_id)
        await self.bus.publish(room_id, signal)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\asgi.py ---
from __future__ import annotations

from .main import create_app

app = create_app()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\main.py ---
from __future__ import annotations

import logging
from contextlib import asynccontextmanager

from fastapi import Depends, FastAPI
from fastapi.responses import RedirectResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

from ..infrastructure.config import get_settings
from ..infrastructure.logging import configure_logging
from ..presentation.docs import get_openapi_tags
from ..presentation.api.routers import auth as auth_router
from ..presentation.api.routers import rooms as rooms_router
from ..presentation.api.routers import participants as participants_router
from ..presentation.api.routers import messages as messages_router
from ..presentation.api.routers import webrtc as webrtc_router
from ..presentation.api.deps.containers import (
    get_user_repo,
    get_room_repo,
    get_participant_repo,
    get_message_repo,
    get_password_hasher,
    get_token_provider,
    get_signal_bus,
    get_ice_provider,
)
from ..presentation.ws import rooms as ws_rooms
from ..presentation.api.deps.db import get_db_session
from ..infrastructure.db.repositories.users import PgUserRepository
from ..infrastructure.db.repositories.rooms import PgRoomRepository
from ..infrastructure.db.repositories.participants import PgParticipantRepository
from ..infrastructure.db.repositories.messages import PgMessageRepository
from ..infrastructure.security.jwt_provider import JoseTokenProvider
from ..infrastructure.security.password_hasher import BcryptPasswordHasher
from ..infrastructure.messaging.redis_bus import RedisSignalBus
from ..infrastructure.ice.provider import EnvIceConfigProvider
from ..presentation.errors import setup_error_handlers


@asynccontextmanager
async def lifespan(app: FastAPI):
    # here we could init DB/Redis connections if needed globally
    yield


def create_app() -> FastAPI:
    settings = get_settings()
    configure_logging(logging.INFO)

    app = FastAPI(
        title=settings.APP_NAME,
        description="WebRTC signaling server with REST and WebSocket",
        version="0.1.0",
        docs_url="/docs",
        redoc_url="/redoc",
        openapi_tags=get_openapi_tags(),
        lifespan=lifespan,
    )

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    setup_error_handlers(app)

    # Routers
    app.include_router(auth_router.router)
    app.include_router(rooms_router.router)
    app.include_router(participants_router.router)
    app.include_router(messages_router.router)
    app.include_router(webrtc_router.router)

    # WS
    app.include_router(ws_rooms.router)

    # Static demo
    app.mount("/static", StaticFiles(directory="app/presentation/static"), name="static")

    # Friendly entrypoints instead of /static/index.html
    @app.get("/", include_in_schema=False)
    async def root_redirect():
        return RedirectResponse(url="/call", status_code=307)

    @app.get("/call", include_in_schema=False)
    async def call_page():
        return FileResponse("app/presentation/static/index.html")

    @app.get("/call/{room_id}", include_in_schema=False)
    async def call_page_room(room_id: str):  # room_id is used client-side from location
        return FileResponse("app/presentation/static/index.html")

    @app.get("/auth", include_in_schema=False)
    async def auth_page():
        return FileResponse("app/presentation/static/auth.html")

    @app.get("/healthz", tags=["health"])
    async def healthz():
        return {"status": "ok"}

    return app
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\errors.py ---
from dataclasses import dataclass


class DomainError(Exception):
    """Базовая доменная ошибка."""


class ValidationError(DomainError):
    pass


class AuthError(DomainError):
    pass


class NotFoundError(DomainError):
    pass


class PermissionDenied(DomainError):
    pass


class ConflictError(DomainError):
    pass


@dataclass(slots=True)
class ErrorResponse:
    detail: str
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\models.py ---
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from .values import Email, PasswordHash, RoomName


class Role(str, Enum):
    owner = "owner"
    moderator = "moderator"
    member = "member"


@dataclass(slots=True)
class User:
    id: UUID
    email: Email
    username: str
    password_hash: PasswordHash
    created_at: datetime

    @staticmethod
    def create(email: str, username: str, password_hash: str) -> "User":
        return User(
            id=uuid4(),
            email=Email(email),
            username=username,
            password_hash=PasswordHash(password_hash),
            created_at=datetime.utcnow(),
        )


@dataclass(slots=True)
class Room:
    id: UUID
    name: RoomName
    owner_id: UUID
    is_private: bool
    created_at: datetime

    @staticmethod
    def create(name: str, owner_id: UUID, is_private: bool = False) -> "Room":
        return Room(id=uuid4(), name=RoomName(name), owner_id=owner_id, is_private=is_private, created_at=datetime.utcnow())


@dataclass(slots=True)
class Participant:
    id: UUID
    user_id: UUID
    room_id: UUID
    role: Role
    muted: bool
    joined_at: datetime
    left_at: Optional[datetime] = None

    @staticmethod
    def join(user_id: UUID, room_id: UUID, role: Role) -> "Participant":
        return Participant(id=uuid4(), user_id=user_id, room_id=room_id, role=role, muted=False, joined_at=datetime.utcnow())


@dataclass(slots=True)
class Message:
    id: UUID
    room_id: UUID
    author_id: UUID
    content: str
    sent_at: datetime

    @staticmethod
    def post(room_id: UUID, author_id: UUID, content: str) -> "Message":
        return Message(id=uuid4(), room_id=room_id, author_id=author_id, content=content[:2000], sent_at=datetime.utcnow())


class SignalType(str, Enum):
    offer = "offer"
    answer = "answer"
    ice_candidate = "ice-candidate"


@dataclass(slots=True)
class Signal:
    type: SignalType
    sender_id: UUID
    room_id: UUID
    sent_at: datetime
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    target_id: Optional[UUID] = None

    @staticmethod
    def create(type: str, sender_id: UUID, room_id: UUID, sdp: Optional[str] = None, candidate: Optional[dict] = None, target_id: Optional[UUID] = None) -> "Signal":
        st = SignalType(type)
        return Signal(type=st, sender_id=sender_id, room_id=room_id, sent_at=datetime.utcnow(), sdp=sdp, candidate=candidate, target_id=target_id)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\values.py ---
from __future__ import annotations

import re
from dataclasses import dataclass

from ..errors import ValidationError


EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")


@dataclass(frozen=True, slots=True)
class Email:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip().lower()
        if not EMAIL_RE.match(v):
            raise ValidationError("Invalid email format")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:  # for convenience
        return self.value


@dataclass(frozen=True, slots=True)
class RoomName:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip()
        if not (1 <= len(v) <= 100):
            raise ValidationError("Room name must be 1..100 chars")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:
        return self.value


@dataclass(frozen=True, slots=True)
class PasswordHash:
    value: str

    def __post_init__(self) -> None:
        if not self.value or len(self.value) < 10:
            # bcrypt hashes are long; minimal sanity check
            raise ValidationError("Password hash looks invalid")

    def __str__(self) -> str:
        return self.value
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\repositories.py ---
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Optional
from uuid import UUID

from ..domain.models import Message, Participant, Room, User


class UserRepository(ABC):
    @abstractmethod
    async def get_by_email(self, email: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_username(self, username: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_id(self, user_id: UUID) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, user: User) -> None:
        raise NotImplementedError


class RoomRepository(ABC):
    @abstractmethod
    async def add(self, room: Room) -> None:
        raise NotImplementedError

    @abstractmethod
    async def get(self, room_id: UUID) -> Optional[Room]:
        raise NotImplementedError

    @abstractmethod
    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:
        raise NotImplementedError

    @abstractmethod
    async def delete(self, room_id: UUID) -> None:
        raise NotImplementedError


class ParticipantRepository(ABC):
    @abstractmethod
    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def list_active(self, room_id: UUID) -> list[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def update(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def remove(self, room_id: UUID, user_id: UUID) -> None:
        raise NotImplementedError


class MessageRepository(ABC):
    @abstractmethod
    async def add(self, message: Message) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        raise NotImplementedError
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\services.py ---
from __future__ import annotations

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any
from uuid import UUID

from ..domain.models import Signal


class SignalBus(ABC):
    @abstractmethod
    async def publish(self, room_id: UUID, signal: Signal) -> None:
        raise NotImplementedError

    @abstractmethod
    async def subscribe(self, room_id: UUID):
        """Возвращает асинхронный итератор по сообщениям Signal."""
        raise NotImplementedError

    @abstractmethod
    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        raise NotImplementedError


class PasswordHasher(ABC):
    @abstractmethod
    def hash(self, password: str) -> str:
        raise NotImplementedError

    @abstractmethod
    def verify(self, password: str, password_hash: str) -> bool:
        raise NotImplementedError


class TokenProvider(ABC):
    @abstractmethod
    def create_access_token(self, subject: str, expires_minutes: int) -> str:
        raise NotImplementedError

    @abstractmethod
    def decode_token(self, token: str) -> dict:
        raise NotImplementedError


class Clock(ABC):
    @abstractmethod
    def now(self) -> datetime:
        raise NotImplementedError


class IceConfigProvider(ABC):
    @abstractmethod
    async def get_servers(self) -> list[dict]:
        raise NotImplementedError
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\room_service.py ---
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Iterable
from uuid import UUID

from ..domain.models import Participant, Role, Room
from ..errors import PermissionDenied, ValidationError


@dataclass(slots=True)
class RoomPolicy:
    max_participants: int = 16


class RoomService:
    def __init__(self, policy: RoomPolicy | None = None) -> None:
        self.policy = policy or RoomPolicy()

    def can_join(self, room: Room, participants: Iterable[Participant]) -> None:
        count = sum(1 for p in participants if p.left_at is None)
        if count >= self.policy.max_participants:
            raise ValidationError("Room is full")

    def ensure_can_kick(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can kick")
        if actor_role == Role.moderator and target_role in {Role.owner, Role.moderator}:
            raise PermissionDenied("Moderator cannot kick owner/moderator")

    def ensure_can_toggle_mute(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can mute")

    def leave(self, participant: Participant) -> Participant:
        if participant.left_at is None:
            participant.left_at = datetime.utcnow()
        return participant
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\config.py ---
from __future__ import annotations

from functools import lru_cache
from typing import List

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)

    # App
    APP_NAME: str = "WebCall"
    APP_ENV: str = "dev"
    API_PREFIX: str = "/api/v1"
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Security
    JWT_SECRET: str = "change_me"
    JWT_EXPIRES_MIN: int = 60

    # Databases
    DATABASE_URL: str
    REDIS_URL: str

    # CORS
    CORS_ORIGINS: List[str] = Field(default_factory=lambda: ["http://localhost:5173", "http://localhost:8000"])  # type: ignore[assignment]

    # WebRTC ICE
    STUN_SERVERS: List[str] = Field(default_factory=lambda: ["stun:stun.l.google.com:19302"])  # type: ignore[assignment]
    # Поддерживаем как одиночный TURN_URL, так и список TURN_URLS для UDP/TCP
    TURN_URLS: List[str] | None = None  # type: ignore[assignment]
    TURN_URL: str | None = None
    TURN_USERNAME: str | None = None
    TURN_PASSWORD: str | None = None


@lru_cache()
def get_settings() -> Settings:
    s = Settings()
    # allow comma-separated env for lists
    if isinstance(s.CORS_ORIGINS, str):  # type: ignore[unreachable]
        s.CORS_ORIGINS = [x.strip() for x in s.CORS_ORIGINS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if isinstance(s.STUN_SERVERS, str):  # type: ignore[unreachable]
        s.STUN_SERVERS = [x.strip() for x in s.STUN_SERVERS.split(",") if x.strip()]  # type: ignore[attr-defined]
    # Нормализуем TURN_URLS / TURN_URL
    if isinstance(s.TURN_URLS, str):  # type: ignore[unreachable]
        s.TURN_URLS = [x.strip() for x in s.TURN_URLS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if not s.TURN_URLS and s.TURN_URL:
        s.TURN_URLS = [s.TURN_URL]
    return s
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\logging.py ---
import json
import logging
from typing import Any


class JsonFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:  # type: ignore[override]
        data: dict[str, Any] = {
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        if record.exc_info:
            data["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(data, ensure_ascii=False)


def configure_logging(level: int = logging.INFO) -> None:
    handler = logging.StreamHandler()
    handler.setFormatter(JsonFormatter())
    root = logging.getLogger()
    root.handlers.clear()
    root.addHandler(handler)
    root.setLevel(level)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\base.py ---
from __future__ import annotations

from sqlalchemy.orm import DeclarativeBase, declared_attr


class Base(DeclarativeBase):
    __abstract__ = True

    @declared_attr.directive
    def __tablename__(cls) -> str:  # type: ignore[override]
        return cls.__name__.lower()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\models.py ---
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from sqlalchemy import Boolean, DateTime, ForeignKey, String, Text
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import Base


class Users(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    email: Mapped[str] = mapped_column(String(254), unique=True, index=True, nullable=False)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    rooms = relationship("Rooms", back_populates="owner")


class Rooms(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    owner_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    is_private: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    owner = relationship("Users", back_populates="rooms")


class Participants(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    user_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    role: Mapped[str] = mapped_column(String(20), nullable=False)
    muted: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    joined_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    left_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False), nullable=True)


class Messages(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    author_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    sent_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False, index=True)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\session.py ---
from __future__ import annotations

from contextlib import asynccontextmanager
from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from ..config import get_settings


_settings = get_settings()
ENGINE: AsyncEngine = create_async_engine(_settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = sessionmaker(bind=ENGINE, class_=AsyncSession, expire_on_commit=False)


@asynccontextmanager
async def get_session() -> AsyncIterator[AsyncSession]:
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        yield session
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\messages.py ---
from __future__ import annotations

from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Message
from ....core.ports.repositories import MessageRepository
from ..models import Messages


class PgMessageRepository(MessageRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, message: Message) -> None:  # type: ignore[override]
        self.session.add(
            Messages(
                id=message.id,
                room_id=message.room_id,
                author_id=message.author_id,
                content=message.content,
                sent_at=message.sent_at,
            )
        )
        await self.session.commit()

    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:  # type: ignore[override]
        stmt = select(Messages).where(Messages.room_id == room_id).order_by(Messages.sent_at.asc()).offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Message(id=r.id, room_id=r.room_id, author_id=r.author_id, content=r.content, sent_at=r.sent_at) for r in rows]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\participants.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Participant, Role
from ....core.ports.repositories import ParticipantRepository
from ..models import Participants


class PgParticipantRepository(ParticipantRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return Participant(
                id=row.id,
                user_id=row.user_id,
                room_id=row.room_id,
                role=Role(row.role),
                muted=row.muted,
                joined_at=row.joined_at,
                left_at=row.left_at,
            )
        return None

    async def list_active(self, room_id: UUID) -> list[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.left_at.is_(None))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [
            Participant(id=r.id, user_id=r.user_id, room_id=r.room_id, role=Role(r.role), muted=r.muted, joined_at=r.joined_at, left_at=r.left_at)
            for r in rows
        ]

    async def add(self, participant: Participant) -> None:  # type: ignore[override]
        self.session.add(
            Participants(
                id=participant.id,
                user_id=participant.user_id,
                room_id=participant.room_id,
                role=participant.role.value,
                muted=participant.muted,
                joined_at=participant.joined_at,
                left_at=participant.left_at,
            )
        )
        await self.session.commit()

    async def update(self, participant: Participant) -> None:  # type: ignore[override]
        await self.session.execute(
            update(Participants)
            .where(Participants.id == participant.id)
            .values(muted=participant.muted, left_at=participant.left_at)
        )
        await self.session.commit()

    async def remove(self, room_id: UUID, user_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(
            delete(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        )
        await self.session.commit()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\rooms.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Room
from ....core.domain.values import RoomName
from ....core.ports.repositories import RoomRepository
from ..models import Rooms


class PgRoomRepository(RoomRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, room: Room) -> None:  # type: ignore[override]
        self.session.add(
            Rooms(id=room.id, name=str(room.name), owner_id=room.owner_id, is_private=room.is_private, created_at=room.created_at)
        )
        await self.session.commit()

    async def get(self, room_id: UUID) -> Optional[Room]:  # type: ignore[override]
        row = await self.session.get(Rooms, room_id)
        if not row:
            return None
        return Room(id=row.id, name=RoomName(row.name), owner_id=row.owner_id, is_private=row.is_private, created_at=row.created_at)

    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:  # type: ignore[override]
        stmt = select(Rooms)
        if owner_id:
            stmt = stmt.where(Rooms.owner_id == owner_id)
        stmt = stmt.offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Room(id=r.id, name=RoomName(r.name), owner_id=r.owner_id, is_private=r.is_private, created_at=r.created_at) for r in rows]

    async def delete(self, room_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(delete(Rooms).where(Rooms.id == room_id))
        await self.session.commit()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\users.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import User
from ....core.domain.values import Email, PasswordHash
from ....core.ports.repositories import UserRepository
from ..models import Users
from ....core.errors import ConflictError


class PgUserRepository(UserRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_email(self, email: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.email == email)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_id(self, user_id: UUID) -> Optional[User]:  # type: ignore[override]
        row = await self.session.get(Users, user_id)
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_username(self, username: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.username == username)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def add(self, user: User) -> None:  # type: ignore[override]
        self.session.add(Users(id=user.id, email=str(user.email), username=user.username, password_hash=str(user.password_hash), created_at=user.created_at))
        try:
            await self.session.commit()
        except IntegrityError as e:
            await self.session.rollback()
            # Переводим БД-ошибку в доменную 409
            raise ConflictError("User with same email or username already exists") from e
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\provider.py ---
# app/presentation/infrastructure/ice/provider.py
from __future__ import annotations

import json
import os
from typing import Any, Protocol


class IceConfigProvider(Protocol):
    async def get_servers(self) -> dict[str, Any]: ...


def _get_env(name: str, default: str | None = None) -> str | None:
    val = os.getenv(name)
    return val if val is not None else default


class EnvIceConfigProvider:
    """
    Читает STUN/TURN из env и отдаёт структуру WebRTC ICE.
    Поддерживает:
      - STUN_SERVERS: JSON-массив или строка с запятыми
      - TURN_URLS: JSON-массив или строка с запятыми
      - TURN_URL: одиночная строка (legacy)
    """

    async def get_servers(self) -> dict[str, Any]:
        # --- STUN ---
        stun_raw = _get_env("STUN_SERVERS", '["stun:stun.l.google.com:19302"]')
        stun_servers: list[str] = []
        if stun_raw:
            try:
                if stun_raw.strip().startswith("["):
                    stun_servers = json.loads(stun_raw)
                else:
                    stun_servers = [s.strip() for s in stun_raw.split(",") if s.strip()]
            except Exception:
                stun_servers = []

        # --- TURN ---
        # Новое: поддержка списка URL (UDP/TCP и т.д.)
        turn_urls_raw = _get_env("TURN_URLS") or _get_env("TURN_URL")
        turn_username = _get_env("TURN_USERNAME")
        turn_password = _get_env("TURN_PASSWORD")

        turn_urls: list[str] = []
        if turn_urls_raw:
            try:
                if turn_urls_raw.strip().startswith("["):
                    turn_urls = json.loads(turn_urls_raw)
                else:
                    turn_urls = [u.strip() for u in turn_urls_raw.split(",") if u.strip()]
            except Exception:
                turn_urls = [turn_urls_raw]

        ice: list[dict[str, Any]] = []
        if stun_servers:
            ice.append({"urls": stun_servers})
        if turn_urls and turn_username and turn_password:
            ice.append(
                {
                    "urls": turn_urls,
                    "username": turn_username,
                    "credential": turn_password,
                }
            )

        return {"iceServers": ice}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\inmemory_bus.py ---
from __future__ import annotations

import asyncio
from collections import defaultdict
from typing import AsyncIterator, Dict, List
from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class InMemorySignalBus(SignalBus):
    def __init__(self) -> None:
        self.queues: Dict[UUID, List[asyncio.Queue[Signal]]] = defaultdict(list)
        self._presence: Dict[UUID, set[str]] = defaultdict(set)

    async def publish(self, room_id: UUID, signal: Signal) -> None:  # type: ignore[override]
        for q in list(self.queues[room_id]):
            await q.put(signal)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:  # type: ignore[override]
        q: asyncio.Queue[Signal] = asyncio.Queue()
        self.queues[room_id].append(q)
        try:
            while True:
                try:
                    s = await q.get()
                except asyncio.CancelledError:
                    # нормальный выход при отмене таска-подписчика
                    break
                else:
                    yield s
        finally:
            self.queues[room_id].remove(q)

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:  # type: ignore[override]
        if present:
            self._presence[room_id].add(str(user_id))
        else:
            self._presence[room_id].discard(str(user_id))

    async def list_presence(self, room_id: UUID) -> List[dict]:  # type: ignore[override]
        return [{"user_id": uid, "present": True} for uid in self._presence[room_id]]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\redis_bus.py ---
from __future__ import annotations

import asyncio
import json
from typing import Any, AsyncIterator
from uuid import UUID

import redis.asyncio as aioredis

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus
from ..config import get_settings


class RedisSignalBus(SignalBus):
    def __init__(self, redis: aioredis.Redis | None = None) -> None:
        self.settings = get_settings()
        self.redis = redis or aioredis.from_url(self.settings.REDIS_URL, decode_responses=True)

    def _channel(self, room_id: UUID) -> str:
        return f"room:{room_id}:signals"

    def _presence_key(self, room_id: UUID) -> str:
        return f"room:{room_id}:presence"

    async def publish(self, room_id: UUID, signal: Signal) -> None:
        payload = json.dumps(
            {
                "type": signal.type.value,
                "sender_id": str(signal.sender_id),
                "target_id": str(signal.target_id) if signal.target_id else None,
                "room_id": str(signal.room_id),
                "sdp": signal.sdp,
                "candidate": signal.candidate,
                "sent_at": signal.sent_at.isoformat(),
            }
        )
        await self.redis.publish(self._channel(room_id), payload)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:
        pubsub = self.redis.pubsub()
        await pubsub.subscribe(self._channel(room_id))
        try:
            async for msg in pubsub.listen():
                if msg["type"] != "message":
                    continue
                data = json.loads(msg["data"])  # type: ignore[arg-type]
                yield Signal.create(
                    type=data["type"],
                    sender_id=UUID(data["sender_id"]),
                    room_id=UUID(data["room_id"]),
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["target_id"]) if data.get("target_id") else None,
                )
        finally:
            await pubsub.unsubscribe(self._channel(room_id))
            await pubsub.close()

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        key = self._presence_key(room_id)
        if present:
            await self.redis.hset(key, str(user_id), json.dumps({"present": True}))
        else:
            await self.redis.hdel(key, str(user_id))
        await self.redis.expire(key, 60 * 60)

    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        key = self._presence_key(room_id)
        data = await self.redis.hgetall(key)
        result: list[dict[str, Any]] = []
        for uid, v in data.items():
            try:
                obj = json.loads(v)
            except Exception:
                obj = {"present": True}
            obj["user_id"] = uid
            result.append(obj)
        return result
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\jwt_provider.py ---
from __future__ import annotations

from datetime import datetime, timedelta, timezone

from jose import JWTError, jwt

from ...core.ports.services import TokenProvider
from ..config import get_settings


class JoseTokenProvider(TokenProvider):
    def __init__(self) -> None:
        self.settings = get_settings()
        self.algorithm = "HS256"

    def create_access_token(self, subject: str, expires_minutes: int | None = None) -> str:  # type: ignore[override]
        expires_minutes = expires_minutes or self.settings.JWT_EXPIRES_MIN
        now = datetime.now(tz=timezone.utc)
        payload = {"sub": subject, "iat": int(now.timestamp()), "exp": int((now + timedelta(minutes=expires_minutes)).timestamp())}
        return jwt.encode(payload, self.settings.JWT_SECRET, algorithm=self.algorithm)

    def decode_token(self, token: str) -> dict:  # type: ignore[override]
        try:
            return jwt.decode(token, self.settings.JWT_SECRET, algorithms=[self.algorithm])
        except JWTError as e:
            raise ValueError("Invalid token") from e
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\password_hasher.py ---
from __future__ import annotations

from passlib.context import CryptContext

from ...core.ports.services import PasswordHasher


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class BcryptPasswordHasher(PasswordHasher):
    def hash(self, password: str) -> str:
        return pwd_context.hash(password)

    def verify(self, password: str, password_hash: str) -> bool:
        return pwd_context.verify(password, password_hash)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\docs.py ---
from __future__ import annotations

from typing import List


def get_openapi_tags() -> List[dict]:
    return [
        {"name": "auth", "description": "Аутентификация"},
        {"name": "rooms", "description": "Комнаты"},
        {"name": "participants", "description": "Участники"},
        {"name": "messages", "description": "Сообщения"},
        {"name": "webrtc", "description": "WebRTC вспомогательные"},
        {"name": "health", "description": "Health checks"},
    ]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\errors.py ---
from __future__ import annotations

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

from ..core.errors import AuthError, ConflictError, DomainError, NotFoundError, PermissionDenied, ValidationError


def setup_error_handlers(app: FastAPI) -> None:
    @app.exception_handler(ValidationError)
    async def _validation(_: Request, exc: ValidationError):
        return JSONResponse(status_code=400, content={"detail": str(exc)})

    @app.exception_handler(AuthError)
    async def _auth(_: Request, exc: AuthError):
        return JSONResponse(status_code=401, content={"detail": str(exc)})

    @app.exception_handler(NotFoundError)
    async def _not_found(_: Request, exc: NotFoundError):
        return JSONResponse(status_code=404, content={"detail": str(exc)})

    @app.exception_handler(ConflictError)
    async def _conflict(_: Request, exc: ConflictError):
        return JSONResponse(status_code=409, content={"detail": str(exc)})

    @app.exception_handler(PermissionDenied)
    async def _forbidden(_: Request, exc: PermissionDenied):
        return JSONResponse(status_code=403, content={"detail": str(exc)}).
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\auth.py ---
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

from ....core.errors import NotFoundError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import TokenProvider
from .containers import get_user_repo, get_token_provider


bearer_scheme = HTTPBearer(auto_error=False)


async def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials | None, Depends(bearer_scheme)],
    users: UserRepository = Depends(get_user_repo),
    tokens: TokenProvider = Depends(get_token_provider),
):
    if not credentials:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    try:
        payload = tokens.decode_token(credentials.credentials)
        sub = payload.get("sub")
        user = await users.get_by_id(UUID(sub))
        if not user:
            raise NotFoundError()
        return user
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\containers.py ---
from __future__ import annotations

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session
from ....infrastructure.db.session import get_session as _get_session
from ....infrastructure.db.repositories.users import PgUserRepository
from ....infrastructure.db.repositories.rooms import PgRoomRepository
from ....infrastructure.db.repositories.participants import PgParticipantRepository
from ....infrastructure.db.repositories.messages import PgMessageRepository
from ....infrastructure.security.password_hasher import BcryptPasswordHasher
from ....infrastructure.security.jwt_provider import JoseTokenProvider
from ....infrastructure.ice.provider import EnvIceConfigProvider


# DB session
# DB session provider
async def get_db_session() -> AsyncSession:
    async with _get_session() as s:  # type: ignore[misc]
        return s
from ....infrastructure.messaging.redis_bus import RedisSignalBus
from ....infrastructure.messaging.inmemory_bus import InMemorySignalBus
from ....infrastructure.config import get_settings
from functools import lru_cache


# Repositories
async def get_user_repo(session: AsyncSession = Depends(get_db_session)):
    return PgUserRepository(session)


async def get_room_repo(session: AsyncSession = Depends(get_db_session)):
    return PgRoomRepository(session)


async def get_participant_repo(session: AsyncSession = Depends(get_db_session)):
    return PgParticipantRepository(session)


async def get_message_repo(session: AsyncSession = Depends(get_db_session)):
    return PgMessageRepository(session)


# Services
def get_password_hasher():
    return BcryptPasswordHasher()


def get_token_provider():
    return JoseTokenProvider()


def get_signal_bus():
    # Singleton SignalBus per process to ensure all WS share the same bus
    return _get_signal_bus_singleton()


@lru_cache(maxsize=1)
def _get_signal_bus_singleton():
    s = get_settings()
    # Use in-memory bus by default for local/dev/testing; switch to Redis via env
    if s.APP_ENV in {"dev", "test"}:
        return InMemorySignalBus()
    return RedisSignalBus()


def get_ice_provider():
    return EnvIceConfigProvider()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\db.py ---
from __future__ import annotations

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session


async def get_db_session() -> AsyncIterator[AsyncSession]:
    async with get_session() as session:
        yield session
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\auth.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from ....application.dto.auth import LoginInput, RegisterInput, RegisterOutput, TokenOutput
from ....core.domain.models import User
from ....core.errors import ConflictError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import PasswordHasher, TokenProvider
from ..deps.containers import get_password_hasher, get_token_provider, get_user_repo

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])


@router.post("/register", response_model=RegisterOutput, status_code=status.HTTP_201_CREATED)
async def register(
    data: RegisterInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
) -> RegisterOutput:  # type: ignore[override]
    from ....application.use_cases.auth import RegisterUser

    use = RegisterUser(users, hasher)
    user = await use.execute(email=data.email, username=data.username, password=data.password)
    return RegisterOutput(id=str(user.id), email=str(user.email), username=user.username)


@router.post("/login", response_model=TokenOutput)
async def login(
    data: LoginInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
    tokens: TokenProvider = Depends(get_token_provider),
) -> TokenOutput:  # type: ignore[override]
    from ....application.use_cases.auth import LoginUser

    use = LoginUser(users, hasher, tokens)
    access = await use.execute(email=data.email, password=data.password)
    return TokenOutput(access_token=access)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\messages.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.messages import MessageDTO, PostMessageInput
from ....application.use_cases.messages import ListMessages, PostMessage
from ....core.ports.repositories import MessageRepository
from ..deps.containers import get_message_repo

router = APIRouter(prefix="/api/v1/rooms/{room_id}/messages", tags=["messages"])


@router.post("", response_model=MessageDTO)
async def post_message(room_id: str, data: PostMessageInput, messages: MessageRepository = Depends(get_message_repo)) -> MessageDTO:  # type: ignore[override]
    use = PostMessage(messages)
    msg = await use.execute(room_id=UUID(room_id), author_id=UUID(data.author_id), content=data.content)
    return MessageDTO(id=str(msg.id), room_id=str(msg.room_id), author_id=str(msg.author_id), content=msg.content, sent_at=msg.sent_at)


@router.get("", response_model=list[MessageDTO])
async def list_messages(room_id: str, skip: int = 0, limit: int = 50, messages: MessageRepository = Depends(get_message_repo)):  # type: ignore[override]
    use = ListMessages(messages)
    items = await use.execute(room_id=UUID(room_id), skip=skip, limit=limit)
    return [MessageDTO(id=str(m.id), room_id=str(m.room_id), author_id=str(m.author_id), content=m.content, sent_at=m.sent_at) for m in items]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\participants.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException

from ....application.use_cases.participants import JoinRoom, KickParticipant, LeaveRoom, ToggleMute
from ....core.domain.models import Role
from ....core.errors import NotFoundError
from ....core.ports.repositories import ParticipantRepository, RoomRepository
from ..deps.containers import get_participant_repo, get_room_repo
from ....core.services.room_service import RoomService

router = APIRouter(prefix="/api/v1/rooms/{room_id}", tags=["participants"])


@router.post("/join")
async def join_room(
    room_id: str,
    user_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
    rooms: RoomRepository = Depends(get_room_repo),
) -> dict:  # type: ignore[override]
    use = JoinRoom(participants, rooms, RoomService())
    p = await use.execute(room_id=UUID(room_id), user_id=UUID(user_id), role=Role.member)
    return {"status": "ok", "participantId": str(p.id)}


@router.post("/leave")
async def leave_room(room_id: str, user_id: str, participants: ParticipantRepository = Depends(get_participant_repo)) -> dict:  # type: ignore[override]
    use = LeaveRoom(participants)
    await use.execute(room_id=UUID(room_id), user_id=UUID(user_id))
    return {"status": "ok"}


@router.post("/kick/{target_id}")
async def kick(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = KickParticipant(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}


@router.post("/toggle-mute/{target_id}")
async def toggle_mute(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = ToggleMute(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\rooms.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.rooms import CreateRoomInput, ListRoomsInput, RoomDTO
from ....application.use_cases.rooms import CreateRoom, GetRoom, ListRooms
from ....core.ports.repositories import RoomRepository
from ..deps.containers import get_room_repo
from ..deps.auth import get_current_user

router = APIRouter(prefix="/api/v1/rooms", tags=["rooms"])


@router.post("", response_model=RoomDTO)
async def create_room(
    data: CreateRoomInput,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = CreateRoom(rooms)
    room = await use.execute(name=data.name, owner_id=UUID(str(current_user.id)), is_private=data.is_private)
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.get("", response_model=list[RoomDTO])
async def list_rooms(
    owner_id: str | None = None,
    skip: int = 0,
    limit: int = 50,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    use = ListRooms(rooms)
    rid = UUID(owner_id) if owner_id else None
    items = await use.execute(owner_id=rid, skip=skip, limit=limit)
    return [RoomDTO(id=str(r.id), name=str(r.name), owner_id=str(r.owner_id), is_private=r.is_private, created_at=r.created_at) for r in items]


@router.get("/{room_id}", response_model=RoomDTO)
async def get_room(
    room_id: str,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = GetRoom(rooms)
    room = await use.execute(UUID(room_id))
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.delete("/{room_id}")
async def delete_room(
    room_id: str,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    from ....application.use_cases.rooms import DeleteRoom, GetRoom

    getter = GetRoom(rooms)
    room = await getter.execute(UUID(room_id))
    if not room or str(room.owner_id) != str(current_user.id):
        from fastapi import HTTPException, status

        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only owner can delete room")
    deleter = DeleteRoom(rooms)
    await deleter.execute(UUID(room_id))
    return {"status": "deleted"}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\webrtc.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends

from ....core.ports.services import IceConfigProvider
from ..deps.containers import get_ice_provider

router = APIRouter(prefix="/api/v1/webrtc", tags=["webrtc"])


@router.get("/ice-servers")
async def ice_servers(provider: IceConfigProvider = Depends(get_ice_provider)) -> dict:  # type: ignore[override]
    return await provider.get_servers()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\schemas\api.py ---
from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class ErrorResponse(BaseModel):
    detail: str


class UserOut(BaseModel):
    id: str
    email: str
    username: str


class RoomCreateIn(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomOut(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class MessageIn(BaseModel):
    content: str = Field(min_length=1, max_length=2000)


class MessageOut(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime


class SignalIn(BaseModel):
    signalType: str
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    targetUserId: Optional[str] = None


class PresenceOut(BaseModel):
    users: list[dict]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\auth.html ---
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Вход | WebCall</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .auth-card { max-width: 520px; margin: 10vh auto; }
      .tabs { display:flex; gap:8px; margin-bottom:12px }
      .tab { padding:8px 12px; border-radius:8px; border:1px solid var(--border); cursor:pointer; background:#0b1220 }
      .tab.active { background: var(--primary); border-color: var(--primary) }
      .hint { color: var(--muted); font-size: 13px }
    </style>
  </head>
  <body>
    <main class="container">
      <div class="card auth-card">
        <h2>Добро пожаловать</h2>
        <div class="tabs">
          <button class="tab active" id="tabLogin">Вход</button>
          <button class="tab" id="tabRegister">Регистрация</button>
        </div>
        <div id="formLogin" class="form-grid">
          <label>
            <span>Email</span>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
          </label>
          <label>
            <span>Пароль</span>
            <input id="loginPassword" type="password" placeholder="••••••••" />
          </label>
          <button id="btnDoLogin" class="btn primary">Войти</button>
          <div class="hint">Если у вас нет аккаунта — перейдите на вкладку «Регистрация».</div>
        </div>
        <div id="formRegister" class="form-grid" style="display:none">
          <label>
            <span>Email</span>
            <input id="regEmail" type="email" placeholder="you@example.com" />
          </label>
          <label>
            <span>Имя пользователя</span>
            <input id="regUsername" type="text" placeholder="Ваше имя" />
          </label>
          <label>
            <span>Пароль</span>
            <input id="regPassword" type="password" placeholder="••••••••" />
          </label>
          <button id="btnDoRegister" class="btn success">Зарегистрироваться</button>
          <div class="hint">После регистрации вы будете перенаправлены в звонок.</div>
        </div>
        <div id="authLog" class="logs" style="margin-top:12px;min-height:60px"></div>
      </div>
    </main>
    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>
    <script type="module" src="/static/js/auth.js"></script>
  </body>
</html>
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\index.html ---
<!doctype html>
<html lang="ru" class="theme-dark">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebCall</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <header class="topbar">
      <div class="wrap">
        <div class="brand">
          <span class="logo" aria-hidden>●</span>
          <span class="brand-name">WebCall</span>
        </div>
        <nav class="top-actions">
          <button id="btnToggleTheme" class="btn ghost" title="Переключить тему">🌓</button>
          <a class="btn ghost" href="/docs" target="_blank" rel="noreferrer">Docs</a>
        </nav>
      </div>
    </header>

    <main class="wrap layout">
      <!-- ЛЕВАЯ КОЛОНКА -->
      <aside class="side">
        <section class="card">
          <h2>Комната</h2>
          <div class="grid">
            <label class="full">
              <span class="label">Room ID</span>
              <input id="roomId" placeholder="room-123" />
            </label>
            <div class="row">
              <button id="btnConnect" class="btn success">Подключиться</button>
              <button id="btnLeave" class="btn" disabled>Выйти</button>
            </div>
            <button id="btnCopyLink" class="btn ghost full">Скопировать ссылку</button>
            <button id="btnForceConnect" class="btn ghost full" disabled>🔄 Переподключить всех</button>
            <button id="btnDiagnose" class="btn ghost full" disabled>🔍 Диагностика аудио</button>
            <div class="muted" id="connStatus">Не подключено</div>
          </div>
        </section>

        <section class="card">
          <h2>Устройства</h2>
          <div class="grid">
            <label class="full">
              <span class="label">Микрофон</span>
              <select id="micSel"></select>
            </label>
            <label class="full">
              <span class="label">Камера</span>
              <select id="camSel"></select>
            </label>
            <label class="full">
              <span class="label">Вывод звука</span>
              <select id="spkSel"></select>
            </label>
            <div class="row">
              <button id="btnToggleMic" class="btn" disabled>🎤 Микрофон</button>
              <button id="btnToggleCam" class="btn" disabled>🎥 Камера</button>
            </div>
          </div>
        </section>

        <section class="card compact">
          <h2>Состояние</h2>
          <div id="stats" class="stats"></div>
        </section>

        <section class="card compact">
          <h2>Логи</h2>
          <div id="logs" class="logs"></div>
        </section>
      </aside>

      <!-- ОСНОВНАЯ ОБЛАСТЬ -->
      <section class="stage">
        <div class="grid-2">
          <div class="card">
          <div class="card">
            <h3>Чат</h3>
            <div id="chat" class="chat-log" aria-live="polite"></div>
            <div class="chat-input">
              <input id="chatInput" placeholder="Напишите сообщение..." />
              <button id="btnSend" class="btn" disabled>Отправить</button>
            </div>
          </div>
        </div>

        <div class="card">
          <h3>Участники</h3>
          <div class="tiles" id="peersGrid" aria-live="polite"></div>
        </div>
      </section>
    </main>

    <!-- Шаблон плитки участника -->
    <template id="tpl-peer-tile">
      <div class="tile" data-peer="">
        <div class="media">
          <video autoplay playsinline></video>
          <audio class="peer-audio" autoplay></audio>
          <div class="avatar" aria-hidden>👤</div>
        </div>
        <div class="hud">
          <div class="row between">
            <div class="name">participant</div>
            <div class="badges">
              <span class="badge net" title="Сеть">🔴</span>
              <span class="badge audio" title="Аудио">🔇</span>
            </div>
          </div>
          <div class="meter"><span></span></div>
          <div class="row">
            <button class="btn xs mute">🔇 Mute</button>
            <input class="volume" type="range" min="0" max="1" step="0.01" value="1" />
          </div>
        </div>
      </div>
    </template>

    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>

    <script type="module" src="/static/js/main.js"></script>
  </body>
</html>
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\styles.css ---
:root{
  --bg:#070a14;
  --panel:#0c1222;
  --card:#0f1830;
  --text:#e8f0ff;
  --muted:#9aacc7;
  --border:#1a2540;
  --accent:#7c3aed;
  --accent-2:#06b6d4;
  --success:#22c55e;
  --ring:rgba(124,58,237,.35);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  background:
    radial-gradient(1000px 600px at 10% -10%, rgba(124,58,237,.14), transparent),
    radial-gradient(900px 500px at 110% 10%, rgba(6,182,212,.12), transparent),
    linear-gradient(180deg,#060913,#0b1220 60%,#0a1226 100%);
}
.wrap{max-width:1280px;margin:0 auto;padding:16px}
.topbar{position:sticky;top:0;backdrop-filter:blur(8px);background:rgba(10,16,32,.6);border-bottom:1px solid var(--border);z-index:20}
.topbar .wrap{display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;align-items:center;gap:10px}
.logo{display:inline-grid;place-items:center;width:22px;height:22px;border-radius:50%;background:conic-gradient(from 180deg, var(--accent), var(--accent-2));box-shadow:0 0 18px rgba(124,58,237,.45)}
.brand-name{font-weight:700;letter-spacing:.4px}
.top-actions{display:flex;gap:8px}

.layout{display:grid;grid-template-columns:320px 1fr;gap:16px}
@media(max-width:1000px){.layout{grid-template-columns:1fr}}

.card{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
  border:1px solid var(--border);border-radius:14px;padding:14px;box-shadow:0 10px 40px rgba(0,0,0,.28)}
.card h2,.card h3{margin:0 0 10px;font-size:16px}
.card.compact{padding:10px}

.side{display:flex;flex-direction:column;gap:16px}
.stage{display:flex;flex-direction:column;gap:16px}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
.grid .full{grid-column:1/-1}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media(max-width:900px){.grid-2{grid-template-columns:1fr}}

.label{font-size:13px;color:var(--muted)}
input,select{
  width:100%;background:#0b1220;border:1px solid var(--border);color:var(--text);
  padding:10px 12px;border-radius:10px;outline:none
}
input:focus,select:focus{border-color:var(--accent);box-shadow:0 0 0 4px var(--ring)}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.row.between{justify-content:space-between}
.btn{
  background:#0f172a;border:1px solid var(--border);color:var(--text);
  padding:8px 12px;border-radius:10px;cursor:pointer;transition:transform .1s ease, box-shadow .2s ease, border-color .2s ease
}
.btn:hover{border-color:#2a3347;box-shadow:0 0 0 4px rgba(124,58,237,.08);transform:translateY(-1px)}
.btn:disabled{opacity:.6;cursor:not-allowed}
.btn.ghost{background:transparent}
.btn.success{background:var(--success);border-color:var(--success)}
.btn.xs{padding:4px 8px;font-size:12px;border-radius:6px}

.video-surface{position:relative;aspect-ratio:16/9;background:#000;border-radius:12px;overflow:hidden;border:1px solid var(--border)}
.overlay-tip{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,.5);padding:6px 8px;border-radius:8px}

.tiles{display:grid;grid-template-columns:repeat(2,1fr);gap:12px}
@media(min-width:1200px){.tiles{grid-template-columns:repeat(3,1fr)}}
@media(max-width:700px){.tiles{grid-template-columns:1fr}}

.tile{position:relative;border:1px solid var(--border);border-radius:14px;overflow:hidden;background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015))}
.tile .media{position:relative;aspect-ratio:16/10;background:#0b1220}
.tile video{width:100%;height:100%;object-fit:cover;display:block}
.tile .avatar{position:absolute;inset:0;display:grid;place-items:center;font-size:42px;color:#94a3b8;filter:drop-shadow(0 6px 14px rgba(0,0,0,.4))}
.tile .gate{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  background:rgba(0,0,0,.6);border:1px solid var(--border);color:#fff;border-radius:999px;padding:10px 16px;
  backdrop-filter:blur(6px);display:none
}
.tile:hover .gate{display:block}
.tile .hud{display:flex;flex-direction:column;gap:6px;padding:8px}
.name{font-size:13px;letter-spacing:.2px}
.badge{font-size:12px;color:#8fb3ff}
.meter{position:relative;height:10px;background:#0b1220;border:1px solid var(--border);border-radius:6px;overflow:hidden;min-width:120px}
.meter>span{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,#06b6d4,#7c3aed);transition:width .08s linear}

.chat-log{height:260px;overflow:auto;border:1px dashed var(--border);border-radius:8px;padding:8px;background:#0b1220}
.chat-input{display:flex;gap:8px}

.logs, .stats{font-family:ui-monospace, Menlo, Consolas, monospace;background:#0b1220;border:1px solid var(--border);border-radius:8px;min-height:80px;max-height:200px;overflow:auto;padding:8px;color:#cbd5e1}
.log-line{display:flex;gap:8px}
.log-line .time{color:#64748b}
.muted{color:var(--muted)}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\api.js ---
// api.js - REST helpers
const base = '';

let iceServersCache = null;
let lastIceFetchTime = 0;
const ICE_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

export async function getIceServers() {
  if (iceServersCache && Date.now() - lastIceFetchTime < ICE_CACHE_DURATION) return iceServersCache;
  try {
    const res = await fetch(`${base}/api/v1/webrtc/ice-servers`);
    if (!res.ok) throw new Error('Failed to fetch ICE servers');
    iceServersCache = await res.json();
    lastIceFetchTime = Date.now();
    return iceServersCache;
  } catch (e) {
    console.warn('Using fallback ICE servers');
    return {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun2.l.google.com:19302" }
      ]
    };
  }
}

export async function login(email, password) {
  const res = await fetch(`${base}/api/v1/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Login failed: ${res.status} ${text}`);
  }
  return res.json(); // { access_token }
}

export async function register(email, username, password) {
  const res = await fetch(`${base}/api/v1/auth/register`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, username, password }),
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Register failed: ${res.status} ${text}`);
  }
  return res.json(); // { id, email, username }
}

export function buildWs(roomId, token) {
  const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
  const qp = token ? `?token=${encodeURIComponent(token)}` : '';
  return new WebSocket(`${wsProto}://${location.host}/ws/rooms/${encodeURIComponent(roomId)}${qp}`);
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\auth.js ---
// auth.js — регистрация/вход
import { login, register } from './api.js';

const els = {
  tabLogin: document.getElementById('tabLogin'),
  tabRegister: document.getElementById('tabRegister'),
  formLogin: document.getElementById('formLogin'),
  formRegister: document.getElementById('formRegister'),
  loginEmail: document.getElementById('loginEmail'),
  loginPassword: document.getElementById('loginPassword'),
  regEmail: document.getElementById('regEmail'),
  regUsername: document.getElementById('regUsername'),
  regPassword: document.getElementById('regPassword'),
  btnDoLogin: document.getElementById('btnDoLogin'),
  btnDoRegister: document.getElementById('btnDoRegister'),
  log: document.getElementById('authLog'),
};

function log(msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  els.log.appendChild(node);
  els.log.scrollTop = els.log.scrollHeight;
}

function setTab(isLogin){
  els.tabLogin.classList.toggle('active', isLogin);
  els.tabRegister.classList.toggle('active', !isLogin);
  els.formLogin.style.display = isLogin ? '' : 'none';
  els.formRegister.style.display = isLogin ? 'none' : '';
}

function getRedirect(){
  const url = new URL(location.href);
  return url.searchParams.get('redirect') || '/call';
}

function applyPostLogin(token){
  localStorage.setItem('wc_token', token);
  localStorage.setItem('wc_seen', '1');
  try{ const payload = JSON.parse(atob(token.split('.')[1])); localStorage.setItem('wc_user', payload.sub || ''); }catch{}
  const url = new URL(location.href);
  const redirect = getRedirect();
  const room = url.searchParams.get('room');
  if (room) {
    // поддержим /call/{room}
    if (redirect.startsWith('/call')) {
      location.href = `/call/${encodeURIComponent(room)}`;
      return;
    }
  }
  location.href = redirect;
}

async function doLogin(){
  const email = els.loginEmail.value.trim();
  const password = els.loginPassword.value;
  try{
    const data = await login(email, password);
    applyPostLogin(data.access_token);
  }catch(e){ log(String(e)); }
}

async function doRegister(){
  const email = els.regEmail.value.trim();
  const username = els.regUsername.value.trim();
  const password = els.regPassword.value;
  try{
    await register(email, username, password);
    log('Регистрация успешна. Выполняем вход...');
    const data = await login(email, password);
    applyPostLogin(data.access_token);
  }catch(e){ log(String(e)); }
}

// Инициализация
(function init(){
  const seen = localStorage.getItem('wc_seen') === '1';
  setTab(seen); // если уже были — показываем логин

  els.tabLogin.addEventListener('click', ()=> setTab(true));
  els.tabRegister.addEventListener('click', ()=> setTab(false));
  els.btnDoLogin.addEventListener('click', doLogin);
  els.btnDoRegister.addEventListener('click', doRegister);
})();
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\main.js ---
// main.js — вход
import { buildWs } from './api.js';
import { sendChat, isWsOpen } from './signal.js';
import { WebRTCManager } from './webrtc.js';
import { bind, setText, setEnabled, appendLog, appendChat } from './ui.js';

let token = null;
let ws = null;
let rtc = null;
let userId = null;
let reconnectTimeout = null;
let isManuallyDisconnected = false;

// выбранные устройства
let selected = { mic: null, cam: null, spk: null };

const els = {
  roomId: document.getElementById('roomId'),
  btnConnect: document.getElementById('btnConnect'),
  btnLeave: document.getElementById('btnLeave'),
  btnCopyLink: document.getElementById('btnCopyLink'),
  btnForceConnect: document.getElementById('btnForceConnect'),
  btnDiagnose: document.getElementById('btnDiagnose'),
  btnSend: document.getElementById('btnSend'),
  chatInput: document.getElementById('chatInput'),
  connStatus: document.getElementById('connStatus'),
  logs: document.getElementById('logs'),
  chat: document.getElementById('chat'),
  btnToggleMic: document.getElementById('btnToggleMic'),
  btnToggleCam: document.getElementById('btnToggleCam'),
  localVideo: document.getElementById('localVideo'),
  peersGrid: document.getElementById('peersGrid'),
  stats: document.getElementById('stats'),
  micSel: document.getElementById('micSel'),
  camSel: document.getElementById('camSel'),
  spkSel: document.getElementById('spkSel'),
  btnToggleTheme: document.getElementById('btnToggleTheme'),
};

function log(msg){ appendLog(els.logs, msg); }
function stat(line){ els.stats && appendLog(els.stats, line); }

function setConnectedState(connected){
  setText(els.connStatus, connected ? 'Подключено' : 'Не подключено');
  setEnabled(els.btnConnect, !connected);
  setEnabled(els.btnSend, connected);
  setEnabled(els.btnLeave, connected);
  setEnabled(els.btnToggleMic, connected);
  setEnabled(els.btnToggleCam, connected);
  setEnabled(els.btnForceConnect, connected);
  setEnabled(els.btnDiagnose, connected);
}

function ensureToken(){
  token = localStorage.getItem('wc_token');
  if (!token){
    const params = new URLSearchParams({ redirect: '/call' });
    if (els.roomId.value) params.set('room', els.roomId.value);
    location.href = `/auth?${params.toString()}`;
    return false;
  }
  try{
    const payload = JSON.parse(atob(token.split('.')[1]));
    userId = payload.sub;
    const now = Math.floor(Date.now()/1000);
    if (payload.exp && now >= payload.exp) {
      localStorage.removeItem('wc_token');
      const p = new URLSearchParams({ redirect: '/call' });
      if (els.roomId.value) p.set('room', els.roomId.value);
      location.href = `/auth?${p.toString()}`;
      return false;
    }
  }catch{}
  return true;
}

// ===== Устройства
async function refreshDevices(){
  if (!navigator.mediaDevices?.enumerateDevices) return;
  const devs = await navigator.mediaDevices.enumerateDevices();
  const mics = devs.filter(d => d.kind === 'audioinput');
  const cams = devs.filter(d => d.kind === 'videoinput');
  const spks = devs.filter(d => d.kind === 'audiooutput');

  const fill = (sel, list, picked) => {
    sel.innerHTML = '';
    list.forEach(d => {
      const o = document.createElement('option');
      o.value = d.deviceId;
      o.textContent = d.label || `Unknown ${d.kind}`;
      if (picked && picked === d.deviceId) o.selected = true;
      sel.appendChild(o);
    });
  };
  fill(els.micSel, mics, selected.mic);
  fill(els.camSel, cams, selected.cam);
  fill(els.spkSel, spks, selected.spk);

  const summary = devs.map(d => `${d.kind}:${d.label||'(no)'}:${(d.deviceId||'').slice(0,6)}`).join(' | ');
  stat(`Devices: ${summary}`);
}

[els.micSel, els.camSel, els.spkSel].forEach(sel => sel?.addEventListener('change', async ()=>{
  selected.mic = els.micSel.value || null;
  selected.cam = els.camSel.value || null;
  selected.spk = els.spkSel.value || null;
  if (rtc) rtc.setPreferredDevices({ mic: selected.mic, cam: selected.cam, spk: selected.spk });
}));

// ===== Подключение
async function connect(){
  const roomId = els.roomId.value.trim();
  if (!roomId){ log('Введите Room ID'); return; }
  if (!ensureToken()) return;
  isManuallyDisconnected = false;

  try{ if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(); }catch{}
  if (reconnectTimeout) { clearTimeout(reconnectTimeout); reconnectTimeout = null; }

  await refreshDevices();

  // Запрашиваем permission до WS, чтобы labels появились и autoplay был «теплее»
  try {
    log('Запрашиваем разрешение на микрофон...');
    const temp = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true, noiseSuppression: true, autoGainControl: true,
        deviceId: selected.mic ? { exact: selected.mic } : undefined
      }, video: false
    });
    temp.getTracks().forEach(t => t.stop());
    log('Разрешение на микрофон получено');
  } catch(e) {
    log(`Ошибка доступа к микрофону: ${e?.name||e}`);
    alert('Нужно разрешение на микрофон.');
    return;
  }

  ws = buildWs(roomId, token);

  ws.onopen = async () => {
    log('WS connected');
    setConnectedState(true);

    // Максимально агрессивная активация аудио контекста
    try {
      // Создаем несколько аудио контекстов для надежности
      for (let i = 0; i < 3; i++) {
        const ac = new AudioContext();
        if (ac.state === 'suspended') await ac.resume();
        
        // Создаем беззвучный генератор для "пробуждения" браузера
        const osc = ac.createOscillator();
        const gain = ac.createGain();
        gain.gain.value = 0.001; // Очень тихо, но не 0
        osc.connect(gain).connect(ac.destination);
        osc.start();
        osc.stop(ac.currentTime + 0.1);
        
        setTimeout(() => { try { ac.close(); } catch {} }, 500);
      }
      
      // Дополнительно эмулируем пользовательское взаимодействие
      document.addEventListener('click', function enableAudio() {
        const ac = new AudioContext();
        if (ac.state === 'suspended') ac.resume();
        document.removeEventListener('click', enableAudio);
        try { ac.close(); } catch {}
      }, { once: true });
      
      log('🎧 Аудио контекст агрессивно активирован для автовоспроизведения');
    } catch(e) { 
      log(`⚠️ Не удалось активировать аудио контекст: ${e}`); 
    }

    rtc = new WebRTCManager({
      localVideo: els.localVideo,
      outputDeviceId: selected.spk,
      onLog: log,
      onPeerState: (peerId, key, val) => {
        const tile = els.peersGrid.querySelector(`.tile[data-peer="${peerId}"]`);
        if (!tile) return;
        if (key === 'net') {
          const badge = tile.querySelector('.badge.net');
          if (badge) {
            badge.textContent = val === 'connected' ? '🟢' : (val === 'connecting' ? '🟡' : '🔴');
            badge.title = val;
          }
        }
      }
    });

    if (!userId) userId = crypto.randomUUID();

    try{
      await rtc.init(ws, userId, { micId: selected.mic || undefined, camId: selected.cam || undefined });
      if (isWsOpen(ws)) {
        ws.send(JSON.stringify({
          type: 'join',
          fromUserId: userId,
          username: localStorage.getItem('wc_user') || 'User'
        }));
      }
    }catch(e){ log(`Ошибка старта WebRTC: ${e?.name||e}`); }
  };

  ws.onmessage = async (ev) => {
    try {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'signal') {
        await rtc?.handleSignal(msg, attachPeerMedia);
      } else if (msg.type === 'chat') {
        const who = msg.authorName || msg.authorId || 'system';
        appendChat(els.chat, who, msg.content || msg.echo || '');
      } else if (msg.type === 'presence') {
        renderPresence(msg.members || []);
      }
    } catch (e) { log(`Ошибка обработки сообщения: ${e}`); }
  };

  ws.onclose = (ev) => {
    log(`WS closed (${ev?.code||''} ${ev?.reason||''})`);
    setConnectedState(false);
    if (ev?.code === 4401) {
      log('Сессия авторизации недействительна. Переходим на страницу входа...');
      isManuallyDisconnected = true;
      if (reconnectTimeout) { clearTimeout(reconnectTimeout); reconnectTimeout = null; }
      const params = new URLSearchParams({ redirect: location.pathname + location.search });
      location.href = `/auth?${params.toString()}`;
      return;
    }
    if (!isManuallyDisconnected && !reconnectTimeout) {
      log('Попытка переподключения через 2 секунды...');
      reconnectTimeout = setTimeout(connect, 2000);
    }
  };

  ws.onerror = (err) => { log(`WS error: ${err}`); };
}

function leave(){
  isManuallyDisconnected = true;
  if (reconnectTimeout) { clearTimeout(reconnectTimeout); reconnectTimeout = null; }
  rtc?.close();
  try{ if (isWsOpen(ws)) ws.send(JSON.stringify({ type: 'leave', fromUserId: userId })); }catch{}
  try{ ws?.close(); }catch{}
  setConnectedState(false);
}

function copyLink(){
  const rid = els.roomId.value.trim();
  const pretty = `${location.origin}/call/${encodeURIComponent(rid)}`;
  navigator.clipboard.writeText(pretty);
  log('Ссылка скопирована');
}

function send(){
  const text = els.chatInput.value.trim();
  if (!text) return;
  sendChat(ws, text, userId);
  els.chatInput.value = '';
}

function toggleMic(){
  const on = rtc?.toggleMic();
  log(`Микрофон: ${on ? 'вкл' : 'выкл'}`);
}

function toggleCam(){
  const on = rtc?.toggleCam();
  log(`Камера: ${on ? 'вкл' : 'выкл'}`);
}

function restoreFromUrl(){
  const url = new URL(location.href);
  const rid = url.searchParams.get('room');
  if (rid) { els.roomId.value = rid; return; }
  const parts = location.pathname.split('/').filter(Boolean);
  if (parts[0] === 'call' && parts[1]) els.roomId.value = decodeURIComponent(parts[1]);
}

function toggleTheme(){ document.documentElement.classList.toggle('theme-light'); }

// Принудительное переподключение ко всем активным
function forceReconnectAll() {
  if (!rtc) return;
  log('Принудительное переподключение ко всем участникам...');
  const activePeers = Array.from(els.peersGrid.querySelectorAll('.tile')).map(t => t.dataset.peer);
  for (const peerId of activePeers) {
    const peer = rtc.getPeer(peerId);
    if (peer) {
      log(`Переподключение к ${peerId.slice(0,8)}...`);
      try { peer.pc?.close(); } catch {}
      rtc.peers.delete(peerId);
      if (userId && peerId && userId < peerId) setTimeout(() => rtc.startOffer(peerId), 200);
    }
  }
}

function diagnoseAudio() {
  if (!rtc) return log('WebRTC менеджер не инициализирован');
  rtc.diagnoseAudio();
}

// ===== Привязка плеера к peer
function attachPeerMedia(peerId, handlers){
  rtc?.bindPeerMedia?.(peerId, handlers);
}

// ===== Отрисовка presence и детерминированный запуск офферов
function renderPresence(members){
  const my = userId;
  const list = members.map(m => (typeof m === 'string' ? {id:m, name:m.slice(0,8)} : m));
  const others = list.filter(x=>x.id!==my);

  const grid = els.peersGrid;
  const existing = new Set(Array.from(grid.querySelectorAll('.tile')).map(n=>n.dataset.peer));

  for (const pid of existing){
    if (!others.some(o=>o.id===pid)) {
      grid.querySelector(`.tile[data-peer="${pid}"]`)?.remove();
      if (rtc) {
        const peer = rtc.getPeer(pid);
        if (peer) { try { peer.pc?.close(); } catch {} rtc.peers.delete(pid); }
      }
    }
  }

  const tpl = document.getElementById('tpl-peer-tile');
  for (const peer of others){
    if (grid.querySelector(`.tile[data-peer="${peer.id}"]`)) continue;

    const node = tpl.content.firstElementChild.cloneNode(true);
    node.dataset.peer = peer.id;
    node.querySelector('.name').textContent = peer.name || peer.id.slice(0,8);

  const video = node.querySelector('video');
  const audioEl = node.querySelector('audio.peer-audio');
    const meterBar = node.querySelector('.meter>span');
    const muteBtn = node.querySelector('.mute');
    const vol = node.querySelector('.volume');

    // Настройки авто-воспроизведения: основной звук выводим через <audio>
    video.muted = true; // видео оставляем без звука
    video.autoplay = true;
    video.playsInline = true;
    if (audioEl) {
      audioEl.autoplay = true;
      // По умолчанию WebAudio будет выводить звук, поэтому элемент аудио держим беззвучным как фолбэк
      audioEl.muted = true;
      audioEl.volume = 0.0;
      if (typeof audioEl.setSinkId === 'function' && rtc?.getOutputDeviceId()){
        audioEl.setSinkId(rtc.getOutputDeviceId()).catch(e=> log(`setSinkId: ${e}`));
      }
    }

    // Фолбэк-контролы для media element; при появлении WebAudio-контролов отключим их
    let usingCtl = false;
    const fallbackMute = ()=>{
      const target = audioEl || video;
      target.muted = !target.muted;
      muteBtn.textContent = target.muted ? '🔊 Unmute' : '🔇 Mute';
    };
    const fallbackVol = ()=>{ (audioEl || video).volume = parseFloat(vol.value || '1'); };
    muteBtn.addEventListener('click', fallbackMute);
    vol.addEventListener('input', fallbackVol);

    attachPeerMedia(peer.id, {
      onTrack: async (stream)=>{
        // присвоим и видео, и аудио
        video.srcObject = stream;
        if (audioEl) audioEl.srcObject = stream;
        node.querySelector('.avatar').style.display='none';

        const hasAudio = stream.getAudioTracks().length > 0;
        const audioBadge = node.querySelector('.badge.audio');
        if (audioBadge){
          audioBadge.textContent = hasAudio ? '🎵' : '🔇';
          audioBadge.title = hasAudio ? 'Аудио активно' : 'Нет аудио';
        }

        // Пытаемся запустить воспроизведение фолбэка (на случай, если WebAudio не сработает)
        try{
          if (audioEl) { await audioEl.play(); } else { await video.play(); }
          log(`▶️ Поток автоматически запущен от ${peer.name || peer.id.slice(0,8)} (аудио=${hasAudio})`);
        }catch(e){
          log(`⚠️ Autoplay заблокирован, пробуем для ${peer.name || peer.id.slice(0,8)}: ${e?.name||e}`);
          const retryPlay = async () => {
            for(let i = 0; i < 5; i++) {
              try {
                if (audioEl) { await audioEl.play(); } else { await video.play(); }
                log(`✅ Воспроизведение успешно после попытки ${i+1}`);
                return;
              } catch {
                if (i < 4) await new Promise(r => setTimeout(r, 200));
              }
            }
            log(`❌ Не удалось запустить автовоспроизведение после 5 попыток`);
          };
          retryPlay();
        }
      },
      onLevel: (lvl)=>{
        if (meterBar) meterBar.style.width = `${Math.min(1, Math.max(0, lvl)) * 100}%`;
        const audioBadge = node.querySelector('.badge.audio');
        if (audioBadge && lvl > 0.01) {
          audioBadge.textContent = '🎤';
          setTimeout(()=>{ if (audioBadge.textContent === '🎤') audioBadge.textContent = '🎵'; }, 180);
        }
      },
      onControl: (ctl)=>{
        if (usingCtl) return;
        // Отключаем фолбэк и подключаем управление через WebAudio
        muteBtn.removeEventListener('click', fallbackMute);
        vol.removeEventListener('input', fallbackVol);
        usingCtl = true;
        if (audioEl) { audioEl.muted = true; audioEl.volume = 0.0; }
        // Инициализируем UI и обработчики
        muteBtn.textContent = ctl.getMuted?.() ? '🔊 Unmute' : '🔇 Mute';
        vol.addEventListener('input', ()=> ctl.setVolume(parseFloat(vol.value || '1')));
        muteBtn.addEventListener('click', ()=>{
          const nowMuted = !ctl.getMuted?.();
          ctl.setMuted(nowMuted);
          muteBtn.textContent = nowMuted ? '🔊 Unmute' : '🔇 Mute';
        });
      }
    });

    grid.appendChild(node);

    if (my && peer?.id && my < peer.id) {
      log(`Инициируем соединение с ${peer.name || peer.id.slice(0,8)}`);
      setTimeout(() => rtc?.startOffer?.(peer.id), 100);
    } else {
      log(`Ожидаем соединение от ${peer.name || peer.id.slice(0,8)}`);
    }
  }

  log(`Участников в комнате: ${others.length + 1} (включая вас)`);
}

// ===== События
bind(els.btnConnect, 'click', connect);
bind(els.btnLeave, 'click', leave);
bind(els.btnCopyLink, 'click', copyLink);
bind(els.btnForceConnect, 'click', forceReconnectAll);
bind(els.btnDiagnose, 'click', diagnoseAudio);
bind(els.btnSend, 'click', send);
bind(els.btnToggleMic, 'click', toggleMic);
bind(els.btnToggleCam, 'click', toggleCam);
bind(els.btnToggleTheme, 'click', toggleTheme);

bind(els.chatInput, 'keypress', (e) => { if (e.key === 'Enter') send(); });

window.addEventListener('beforeunload', ()=>{ try{ if (isWsOpen(ws)) ws.close(); }catch{} });

// Init
restoreFromUrl();
if (ensureToken()) {
  log('Готово. Введите Room ID и нажмите Подключиться.');
  refreshDevices().catch(()=>{});
}

// Глобальная активация аудио при загрузке страницы
(() => {
  // Активируем аудио контекст на первом пользовательском взаимодействии
  const activateAudio = async () => {
    try {
      const ac = new AudioContext();
      if (ac.state === 'suspended') await ac.resume();
      
      // Создаем короткий беззвучный сигнал
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      gain.gain.value = 0.001;
      osc.connect(gain).connect(ac.destination);
      osc.start();
      osc.stop(ac.currentTime + 0.05);
      
      console.log('🎧 Аудио контекст активирован глобально');
      setTimeout(() => { try { ac.close(); } catch {} }, 200);
    } catch (e) {
      console.warn('Не удалось активировать аудио:', e);
    }
  };

  // Активируем на любое взаимодействие
  ['click', 'keydown', 'touchstart'].forEach(event => {
    document.addEventListener(event, activateAudio, { once: true });
  });

  // Попробуем активировать сразу (на случай если браузер позволяет)
  setTimeout(activateAudio, 100);
})();
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\signal.js ---
// signal.js — WebSocket helpers
function isWsOpen(ws) {
  return ws && ws.readyState === WebSocket.OPEN;
}

function _safeSend(ws, obj, maxRetries = 3) {
  if (!isWsOpen(ws)) {
    if (maxRetries > 0) setTimeout(() => _safeSend(ws, obj, maxRetries - 1), 300);
    return false;
  }
  try {
    ws.send(JSON.stringify(obj));
    return true;
  } catch (e) {
    console.warn("WS send failed:", e);
    if (maxRetries > 0) setTimeout(() => _safeSend(ws, obj, maxRetries - 1), 300);
    return false;
  }
}

/**
 * @param {WebSocket} ws
 * @param {"offer"|"answer"|"ice-candidate"} type
 * @param {object} payload - { sdp } или { candidate }
 * @param {string} fromUserId
 * @param {string=} targetUserId
 */
export function sendSignal(ws, type, payload, fromUserId, targetUserId) {
  const body = { type: "signal", signalType: type, fromUserId, ...payload };
  if (targetUserId) body.targetUserId = targetUserId;
  _safeSend(ws, body);
}

export function sendChat(ws, content, fromUserId) {
  _safeSend(ws, { type: "chat", content, fromUserId });
}

export { isWsOpen };
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\ui.js ---
// ui.js - UI helpers
export function bind(el, event, fn){ el?.addEventListener(event, fn); }
export function setText(el, text){ if (el) el.textContent = text; }
export function setEnabled(el, enabled){ if (el) el.disabled = !enabled; }

export function appendLog(container, msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  container.appendChild(node);
  container.scrollTop = container.scrollHeight;
}

export function appendChat(container, who, text){
  const line = document.createElement('div');
  line.innerHTML = `<strong>${who}:</strong> ${escapeHtml(text)}`;
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc.js ---
// webrtc.js — мультипир WebRTC с Perfect Negotiation, аккуратным ICE и подробными логами
import { sendSignal } from "./signal.js";
import { getIceServers } from "./api.js";

/**
 * Опции:
 * - localVideo: HTMLVideoElement|null
 * - outputDeviceId?: string|null
 * - onLog?: (msg)=>void
 * - onPeerState?: (peerId, key, value)=>void
 */
export class WebRTCManager {
  constructor(opts){
    this.localVideo = opts.localVideo || null;
    this.outputDeviceId = opts.outputDeviceId || null;
    this.onLog = opts.onLog || (()=>{});
    this.onPeerState = opts.onPeerState || (()=>{});

    this.ws = null;
    this.userId = null;
    this.localStream = null;
    this.preferred = { micId: undefined, camId: undefined };
    this.iceConfig = null;
  this.audioCtx = null; // Глобальный аудио контекст для вывода звука

  // peerId -> { pc, stream, candidates:[], remoteSet, handlers, level:{analyser,raf,gain,volume,muted},
    //             makingOffer, ignoreOffer, polite, iceFailTimer }
    this.peers = new Map();
  }

  _log(m){ try{ this.onLog(m); }catch{} }
  getOutputDeviceId(){ return this.outputDeviceId; }
  setPreferredDevices({ mic, cam, spk }){
    if (mic) this.preferred.micId = mic;
    if (cam) this.preferred.camId = cam;
    if (spk) this.outputDeviceId = spk;
  }

  async _getLocalMedia(){
    const baseAudio = {
      echoCancellation: true, noiseSuppression: true, autoGainControl: true,
      deviceId: this.preferred.micId ? { exact: this.preferred.micId } : undefined,
    };
    try {
      this._log('Запрашиваем локальный медиапоток: audio=true, video=false');
      return await navigator.mediaDevices.getUserMedia({ audio: baseAudio, video: false });
    } catch(e) {
      this._log(`getUserMedia audio failed: ${e?.name||e}`);
      return null;
    }
  }

  async init(ws, userId, { micId, camId } = {}){
    this.ws = ws;
    this.userId = userId;
    if (micId) this.preferred.micId = micId;
    if (camId) this.preferred.camId = camId;

    if (!this.iceConfig) {
      try { this.iceConfig = await getIceServers(); }
      catch { this.iceConfig = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] }; }
    }

    if (this.localStream) return;

    const stream = await this._getLocalMedia();
    this.localStream = stream;
    if (stream && this.localVideo) this.localVideo.srcObject = stream;
    this._log(`WebRTC инициализирован. Аудио: ${this.localStream ? 'есть' : 'нет'}`);
  }

  _isPolite(myId, peerId){
    // polite — у кого строковый id больше; инициатор оффера — у кого меньше
    return String(myId) > String(peerId);
  }

  async _ensurePeer(peerId){
    if (this.peers.has(peerId)) return this.peers.get(peerId);

    const pc = new RTCPeerConnection({ ...this.iceConfig, bundlePolicy:"max-bundle", rtcpMuxPolicy:"require" });
    const state = {
      pc,
      stream: new MediaStream(),
      candidates: [],
      remoteSet: false,
      handlers: null,
  level: { analyser:null, raf:0, gain:null, volume:1, muted:false },
      makingOffer: false,
      ignoreOffer: false,
      polite: this._isPolite(this.userId, peerId),
      iceFailTimer: null,
    };

    // **Важно**: Добавляем треки только один раз и правильно
    if (this.localStream && this.localStream.getTracks().length > 0){
      // Добавляем каждый трек только один раз
      for (const track of this.localStream.getTracks()) {
        try { 
          pc.addTrack(track, this.localStream); 
          this._log(`✅ Добавлен ${track.kind} трек для ${peerId.slice(0,8)}`); 
        }
        catch(e){ 
          this._log(`❌ addTrack(${track.kind}) error → ${peerId.slice(0,8)}: ${e}`); 
        }
      }
    } else {
      // Если нет локального потока, создаем только recvonly transceivers
      try{ 
        pc.addTransceiver("audio", { direction:"recvonly" }); 
        this._log(`Добавлен recvonly audio transceiver для ${peerId.slice(0,8)}`);
      }catch(e){
        this._log(`❌ addTransceiver(audio) error → ${peerId.slice(0,8)}: ${e}`); 
      }
    }

    pc.addEventListener("icecandidate", (e)=>{
      if (e.candidate) sendSignal(this.ws, "ice-candidate", { candidate: e.candidate }, this.userId, peerId);
    });

    pc.addEventListener("track", (e)=>{
      this._log(`Получен трек от ${peerId.slice(0,8)}: ${e.track.kind} (enabled:${e.track.enabled})`);
      if (e.track && !state.stream.getTracks().some(t=>t.id===e.track.id)) state.stream.addTrack(e.track);
      if (state.handlers?.onTrack) state.handlers.onTrack(state.stream);
  if (e.track?.kind === 'audio') this._setupPeerLevel(peerId, state);
    });

    pc.addEventListener("negotiationneeded", async ()=>{
      // В Perfect Negotiation оффер может делать и «вежливый», но мы защищаемся makingOffer
      try{
        if (state.makingOffer) return;
        state.makingOffer = true;
        const offer = await pc.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
        await pc.setLocalDescription(offer);
        sendSignal(this.ws, 'offer', { sdp: offer.sdp }, this.userId, peerId);
        this._log(`📤 Sent offer → ${peerId.slice(0,8)} (negotiationneeded)`);
      }catch(e){ this._log(`negotiationneeded(${peerId.slice(0,8)}): ${e?.name||e}`); }
      finally{ state.makingOffer = false; }
    });

    pc.addEventListener("connectionstatechange", ()=>{
      const s = pc.connectionState;
      this.onPeerState(peerId, 'net', s);
      this._log(`PC(${peerId.slice(0,8)}) = ${s}`);
      if (s === 'failed'){
        this._iceRestart(peerId).catch(()=>{});
      } else if (s === 'disconnected'){
        clearTimeout(state.iceFailTimer);
        state.iceFailTimer = setTimeout(()=>{
          if (pc.connectionState === 'disconnected') this._iceRestart(peerId).catch(()=>{});
        }, 2000);
      } else if (s === 'connected' || s === 'completed'){
        clearTimeout(state.iceFailTimer);
        state.iceFailTimer = null;
      }
    });

    pc.addEventListener("iceconnectionstatechange", ()=>{ this._log(`ICE(${peerId.slice(0,8)}) = ${pc.iceConnectionState}`); });

    this.peers.set(peerId, state);
    return state;
  }

  async _iceRestart(peerId){
    const st = this.peers.get(peerId);
    if (!st) return;
    this._log(`ICE-restart → ${peerId.slice(0,8)}`);
    try{
      const offer = await st.pc.createOffer({ iceRestart:true });
      await st.pc.setLocalDescription(offer);
      sendSignal(this.ws, 'offer', { sdp: offer.sdp }, this.userId, peerId);
    }catch(e){ this._log(`ICE-restart(${peerId.slice(0,8)}): ${e?.name||e}`); }
  }

  // публичные хуки UI
  bindPeerMedia(peerId, handlers){
    const st = this.peers.get(peerId);
    if (!st) return;
    st.handlers = handlers;
    // Если треки уже пришли до установки обработчиков — сразу передадим текущий stream в UI
    try{
      if (st.stream && st.stream.getTracks && st.stream.getTracks().length > 0) {
        handlers?.onTrack?.(st.stream);
      }
      // Если уже настроен аудио-пайплайн — отдадим контролы
      if (st.level?.gain && handlers?.onControl) {
        handlers.onControl(this._makeControlForPeer(st));
      }
    }catch{}
  }
  getPeer(peerId){ return this.peers.get(peerId); }

  // Диагностика состояния аудио/SDP/статов
  async diagnoseAudio(){
    this._log('=== 🔊 АУДИО ДИАГНОСТИКА ===');
    
    // Проверяем глобальный аудио контекст
    try {
      const ac = new AudioContext();
      this._log(`🎧 AudioContext state: ${ac.state}`);
      if (ac.state === 'suspended') {
        await ac.resume();
        this._log(`🎧 AudioContext resumed to: ${ac.state}`);
      }
      setTimeout(() => { try { ac.close(); } catch {} }, 100);
    } catch(e) {
      this._log(`❌ AudioContext error: ${e}`);
    }
    
    if (this.localStream) {
      const audioTracks = this.localStream.getAudioTracks();
      this._log(`📱 Локальный поток: ${audioTracks.length} аудио треков`);
      audioTracks.forEach((t,i)=> this._log(`🎤 Трек ${i}: enabled=${t.enabled}, readyState=${t.readyState}, muted=${t.muted}`));
    } else {
      this._log('❌ НЕТ локального потока!');
    }
    this._log(`🔗 Активных соединений: ${this.peers.size}`);

    for (const [peerId, st] of this.peers){
      const pc = st.pc;
      this._log(`--- Peer ${peerId.slice(0,8)} ---`);
      this._log(`📊 Состояние: ${pc.connectionState}`);
      this._log(`🧊 ICE: ${pc.iceConnectionState}`);
      this._log(`� Signaling: ${pc.signalingState}`);

      const senders = pc.getSenders(); 
      const receivers = pc.getReceivers();
      this._log(`📤 Отправляем треков: ${senders.length}`);
      senders.forEach((s,i)=> {
        if (s.track) {
          this._log(`Sender ${i}: ${s.track.kind}, enabled=${s.track.enabled}, readyState=${s.track.readyState}`);
        } else {
          this._log(`Sender ${i}: ❌ НЕТ ТРЕКА`);
        }
      });
      
      this._log(`📥 Получаем треков: ${receivers.length}`);
      receivers.forEach((r,i)=> {
        if (r.track) {
          this._log(`Receiver ${i}: ${r.track.kind}, enabled=${r.track.enabled}, readyState=${r.track.readyState}`);
        } else {
          this._log(`Receiver ${i}: ❌ НЕТ ТРЕКА`);
        }
      });
      
      const tracks = st.stream.getTracks();
      this._log(`🌊 В потоке треков: ${tracks.length}`);
      tracks.forEach((t,i)=> this._log(`Stream трек ${i}: ${t.kind}, enabled=${t.enabled}, readyState=${t.readyState}, muted=${t.muted}`));

      if (pc.connectionState === 'connected') {
        try{
          const stats = await pc.getStats();
          let inA=0,outA=0;
          stats.forEach(r=>{
            if (r.type==='inbound-rtp' && r.kind==='audio') inA++;
            if (r.type==='outbound-rtp' && r.kind==='audio') outA++;
          });
          this._log(`📈 Stats - Inbound audio: ${inA}, Outbound audio: ${outA}`);
        }catch(e){ this._log(`📈 Stats error: ${e}`); }
      }
    }
    this._log('=== КОНЕЦ ДИАГНОСТИКИ ===');
  }

  async handleSignal(msg, mediaBinder){
    if (msg?.fromUserId && this.userId && msg.fromUserId === this.userId) return;
    if (msg?.targetUserId && this.userId && msg.targetUserId !== this.userId) return;

    const peerId = msg.fromUserId;
    if (!peerId) return;

    if (!this.localStream) { this._log('КРИТИЧНО: Нет локального потока при обработке сигнала!'); return; }

    const peer = await this._ensurePeer(peerId);
    const pc = peer.pc;

    if (mediaBinder && !peer.handlers){
      mediaBinder(peerId, { onTrack: ()=>{}, onLevel: ()=>{} });
    }

    if (msg.signalType === 'offer'){
      const desc = { type:'offer', sdp: msg.sdp };
      const offerCollision = peer.makingOffer || pc.signalingState !== "stable";
      peer.ignoreOffer = !peer.polite && offerCollision;
      if (peer.ignoreOffer) { this._log(`⏭️ Ignore offer from ${peerId.slice(0,8)} (impolite collision)`); return; }

      try{
        if (offerCollision) await pc.setLocalDescription({ type:'rollback' });
        await pc.setRemoteDescription(desc);
        peer.remoteSet = true;
        await this._flushQueuedCandidates(peerId);

        const answer = await pc.createAnswer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
        await pc.setLocalDescription(answer);
        sendSignal(this.ws, 'answer', { sdp: answer.sdp }, this.userId, peerId);
        this._log(`📤 Answered offer from ${peerId.slice(0,8)}`);
      }catch(e){ this._log(`SRD(offer)[${peerId.slice(0,8)}]: ${e?.name||e}`); }

    } else if (msg.signalType === 'answer'){
      if (pc.signalingState !== 'have-local-offer'){ this._log(`Ignore answer in ${pc.signalingState}`); return; }
      try{
        await pc.setRemoteDescription({ type:'answer', sdp: msg.sdp });
        peer.remoteSet = true;
        await this._flushQueuedCandidates(peerId);
        this._log(`Processed answer from ${peerId.slice(0,8)}`);
      }catch(e){ this._log(`SRD(answer)[${peerId.slice(0,8)}]: ${e?.name||e}`); }

    } else if (msg.signalType === 'ice-candidate'){
      if (!peer.remoteSet) peer.candidates.push(msg.candidate);
      else {
        try { await pc.addIceCandidate(msg.candidate); }
        catch(e){ this._log(`addIce[${peerId.slice(0,8)}]: ${e?.name||e}`); }
      }
    }
  }

  async _flushQueuedCandidates(peerId){
    const peer = this.peers.get(peerId);
    if (!peer?.pc) return;
    while (peer.candidates.length){
      const c = peer.candidates.shift();
      try { await peer.pc.addIceCandidate(c); }
      catch(e){ this._log(`flush ICE[${peerId.slice(0,8)}]: ${e?.name||e}`); }
    }
  }

  async startOffer(peerId){
    if (!this.localStream) { this._log('КРИТИЧНО: Нет локального потока для startOffer!'); return; }
    const st = await this._ensurePeer(peerId);
    if (st.makingOffer) return;
    if (st.pc.signalingState !== 'stable'){ this._log(`Skip startOffer(${peerId.slice(0,8)}) in ${st.pc.signalingState}`); return; }
    try{
      st.makingOffer = true;
      const offer = await st.pc.createOffer({ offerToReceiveAudio:true, offerToReceiveVideo:true });
      await st.pc.setLocalDescription(offer);
      sendSignal(this.ws, 'offer', { sdp: offer.sdp }, this.userId, peerId);
      this._log(`📤 Sent offer → ${peerId.slice(0,8)} (startOffer)`);
    }catch(e){ this._log(`startOffer(${peerId.slice(0,8)}): ${e?.name||e}`); }
    finally{ st.makingOffer = false; }
  }

  toggleMic(){
    if (!this.localStream) { this._log('Нет локального потока для микрофона'); return false; }
    const tr = this.localStream.getAudioTracks()[0];
    if (!tr) { this._log('Нет аудио трека для переключения'); return false; }
    tr.enabled = !tr.enabled;
    this._log(`Микрофон ${tr.enabled ? 'включён' : 'выключен'}`);
    return tr.enabled;
  }

  async toggleCam(){
    if (!this.localStream) { this._log('Нет локального потока для камеры'); return false; }
    let tr = this.localStream.getVideoTracks()[0];
    if (!tr){
      try{
        const vs = await navigator.mediaDevices.getUserMedia({
          video: this.preferred.camId ? { deviceId: { exact: this.preferred.camId } } : true,
          audio: false
        });
        const [vt] = vs.getVideoTracks();
        if (!vt) return false;
        this.localStream.addTrack(vt);
        if (this.localVideo){ this.localVideo.srcObject = this.localStream; }
        // negotiationneeded сработает сам
        this._log('Камера включена');
        return true;
      }catch(e){ this._log(`Camera init: ${e?.name||e}`); return false; }
    }
    tr.enabled = !tr.enabled;
    this._log(`Камера ${tr.enabled ? 'включена' : 'выключена'}`);
    return tr.enabled;
  }

  async close(){
    try{ this.ws?.close(); }catch{}
    for (const [, st] of this.peers){
      try{ st.pc?.close(); }catch{}
      if (st.level?.raf) cancelAnimationFrame(st.level.raf);
      clearTimeout(st.iceFailTimer);
    }
    this.peers.clear();
    if (this.localStream) this.localStream.getTracks().forEach(t=>t.stop());
    this.localStream = null;
  try{ await this.audioCtx?.close(); }catch{}
  this.audioCtx = null;
    this._log('WebRTC соединения закрыты');
  }

  _setupPeerLevel(peerId, state){
    try{
      if (!window.AudioContext || !state.stream?.getAudioTracks().length) return;
      if (state.level.raf) cancelAnimationFrame(state.level.raf);
      if (!this.audioCtx) this.audioCtx = new AudioContext();
      try { this.audioCtx.resume(); } catch {}
      const src = this.audioCtx.createMediaStreamSource(state.stream);
      state.level.analyser = this.audioCtx.createAnalyser();
      state.level.analyser.fftSize = 256;
      state.level.gain = this.audioCtx.createGain();
      state.level.volume = 1;
      state.level.muted = false;
      // Параллель: в анализатор и в выход с контролем громкости
      src.connect(state.level.analyser);
      src.connect(state.level.gain);
      try { state.level.gain.connect(this.audioCtx.destination); } catch {}
      const data = new Uint8Array(state.level.analyser.frequencyBinCount);
      const loop = ()=>{
        if (!state.level.analyser) return;
        state.level.analyser.getByteTimeDomainData(data);
        let sum=0; for (let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
        const rms = Math.sqrt(sum/data.length);
        if (state.handlers?.onLevel) state.handlers.onLevel(rms);
        state.level.raf = requestAnimationFrame(loop);
      };
      state.level.raf = requestAnimationFrame(loop);
      // Сообщим UI про контролы громкости/мьюта
      if (state.handlers?.onControl) {
        try { state.handlers.onControl(this._makeControlForPeer(state)); } catch {}
      }
      this._log(`Настроен аудио анализатор для ${peerId.slice(0,8)}`);
    }catch(e){ this._log(`level[${peerId.slice(0,8)}]: ${e?.name||e}`); }
  }

  _makeControlForPeer(state){
    const apply = ()=>{
      if (!state.level?.gain) return;
      const vol = Math.max(0, Math.min(1, state.level.volume ?? 1));
      state.level.gain.gain.value = state.level.muted ? 0 : vol;
    };
    // Инициализация
    apply();
    return {
      setVolume: (v)=>{ state.level.volume = isFinite(v) ? Math.max(0, Math.min(1, v)) : 1; apply(); },
      setMuted: (m)=>{ state.level.muted = !!m; apply(); },
      getVolume: ()=> state.level?.gain?.gain?.value ?? 1,
      getMuted: ()=> !!state.level?.muted,
    };
  }
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\rooms.py ---
from __future__ import annotations

import asyncio
import json
from typing import Any
from collections import defaultdict
import contextlib
from uuid import UUID, uuid5, NAMESPACE_URL

from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect
from ...infrastructure.config import get_settings

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus, TokenProvider
from ...core.ports.repositories import UserRepository
from ..api.deps.containers import get_signal_bus, get_token_provider, get_user_repo
from ...infrastructure.messaging.redis_bus import RedisSignalBus  # for type-check to enable Redis chat broadcast

router = APIRouter()

# In-process registry of room connections for chat broadcast (dev/test)
_room_clients: dict[UUID, set[WebSocket]] = defaultdict(set)
_ws_user: dict[WebSocket, UUID] = {}
_room_members: dict[UUID, set[UUID]] = defaultdict(set)
_user_names: dict[UUID, str] = {}


@router.websocket("/ws/rooms/{room_id}")
async def ws_room(
    websocket: WebSocket,
    room_id: str,
    bus: SignalBus = Depends(get_signal_bus),
    tokens: TokenProvider = Depends(get_token_provider),
    users: UserRepository = Depends(get_user_repo),
):  # type: ignore[override]
    settings = get_settings()
    token = websocket.query_params.get("token")
    allow_unauth = settings.APP_ENV in {"dev", "test"}
    # Принимаем соединение сразу, чтобы при ошибке аутентификации клиент получил корректный close frame,
    # иначе браузер покажет 1006 (abnormal closure)
    await websocket.accept()
    if token:
        try:
            tokens.decode_token(token)
        except Exception:
            if not allow_unauth:
                await websocket.close(code=4401, reason="Unauthorized")
                return
    else:
        if not allow_unauth:
            await websocket.close(code=4401, reason="Unauthorized")
            return
    # Поддержка человекочитаемых room_id: если не UUID, маппим в стабильный UUID v5
    try:
        room_uuid = UUID(room_id)
    except Exception:
        room_uuid = uuid5(NAMESPACE_URL, f"webcall:{room_id}")

    async def sender():
        async for signal in bus.subscribe(room_uuid):
            await websocket.send_json(
                {
                    "type": "signal",
                    "fromUserId": str(signal.sender_id),
                    "signalType": signal.type.value,
                    "sdp": signal.sdp,
                    "candidate": signal.candidate,
                    # передаём target для клиентской фильтрации (если задан)
                    "targetUserId": str(signal.target_id) if getattr(signal, "target_id", None) else None,
                }
            )

    send_task = asyncio.create_task(sender())
    # If Redis is used, also subscribe to chat channel to receive messages from other processes
    chat_task: asyncio.Task | None = None
    chat_channel = f"room:{room_uuid}:chat"
    if isinstance(bus, RedisSignalBus):
        async def chat_listener() -> None:
            pubsub = bus.redis.pubsub()
            await pubsub.subscribe(chat_channel)
            try:
                async for msg in pubsub.listen():
                    if msg.get("type") != "message":
                        continue
                    try:
                        data = json.loads(msg["data"])  # type: ignore[arg-type]
                    except Exception:
                        continue
                    await websocket.send_json({
                        "type": "chat",
                        "authorId": data.get("authorId"),
                        "authorName": data.get("authorName"),
                        "content": data.get("content")
                    })
            finally:
                with contextlib.suppress(Exception):
                    await pubsub.unsubscribe(chat_channel)
                    await pubsub.close()

        chat_task = asyncio.create_task(chat_listener())
    # register connection in room for chat broadcast
    _room_clients[room_uuid].add(websocket)

    try:
        while True:
            msg = await websocket.receive_text()
            data: dict[str, Any] = json.loads(msg)
            if data.get("type") == "signal":
                s = Signal.create(
                    type=data.get("signalType"),
                    sender_id=UUID(data.get("fromUserId")),
                    room_id=room_uuid,
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["targetUserId"]) if data.get("targetUserId") else None,
                )
                await bus.publish(room_uuid, s)
            elif data.get("type") == "join":
                # Register user presence
                try:
                    uid = UUID(data.get("fromUserId"))
                except Exception:
                    # if invalid id, skip presence for this socket
                    continue
                _ws_user[websocket] = uid
                _room_members[room_uuid].add(uid)
                # try resolve username (optional)
                try:
                    u = await users.get_by_id(uid)
                    if u:
                        _user_names[uid] = u.username
                except Exception:
                    # fallback leave name unset; will be derived from uuid
                    pass
                # broadcast presence list to room
                members = []
                for u in sorted(_room_members[room_uuid], key=str):
                    name = _user_names.get(u) or str(u)[:8]
                    members.append({"id": str(u), "name": name})
                for ws in list(_room_clients.get(room_uuid, set())):
                    with contextlib.suppress(Exception):
                        await ws.send_json({"type": "presence", "members": members})
            elif data.get("type") == "leave":
                break
            elif data.get("type") == "chat":
                # Broadcast chat to all participants in room (including sender)
                content = data.get("content")
                author = data.get("fromUserId")
                author_name: str | None = None
                # Попробуем получить имя пользователя по его UUID, если он передан
                try:
                    if author:
                        u = await users.get_by_id(UUID(author))
                        if u:
                            author_name = u.username
                except Exception:
                    # Не прерываем чат при ошибке, просто не заполним имя
                    pass
                if isinstance(bus, RedisSignalBus):
                    # Publish to Redis channel so all processes deliver the message
                    await bus.redis.publish(chat_channel, json.dumps({
                        "authorId": author,
                        "authorName": author_name,
                        "content": content
                    }))
                else:
                    # In-process fallback (dev/test)
                    payload = {"type": "chat", "authorId": author, "authorName": author_name, "content": content}
                    # Backward compat for older UIs relying on 'echo'
                    payload_with_echo = {**payload, "echo": content}
                    dead: list[WebSocket] = []
                    for ws in list(_room_clients.get(room_uuid, set())):
                        try:
                            await ws.send_json(payload_with_echo)
                        except Exception:
                            dead.append(ws)
                    # cleanup dead connections
                    for ws in dead:
                        with contextlib.suppress(KeyError):
                            _room_clients[room_uuid].remove(ws)
            else:
                await websocket.send_json({"type": "error", "message": "Unknown message"})
    except WebSocketDisconnect:
        pass
    finally:
        send_task.cancel()
        if chat_task:
            chat_task.cancel()
        # В Python 3.11 CancelledError наследуется от BaseException — подавляем явно
        with contextlib.suppress(asyncio.CancelledError):
            await send_task
        if chat_task:
            with contextlib.suppress(asyncio.CancelledError):
                await chat_task
        # unregister connection
        with contextlib.suppress(KeyError):
            _room_clients[room_uuid].remove(websocket)
        # presence cleanup and broadcast
        uid = _ws_user.pop(websocket, None)
        if uid is not None:
            with contextlib.suppress(KeyError):
                _room_members[room_uuid].remove(uid)
            # cleanup username mapping if user no longer present in any room instance
            if uid not in _room_members.get(room_uuid, set()):
                with contextlib.suppress(KeyError):
                    _user_names.pop(uid)
            members = []
            for u in sorted(_room_members[room_uuid], key=str):
                name = _user_names.get(u) or str(u)[:8]
                members.append({"id": str(u), "name": name})
            for ws in list(_room_clients.get(room_uuid, set())):
                with contextlib.suppress(Exception):
                    await ws.send_json({"type": "presence", "members": members})
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\create_superuser.py ---
import asyncio
from uuid import UUID

from app.infrastructure.db.session import AsyncSessionLocal
from app.infrastructure.db.repositories.users import PgUserRepository
from app.infrastructure.security.password_hasher import BcryptPasswordHasher


async def main():
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        users = PgUserRepository(session)
        hasher = BcryptPasswordHasher()
        # minimal example: ensure user exists
        from app.core.domain.models import User

        u = User.create("admin@example.com", "admin", hasher.hash("admin"))
        await users.add(u)
        print("Created:", u.id)


if __name__ == "__main__":
    asyncio.run(main())
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\wait_for_db.py ---
# app/scripts/wait_for_db.py
from __future__ import annotations

import asyncio
import os
import sys

import asyncpg


def _to_asyncpg_dsn(url: str) -> str:
    """
    Convert SQLAlchemy async URL (postgresql+asyncpg://...) to asyncpg-compatible DSN.
    """
    if url.startswith("postgresql+asyncpg://"):
        return "postgresql://" + url[len("postgresql+asyncpg://") :]
    return url


async def main() -> None:
    # Берём URL из окружения (как в .env). Фолбэк — только для локалки.
    env_url = os.getenv(
        "DATABASE_URL",
        "postgresql+asyncpg://webcall:secret@postgres:5432/webcall",
    )
    dsn = _to_asyncpg_dsn(env_url)

    # Подождём до 60 сек, печатая причину (чтобы было видно в логах почему ждём)
    last_err: Exception | None = None
    for attempt in range(60):
        try:
            conn = await asyncpg.connect(dsn)
            await conn.close()
            print("db ready")
            return
        except Exception as e:
            last_err = e
            print(f"[wait_for_db] attempt {attempt+1}/60: {e!r}")
            await asyncio.sleep(1)

    print("[wait_for_db] database is not ready, aborting", file=sys.stderr)
    if last_err:
        print(f"[wait_for_db] last error: {last_err!r}", file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\conftest.py ---
import asyncio
import os
import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.fixture(scope="session")
def anyio_backend():
    return 'asyncio'


@pytest.fixture()
async def client():
    # httpx>=0.27: pass ASGITransport instead of deprecated app= argument
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_auth.py ---
import pytest


@pytest.mark.asyncio
async def test_dummy_auth():
    assert True
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_rooms.py ---
import pytest


@pytest.mark.asyncio
async def test_dummy_rooms():
    assert True
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_ws_basic.py ---
import asyncio
import json

import pytest
from starlette.testclient import TestClient

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_ws_basic():
    client = TestClient(app)
    with client.websocket_connect("/ws/rooms/00000000-0000-0000-0000-000000000001") as ws:
        ws.send_json({"type": "chat", "content": "hi"})
        msg = ws.receive_json()
        assert msg["type"] == "chat"
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.Dockerfile ---
# syntax=docker/dockerfile:1
FROM python:3.11-slim AS base

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=on \
    PYTHONPATH=/app

WORKDIR /app

# System deps
RUN apt-get update && apt-get install -y --no-install-recommends build-essential libpq-dev curl && rm -rf /var/lib/apt/lists/*

# Install Poetry
ENV POETRY_HOME=/opt/poetry \
    POETRY_VERSION=1.8.3
ENV PATH="$POETRY_HOME/bin:$PATH"
RUN curl -sSL https://install.python-poetry.org | python3 - && poetry --version

# Copy project files
COPY pyproject.toml README.md ./
RUN poetry config virtualenvs.create false \
    && poetry install --no-interaction --no-ansi --with dev

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.bootstrap.asgi:app", "--host", "0.0.0.0", "--port", "8000"]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_health.py ---
import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_healthz():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
        r = await client.get("/healthz")
        assert r.status_code == 200
        assert r.json() == {"status": "ok"}

=== Dump finished: 05.09.2025 20:09:10,37
