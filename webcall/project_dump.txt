=== Dump started: 05.09.2025 17:22:26,39
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   README.md
|   |   
|   \---v
|       \---cache
|               lastfailed
|               nodeids
|               
+---alembic
|   |   env.py
|   |   
|   \---versions
|           0001_init.py
|           
+---app
|   |   __init__.py
|   |   
|   +---application
|   |   |   __init__.py
|   |   |   
|   |   +---dto
|   |   |       auth.py
|   |   |       messages.py
|   |   |       rooms.py
|   |   |       __init__.py
|   |   |       
|   |   \---use_cases
|   |           auth.py
|   |           messages.py
|   |           participants.py
|   |           rooms.py
|   |           signals.py
|   |           __init__.py
|   |           
|   +---bootstrap
|   |       asgi.py
|   |       main.py
|   |       __init__.py
|   |       
|   +---core
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---domain
|   |   |       models.py
|   |   |       values.py
|   |   |       __init__.py
|   |   |       
|   |   +---ports
|   |   |       repositories.py
|   |   |       services.py
|   |   |       __init__.py
|   |   |       
|   |   \---services
|   |           room_service.py
|   |           __init__.py
|   |           
|   +---infrastructure
|   |   |   config.py
|   |   |   logging.py
|   |   |   __init__.py
|   |   |   
|   |   +---db
|   |   |   |   base.py
|   |   |   |   models.py
|   |   |   |   session.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---repositories
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           users.py
|   |   |           __init__.py
|   |   |           
|   |   +---ice
|   |   |       provider.py
|   |   |       __init__.py
|   |   |       
|   |   +---messaging
|   |   |       inmemory_bus.py
|   |   |       redis_bus.py
|   |   |       __init__.py
|   |   |       
|   |   \---security
|   |           jwt_provider.py
|   |           password_hasher.py
|   |           __init__.py
|   |           
|   +---presentation
|   |   |   docs.py
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---api
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---deps
|   |   |   |       auth.py
|   |   |   |       containers.py
|   |   |   |       db.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---routers
|   |   |           auth.py
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           webrtc.py
|   |   |           __init__.py
|   |   |           
|   |   +---schemas
|   |   |       api.py
|   |   |       
|   |   +---static
|   |   |   |   app.js
|   |   |   |   auth.html
|   |   |   |   index.html
|   |   |   |   styles.css
|   |   |   |   
|   |   |   \---js
|   |   |           api.js
|   |   |           auth.js
|   |   |           main.js
|   |   |           signal.js
|   |   |           ui.js
|   |   |           webrtc.js
|   |   |           
|   |   \---ws
|   |           rooms.py
|   |           
|   +---scripts
|   |       create_superuser.py
|   |       wait_for_db.py
|   |       
|   \---tests
|           conftest.py
|           test_auth.py
|           test_rooms.py
|           test_ws_basic.py
|           
+---docker
|       api.Dockerfile
|       
\---tests
        test_health.py
        

=== FILE CONTENTS =======================================

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env.example ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore ---
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.venv/
.poetry/
.mypy_cache/
.pytest_cache/
.coverage
htmlcov/
.cache/

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini ---
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml ---
services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000"         # для локальной проверки, Nginx ходит на 127.0.0.1:8000
    depends_on:
      - postgres
      - redis
      - coturn
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000"]
    volumes:
      - ./:/app

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: Mousa     # ← совпадает с .env
      POSTGRES_DB: webcall
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    command:
      - -n
      - --log-file=stdout
      - --min-port=49152
      - --max-port=49200
      - --realm=turn.bandjshoos.ru
      - --listening-ip=0.0.0.0
      - --relay-ip=0.0.0.0
      - --listening-port=3478
      - --external-ip=104.238.24.120          # ← публичный IP твоего VPS
      - --lt-cred-mech
      - --user=webcall:Mousa   # ← совпадает с .env
      - --fingerprint
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49200:49152-49200/udp"

volumes:
  pgdata:
  redisdata:

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\dump.bat ---
@echo off
chcp 65001 >nul
setlocal EnableDelayedExpansion

:: Игнорируемые папки
set "SKIP_DIRS=\venv\;.git\;__pycache__\;.mypy_cache\;.idea\;.vscode\;node_modules\;.pytest_cache\"

:: Игнорируемые файлы
set "SKIP_FILES=CACHEDIR.TAG"

set "OUT=project_dump.txt"

(
  echo === Dump started: %date% %time%
  echo Root: %cd%
  echo.
  echo === DIRECTORY TREE =======================================
  tree /F /A
  echo.
  echo === FILE CONTENTS =======================================
) > "%OUT%"

:: Обход файлов
for /R %%F in (*) do (
    set "FILE=%%~fF"
    call :ShouldSkip "%%F"
    if errorlevel 1 (
        REM skip
    ) else (
        >>"%OUT%" echo.
        >>"%OUT%" echo --- %%F ---
        >>"%OUT%" type "%%F"
    )
)

>>"%OUT%" echo.
>>"%OUT%" echo === Dump finished: %date% %time%

echo Структура и содержимое файлов сохранены в %OUT%
exit /b


:ShouldSkip
setlocal
set "FN=%~1"

:: Проверяем папки
for %%D in (%SKIP_DIRS%) do (
    echo "%FN%" | findstr /I "%%D" >nul && (exit /b 1)
)

:: Проверяем файлы
for %%X in (%SKIP_FILES%) do (
    if /I "%~nx1"=="%%X" exit /b 1
)

exit /b 0

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile ---
.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\project_dump.txt ---
=== Dump started: 05.09.2025 17:22:26,39
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   README.md
|   |   
|   \---v
|       \---cache
|               lastfailed
|               nodeids
|               
+---alembic
|   |   env.py
|   |   
|   \---versions
|           0001_init.py
|           
+---app
|   |   __init__.py
|   |   
|   +---application
|   |   |   __init__.py
|   |   |   
|   |   +---dto
|   |   |       auth.py
|   |   |       messages.py
|   |   |       rooms.py
|   |   |       __init__.py
|   |   |       
|   |   \---use_cases
|   |           auth.py
|   |           messages.py
|   |           participants.py
|   |           rooms.py
|   |           signals.py
|   |           __init__.py
|   |           
|   +---bootstrap
|   |       asgi.py
|   |       main.py
|   |       __init__.py
|   |       
|   +---core
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---domain
|   |   |       models.py
|   |   |       values.py
|   |   |       __init__.py
|   |   |       
|   |   +---ports
|   |   |       repositories.py
|   |   |       services.py
|   |   |       __init__.py
|   |   |       
|   |   \---services
|   |           room_service.py
|   |           __init__.py
|   |           
|   +---infrastructure
|   |   |   config.py
|   |   |   logging.py
|   |   |   __init__.py
|   |   |   
|   |   +---db
|   |   |   |   base.py
|   |   |   |   models.py
|   |   |   |   session.py
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   \---repositories
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           users.py
|   |   |           __init__.py
|   |   |           
|   |   +---ice
|   |   |       provider.py
|   |   |       __init__.py
|   |   |       
|   |   +---messaging
|   |   |       inmemory_bus.py
|   |   |       redis_bus.py
|   |   |       __init__.py
|   |   |       
|   |   \---security
|   |           jwt_provider.py
|   |           password_hasher.py
|   |           __init__.py
|   |           
|   +---presentation
|   |   |   docs.py
|   |   |   errors.py
|   |   |   __init__.py
|   |   |   
|   |   +---api
|   |   |   |   __init__.py
|   |   |   |   
|   |   |   +---deps
|   |   |   |       auth.py
|   |   |   |       containers.py
|   |   |   |       db.py
|   |   |   |       __init__.py
|   |   |   |       
|   |   |   \---routers
|   |   |           auth.py
|   |   |           messages.py
|   |   |           participants.py
|   |   |           rooms.py
|   |   |           webrtc.py
|   |   |           __init__.py
|   |   |           
|   |   +---schemas
|   |   |       api.py
|   |   |       
|   |   +---static
|   |   |   |   app.js
|   |   |   |   auth.html
|   |   |   |   index.html
|   |   |   |   styles.css
|   |   |   |   
|   |   |   \---js
|   |   |           api.js
|   |   |           auth.js
|   |   |           main.js
|   |   |           signal.js
|   |   |           ui.js
|   |   |           webrtc.js
|   |   |           
|   |   \---ws
|   |           rooms.py
|   |           
|   +---scripts
|   |       create_superuser.py
|   |       wait_for_db.py
|   |       
|   \---tests
|           conftest.py
|           test_auth.py
|           test_rooms.py
|           test_ws_basic.py
|           
+---docker
|       api.Dockerfile
|       
\---tests
        test_health.py
        

=== FILE CONTENTS =======================================

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.env.example ---
# ===== FastAPI / App =====
APP_NAME=WebCall
APP_ENV=prod
API_PREFIX=/api/v1
PORT=8000
HOST=0.0.0.0

# ===== Security =====
# ЗАМЕНИ на длинную случайную строку
JWT_SECRET=REPLACE_ME_WITH_LONG_RANDOM
JWT_EXPIRES_MIN=60

# ===== Database =====
DATABASE_URL=postgresql+asyncpg://webcall:Mousa@postgres:5432/webcall

# ===== Redis =====
REDIS_URL=redis://redis:6379/0

# ===== CORS (JSON array) =====
CORS_ORIGINS=["https://call.bandjshoos.ru","http://localhost:8000"]

# ===== WebRTC ICE =====
# STUN
STUN_SERVERS=["stun:stun.l.google.com:19302"]

# TURN: теперь список из UDP и TCP
# ВАЖНО: пароль ниже ДОЛЖЕН совпадать с docker-compose (coturn --user)
TURN_URLS=["turn:turn.bandjshoos.ru:3478?transport=udp","turn:turn.bandjshoos.ru:3478?transport=tcp"]
TURN_USERNAME=webcall
TURN_PASSWORD=Mousa  # задай реальный и тот же в compose

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore ---
__pycache__/
*.pyc
*.pyo
*.pyd
.env
.venv/
.poetry/
.mypy_cache/
.pytest_cache/
.coverage
htmlcov/
.cache/

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini ---
[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml ---
services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    ports:
      - "8000:8000"         # для локальной проверки, Nginx ходит на 127.0.0.1:8000
    depends_on:
      - postgres
      - redis
      - coturn
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000"]
    volumes:
      - ./:/app

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: Mousa     # ← совпадает с .env
      POSTGRES_DB: webcall
    ports:
      - "5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redisdata:/data

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    command:
      - -n
      - --log-file=stdout
      - --min-port=49152
      - --max-port=49200
      - --realm=turn.bandjshoos.ru
      - --listening-ip=0.0.0.0
      - --relay-ip=0.0.0.0
      - --listening-port=3478
      - --external-ip=104.238.24.120          # ← публичный IP твоего VPS
      - --lt-cred-mech
      - --user=webcall:Mousa   # ← совпадает с .env
      - --fingerprint
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49200:49152-49200/udp"

volumes:
  pgdata:
  redisdata:

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\dump.bat ---
@echo off
chcp 65001 >nul
setlocal EnableDelayedExpansion

:: Игнорируемые папки
set "SKIP_DIRS=\venv\;.git\;__pycache__\;.mypy_cache\;.idea\;.vscode\;node_modules\;.pytest_cache\"

:: Игнорируемые файлы
set "SKIP_FILES=CACHEDIR.TAG"

set "OUT=project_dump.txt"

(
  echo === Dump started: %date% %time%
  echo Root: %cd%
  echo.
  echo === DIRECTORY TREE =======================================
  tree /F /A
  echo.
  echo === FILE CONTENTS =======================================
) > "%OUT%"

:: Обход файлов
for /R %%F in (*) do (
    set "FILE=%%~fF"
    call :ShouldSkip "%%F"
    if errorlevel 1 (
        REM skip
    ) else (
        >>"%OUT%" echo.
        >>"%OUT%" echo --- %%F ---
        >>"%OUT%" type "%%F"
    )
)

>>"%OUT%" echo.
>>"%OUT%" echo === Dump finished: %date% %time%

echo Структура и содержимое файлов сохранены в %OUT%
exit /b


:ShouldSkip
setlocal
set "FN=%~1"

:: Проверяем папки
for %%D in (%SKIP_DIRS%) do (
    echo "%FN%" | findstr /I "%%D" >nul && (exit /b 1)
)

:: Проверяем файлы
for %%X in (%SKIP_FILES%) do (
    if /I "%~nx1"=="%%X" exit /b 1
)

exit /b 0

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile ---
.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\project_dump.txt ---
=== Dump started: 05.09.2025 17:22:26,39
Root: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall

=== DIRECTORY TREE =======================================
Folder PATH listing
Volume serial number is 24DA-408B
C:.
|   .env
|   .env.example
|   .gitignore
|   .pre-commit-config.yaml
|   alembic.ini
|   docker-compose.yml
|   dump.bat
|   Makefile
|   project_dump.txt
|   pyproject.toml
|   README.md
|   
+---.pytest_cache
|   |   .gitignore
|   |   CACHEDIR.TAG
|   |   
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\pyproject.toml ---
[tool.poetry]
name = "webcall"
version = "0.1.0"
description = "WebRTC call backend with FastAPI (onion architecture)"
authors = ["You <you@example.com>"]
readme = "README.md"
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.111.0"
uvicorn = {extras=["standard"], version="^0.30.0"}
pydantic = "^2.8.2"
pydantic-settings = "^2.4.0"
SQLAlchemy = "^2.0.30"
asyncpg = "^0.29.0"
alembic = "^1.13.2"
redis = "^5.0.6"
passlib = {version = "^1.7.4", extras=["bcrypt"]}
python-jose = {version = "^3.3.0", extras=["cryptography"]}
httpx = "^0.27.0"
structlog = "^24.1.0"

[tool.poetry.group.dev.dependencies]
pytest = "^8.2.2"
pytest-asyncio = "^0.23.8"
httpx = {version="^0.27.0", extras=["http2"]}
ruff = "^0.6.3"
black = "^24.8.0"
isort = "^5.13.2"
pre-commit = "^3.8.0"
mypy = "^1.11.1"

[tool.ruff]
line-length = 100
extend-select = ["I"]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 100

[tool.pytest.ini_options]
asyncio_mode = "auto"
filterwarnings = [
  "ignore::DeprecationWarning",
]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\README.md ---
# WebCall

Бэкенд для веб-созвонов на FastAPI с WebSocket-сигналингом (onion/clean architecture).

Слои: presentation → application → core. Инфраструктура внедряется через порты.

## Быстрый старт (Docker)

1. Создайте `.env` из примера:

```
cp .env.example .env
```

2. Поднимите стэк:

```
docker compose up --build
```

3. Примените миграции (в другом терминале):

```
docker compose exec api alembic upgrade head
```

4. Откройте Swagger: http://localhost:8000/docs

5. Демо-клиент: http://localhost:8000/static/index.html

## Локальный запуск

Требуется Python 3.11+ и Poetry.

```
poetry install
poetry run uvicorn app.bootstrap.asgi:app --reload
```

Миграции:

```
poetry run alembic upgrade head
```

## Структура

См. дерево в задаче. Важные части:
- app/bootstrap: создание приложения
- core: доменные сущности/порты/сервисы
- application: use-cases
- infrastructure: реализация портов (DB, Redis, JWT, bcrypt, ICE)
- presentation: REST и WS, схемы, ошибки, статика

## Definition of Done
- docker compose up поднимает Postgres, Redis, API
- alembic upgrade head проходит
- /docs доступен
- Регистрация/логин работают
- Создание комнат работает
- WS сигналинг показывает обмен сообщениями

## Примечания
- Rate limit для REST помечен как TODO
- Метрики/Prometheus — TODO хуки
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\.gitignore ---
# Created by pytest automatically.
*
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\README.md ---
# pytest cache directory #

This directory contains data from the pytest's cache plugin,
which provides the `--lf` and `--ff` options, as well as the `cache` fixture.

**Do not** commit this to version control.

See [the docs](https://docs.pytest.org/en/stable/how-to/cache.html) for more information.
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\v\cache\lastfailed ---
{}.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pytest_cache\v\cache\nodeids ---
[
  "app/tests/test_auth.py::test_dummy_auth",
  "app/tests/test_rooms.py::test_dummy_rooms",
  "app/tests/test_ws_basic.py::test_ws_basic",
  "tests/test_health.py::test_healthz"
].
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\env.py ---
from __future__ import annotations

import asyncio
from logging.config import fileConfig
import os
import sys

# Ensure project root is on PYTHONPATH so `import app` works when running alembic
CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

from app.infrastructure.config import get_settings
from app.infrastructure.db.base import Base
from app.infrastructure.db import models  # noqa: F401

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


def get_url() -> str:
    return get_settings().DATABASE_URL


def run_migrations_offline() -> None:
    url = get_url()
    context.configure(
        url=url,
        target_metadata=Base.metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=Base.metadata, compare_type=True)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    connectable = create_async_engine(get_url(), poolclass=pool.NullPool)

    async def run_migrations() -> None:
        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

    asyncio.run(run_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0001_init.py ---
from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = "0001_init"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "users",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("email", sa.String(254), nullable=False, unique=True, index=True),
        sa.Column("username", sa.String(50), nullable=False, unique=True, index=True),
        sa.Column("password_hash", sa.String(255), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "rooms",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("name", sa.String(100), nullable=False),
        sa.Column("owner_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("is_private", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "participants",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("user_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("role", sa.String(20), nullable=False),
        sa.Column("muted", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("joined_at", sa.DateTime(timezone=False), nullable=False),
        sa.Column("left_at", sa.DateTime(timezone=False), nullable=True),
    )

    op.create_table(
        "messages",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("author_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("content", sa.Text(), nullable=False),
        sa.Column("sent_at", sa.DateTime(timezone=False), nullable=False, index=True),
    )


def downgrade() -> None:
    op.drop_table("messages")
    op.drop_table("participants")
    op.drop_table("rooms")
    op.drop_table("users")
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\auth.py ---
from __future__ import annotations

from pydantic import BaseModel, EmailStr, Field


class RegisterInput(BaseModel):
    email: EmailStr
    username: str = Field(min_length=3, max_length=50)
    password: str = Field(min_length=6, max_length=128)


class RegisterOutput(BaseModel):
    id: str
    email: EmailStr
    username: str


class LoginInput(BaseModel):
    email: EmailStr
    password: str


class TokenOutput(BaseModel):
    access_token: str
    token_type: str = "bearer"
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\messages.py ---
from __future__ import annotations

from datetime import datetime
from pydantic import BaseModel, Field


class PostMessageInput(BaseModel):
    room_id: str
    author_id: str
    content: str = Field(min_length=1, max_length=2000)


class MessageDTO(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\rooms.py ---
from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class CreateRoomInput(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomDTO(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class ListRoomsInput(BaseModel):
    owner_id: Optional[str] = None
    skip: int = 0
    limit: int = 50
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\auth.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import User
from ...core.errors import AuthError, ConflictError, NotFoundError
from ...core.ports.repositories import UserRepository
from ...core.ports.services import PasswordHasher, TokenProvider


class RegisterUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher) -> None:
        self.users = users
        self.hasher = hasher

    async def execute(self, email: str, username: str, password: str) -> User:
        if await self.users.get_by_email(email):
            raise ConflictError("Email already registered")
        if await self.users.get_by_username(username):
            raise ConflictError("Username already taken")
        pwd_hash = self.hasher.hash(password)
        user = User.create(email=email, username=username, password_hash=pwd_hash)
        await self.users.add(user)
        return user


class LoginUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher, tokens: TokenProvider) -> None:
        self.users = users
        self.hasher = hasher
        self.tokens = tokens

    async def execute(self, email: str, password: str) -> str:
        user = await self.users.get_by_email(email)
        if not user or not self.hasher.verify(password, str(user.password_hash)):
            raise AuthError("Invalid credentials")
        return self.tokens.create_access_token(str(user.id), None)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\messages.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Message
from ...core.ports.repositories import MessageRepository


class PostMessage:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, author_id: UUID, content: str) -> Message:
        msg = Message.post(room_id=room_id, author_id=author_id, content=content)
        await self.messages.add(msg)
        return msg


class ListMessages:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        return await self.messages.list(room_id=room_id, skip=skip, limit=limit)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\participants.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Participant, Role
from ...core.errors import NotFoundError
from ...core.ports.repositories import ParticipantRepository, RoomRepository
from ...core.services.room_service import RoomService


class JoinRoom:
    def __init__(self, participants: ParticipantRepository, rooms: RoomRepository, policy: RoomService) -> None:
        self.participants = participants
        self.rooms = rooms
        self.policy = policy

    async def execute(self, room_id: UUID, user_id: UUID, role: Role = Role.member) -> Participant:
        room = await self.rooms.get(room_id)
        if not room:
            raise NotFoundError("Room not found")
        active = await self.participants.list_active(room_id)
        self.policy.can_join(room, active)
        participant = Participant.join(user_id=user_id, room_id=room_id, role=role)
        await self.participants.add(participant)
        return participant


class LeaveRoom:
    def __init__(self, participants: ParticipantRepository) -> None:
        self.participants = participants

    async def execute(self, room_id: UUID, user_id: UUID) -> None:
        p = await self.participants.get(room_id, user_id)
        if p:
            p.left_at = p.left_at or p.joined_at
            await self.participants.update(p)


class KickParticipant:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_kick(actor.role, target.role)
        await self.participants.remove(room_id, target_id)


class ToggleMute:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_toggle_mute(actor.role, target.role)
        target.muted = not target.muted
        await self.participants.update(target)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\rooms.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from ...core.domain.models import Room
from ...core.ports.repositories import RoomRepository


class CreateRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, name: str, owner_id: UUID, is_private: bool = False) -> Room:
        room = Room.create(name=name, owner_id=owner_id, is_private=is_private)
        await self.rooms.add(room)
        return room


class ListRooms:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, owner_id: Optional[UUID] = None, skip: int = 0, limit: int = 50) -> list[Room]:
        return await self.rooms.list(owner_id=owner_id, skip=skip, limit=limit)


class GetRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> Optional[Room]:
        return await self.rooms.get(room_id)


class DeleteRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> None:
        await self.rooms.delete(room_id)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\signals.py ---
from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class PublishSignal:
    def __init__(self, bus: SignalBus) -> None:
        self.bus = bus

    async def execute(
        self, *, room_id: UUID, sender_id: UUID, type: str, sdp: str | None = None, candidate: dict | None = None, target_id: UUID | None = None
    ) -> None:
        signal = Signal.create(type=type, sender_id=sender_id, room_id=room_id, sdp=sdp, candidate=candidate, target_id=target_id)
        await self.bus.publish(room_id, signal)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\asgi.py ---
from __future__ import annotations

from .main import create_app

app = create_app()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\main.py ---
from __future__ import annotations

import logging
from contextlib import asynccontextmanager

from fastapi import Depends, FastAPI
from fastapi.responses import RedirectResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles

from ..infrastructure.config import get_settings
from ..infrastructure.logging import configure_logging
from ..presentation.docs import get_openapi_tags
from ..presentation.api.routers import auth as auth_router
from ..presentation.api.routers import rooms as rooms_router
from ..presentation.api.routers import participants as participants_router
from ..presentation.api.routers import messages as messages_router
from ..presentation.api.routers import webrtc as webrtc_router
from ..presentation.api.deps.containers import (
    get_user_repo,
    get_room_repo,
    get_participant_repo,
    get_message_repo,
    get_password_hasher,
    get_token_provider,
    get_signal_bus,
    get_ice_provider,
)
from ..presentation.ws import rooms as ws_rooms
from ..presentation.api.deps.db import get_db_session
from ..infrastructure.db.repositories.users import PgUserRepository
from ..infrastructure.db.repositories.rooms import PgRoomRepository
from ..infrastructure.db.repositories.participants import PgParticipantRepository
from ..infrastructure.db.repositories.messages import PgMessageRepository
from ..infrastructure.security.jwt_provider import JoseTokenProvider
from ..infrastructure.security.password_hasher import BcryptPasswordHasher
from ..infrastructure.messaging.redis_bus import RedisSignalBus
from ..infrastructure.ice.provider import EnvIceConfigProvider
from ..presentation.errors import setup_error_handlers


@asynccontextmanager
async def lifespan(app: FastAPI):
    # here we could init DB/Redis connections if needed globally
    yield


def create_app() -> FastAPI:
    settings = get_settings()
    configure_logging(logging.INFO)

    app = FastAPI(
        title=settings.APP_NAME,
        description="WebRTC signaling server with REST and WebSocket",
        version="0.1.0",
        docs_url="/docs",
        redoc_url="/redoc",
        openapi_tags=get_openapi_tags(),
        lifespan=lifespan,
    )

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    setup_error_handlers(app)

    # Routers
    app.include_router(auth_router.router)
    app.include_router(rooms_router.router)
    app.include_router(participants_router.router)
    app.include_router(messages_router.router)
    app.include_router(webrtc_router.router)

    # WS
    app.include_router(ws_rooms.router)

    # Static demo
    app.mount("/static", StaticFiles(directory="app/presentation/static"), name="static")

    # Friendly entrypoints instead of /static/index.html
    @app.get("/", include_in_schema=False)
    async def root_redirect():
        return RedirectResponse(url="/call", status_code=307)

    @app.get("/call", include_in_schema=False)
    async def call_page():
        return FileResponse("app/presentation/static/index.html")

    @app.get("/call/{room_id}", include_in_schema=False)
    async def call_page_room(room_id: str):  # room_id is used client-side from location
        return FileResponse("app/presentation/static/index.html")

    @app.get("/auth", include_in_schema=False)
    async def auth_page():
        return FileResponse("app/presentation/static/auth.html")

    @app.get("/healthz", tags=["health"])
    async def healthz():
        return {"status": "ok"}

    return app
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\errors.py ---
from dataclasses import dataclass


class DomainError(Exception):
    """Базовая доменная ошибка."""


class ValidationError(DomainError):
    pass


class AuthError(DomainError):
    pass


class NotFoundError(DomainError):
    pass


class PermissionDenied(DomainError):
    pass


class ConflictError(DomainError):
    pass


@dataclass(slots=True)
class ErrorResponse:
    detail: str
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\models.py ---
from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from .values import Email, PasswordHash, RoomName


class Role(str, Enum):
    owner = "owner"
    moderator = "moderator"
    member = "member"


@dataclass(slots=True)
class User:
    id: UUID
    email: Email
    username: str
    password_hash: PasswordHash
    created_at: datetime

    @staticmethod
    def create(email: str, username: str, password_hash: str) -> "User":
        return User(
            id=uuid4(),
            email=Email(email),
            username=username,
            password_hash=PasswordHash(password_hash),
            created_at=datetime.utcnow(),
        )


@dataclass(slots=True)
class Room:
    id: UUID
    name: RoomName
    owner_id: UUID
    is_private: bool
    created_at: datetime

    @staticmethod
    def create(name: str, owner_id: UUID, is_private: bool = False) -> "Room":
        return Room(id=uuid4(), name=RoomName(name), owner_id=owner_id, is_private=is_private, created_at=datetime.utcnow())


@dataclass(slots=True)
class Participant:
    id: UUID
    user_id: UUID
    room_id: UUID
    role: Role
    muted: bool
    joined_at: datetime
    left_at: Optional[datetime] = None

    @staticmethod
    def join(user_id: UUID, room_id: UUID, role: Role) -> "Participant":
        return Participant(id=uuid4(), user_id=user_id, room_id=room_id, role=role, muted=False, joined_at=datetime.utcnow())


@dataclass(slots=True)
class Message:
    id: UUID
    room_id: UUID
    author_id: UUID
    content: str
    sent_at: datetime

    @staticmethod
    def post(room_id: UUID, author_id: UUID, content: str) -> "Message":
        return Message(id=uuid4(), room_id=room_id, author_id=author_id, content=content[:2000], sent_at=datetime.utcnow())


class SignalType(str, Enum):
    offer = "offer"
    answer = "answer"
    ice_candidate = "ice-candidate"


@dataclass(slots=True)
class Signal:
    type: SignalType
    sender_id: UUID
    room_id: UUID
    sent_at: datetime
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    target_id: Optional[UUID] = None

    @staticmethod
    def create(type: str, sender_id: UUID, room_id: UUID, sdp: Optional[str] = None, candidate: Optional[dict] = None, target_id: Optional[UUID] = None) -> "Signal":
        st = SignalType(type)
        return Signal(type=st, sender_id=sender_id, room_id=room_id, sent_at=datetime.utcnow(), sdp=sdp, candidate=candidate, target_id=target_id)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\values.py ---
from __future__ import annotations

import re
from dataclasses import dataclass

from ..errors import ValidationError


EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")


@dataclass(frozen=True, slots=True)
class Email:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip().lower()
        if not EMAIL_RE.match(v):
            raise ValidationError("Invalid email format")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:  # for convenience
        return self.value


@dataclass(frozen=True, slots=True)
class RoomName:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip()
        if not (1 <= len(v) <= 100):
            raise ValidationError("Room name must be 1..100 chars")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:
        return self.value


@dataclass(frozen=True, slots=True)
class PasswordHash:
    value: str

    def __post_init__(self) -> None:
        if not self.value or len(self.value) < 10:
            # bcrypt hashes are long; minimal sanity check
            raise ValidationError("Password hash looks invalid")

    def __str__(self) -> str:
        return self.value
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\repositories.py ---
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Optional
from uuid import UUID

from ..domain.models import Message, Participant, Room, User


class UserRepository(ABC):
    @abstractmethod
    async def get_by_email(self, email: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_username(self, username: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_id(self, user_id: UUID) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, user: User) -> None:
        raise NotImplementedError


class RoomRepository(ABC):
    @abstractmethod
    async def add(self, room: Room) -> None:
        raise NotImplementedError

    @abstractmethod
    async def get(self, room_id: UUID) -> Optional[Room]:
        raise NotImplementedError

    @abstractmethod
    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:
        raise NotImplementedError

    @abstractmethod
    async def delete(self, room_id: UUID) -> None:
        raise NotImplementedError


class ParticipantRepository(ABC):
    @abstractmethod
    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def list_active(self, room_id: UUID) -> list[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def update(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def remove(self, room_id: UUID, user_id: UUID) -> None:
        raise NotImplementedError


class MessageRepository(ABC):
    @abstractmethod
    async def add(self, message: Message) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        raise NotImplementedError
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\services.py ---
from __future__ import annotations

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any
from uuid import UUID

from ..domain.models import Signal


class SignalBus(ABC):
    @abstractmethod
    async def publish(self, room_id: UUID, signal: Signal) -> None:
        raise NotImplementedError

    @abstractmethod
    async def subscribe(self, room_id: UUID):
        """Возвращает асинхронный итератор по сообщениям Signal."""
        raise NotImplementedError

    @abstractmethod
    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        raise NotImplementedError


class PasswordHasher(ABC):
    @abstractmethod
    def hash(self, password: str) -> str:
        raise NotImplementedError

    @abstractmethod
    def verify(self, password: str, password_hash: str) -> bool:
        raise NotImplementedError


class TokenProvider(ABC):
    @abstractmethod
    def create_access_token(self, subject: str, expires_minutes: int) -> str:
        raise NotImplementedError

    @abstractmethod
    def decode_token(self, token: str) -> dict:
        raise NotImplementedError


class Clock(ABC):
    @abstractmethod
    def now(self) -> datetime:
        raise NotImplementedError


class IceConfigProvider(ABC):
    @abstractmethod
    async def get_servers(self) -> list[dict]:
        raise NotImplementedError
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\room_service.py ---
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Iterable
from uuid import UUID

from ..domain.models import Participant, Role, Room
from ..errors import PermissionDenied, ValidationError


@dataclass(slots=True)
class RoomPolicy:
    max_participants: int = 16


class RoomService:
    def __init__(self, policy: RoomPolicy | None = None) -> None:
        self.policy = policy or RoomPolicy()

    def can_join(self, room: Room, participants: Iterable[Participant]) -> None:
        count = sum(1 for p in participants if p.left_at is None)
        if count >= self.policy.max_participants:
            raise ValidationError("Room is full")

    def ensure_can_kick(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can kick")
        if actor_role == Role.moderator and target_role in {Role.owner, Role.moderator}:
            raise PermissionDenied("Moderator cannot kick owner/moderator")

    def ensure_can_toggle_mute(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can mute")

    def leave(self, participant: Participant) -> Participant:
        if participant.left_at is None:
            participant.left_at = datetime.utcnow()
        return participant
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\config.py ---
from __future__ import annotations

from functools import lru_cache
from typing import List

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)

    # App
    APP_NAME: str = "WebCall"
    APP_ENV: str = "dev"
    API_PREFIX: str = "/api/v1"
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Security
    JWT_SECRET: str = "change_me"
    JWT_EXPIRES_MIN: int = 60

    # Databases
    DATABASE_URL: str
    REDIS_URL: str

    # CORS
    CORS_ORIGINS: List[str] = Field(default_factory=lambda: ["http://localhost:5173", "http://localhost:8000"])  # type: ignore[assignment]

    # WebRTC ICE
    STUN_SERVERS: List[str] = Field(default_factory=lambda: ["stun:stun.l.google.com:19302"])  # type: ignore[assignment]
    # Поддерживаем как одиночный TURN_URL, так и список TURN_URLS для UDP/TCP
    TURN_URLS: List[str] | None = None  # type: ignore[assignment]
    TURN_URL: str | None = None
    TURN_USERNAME: str | None = None
    TURN_PASSWORD: str | None = None


@lru_cache()
def get_settings() -> Settings:
    s = Settings()
    # allow comma-separated env for lists
    if isinstance(s.CORS_ORIGINS, str):  # type: ignore[unreachable]
        s.CORS_ORIGINS = [x.strip() for x in s.CORS_ORIGINS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if isinstance(s.STUN_SERVERS, str):  # type: ignore[unreachable]
        s.STUN_SERVERS = [x.strip() for x in s.STUN_SERVERS.split(",") if x.strip()]  # type: ignore[attr-defined]
    # Нормализуем TURN_URLS / TURN_URL
    if isinstance(s.TURN_URLS, str):  # type: ignore[unreachable]
        s.TURN_URLS = [x.strip() for x in s.TURN_URLS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if not s.TURN_URLS and s.TURN_URL:
        s.TURN_URLS = [s.TURN_URL]
    return s
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\logging.py ---
import json
import logging
from typing import Any


class JsonFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:  # type: ignore[override]
        data: dict[str, Any] = {
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        if record.exc_info:
            data["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(data, ensure_ascii=False)


def configure_logging(level: int = logging.INFO) -> None:
    handler = logging.StreamHandler()
    handler.setFormatter(JsonFormatter())
    root = logging.getLogger()
    root.handlers.clear()
    root.addHandler(handler)
    root.setLevel(level)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\base.py ---
from __future__ import annotations

from sqlalchemy.orm import DeclarativeBase, declared_attr


class Base(DeclarativeBase):
    __abstract__ = True

    @declared_attr.directive
    def __tablename__(cls) -> str:  # type: ignore[override]
        return cls.__name__.lower()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\models.py ---
from __future__ import annotations

from datetime import datetime
from uuid import UUID

from sqlalchemy import Boolean, DateTime, ForeignKey, String, Text
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import Base


class Users(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    email: Mapped[str] = mapped_column(String(254), unique=True, index=True, nullable=False)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    rooms = relationship("Rooms", back_populates="owner")


class Rooms(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    owner_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    is_private: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    owner = relationship("Users", back_populates="rooms")


class Participants(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    user_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    role: Mapped[str] = mapped_column(String(20), nullable=False)
    muted: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    joined_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    left_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False), nullable=True)


class Messages(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    author_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    sent_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False, index=True)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\session.py ---
from __future__ import annotations

from contextlib import asynccontextmanager
from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from ..config import get_settings


_settings = get_settings()
ENGINE: AsyncEngine = create_async_engine(_settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = sessionmaker(bind=ENGINE, class_=AsyncSession, expire_on_commit=False)


@asynccontextmanager
async def get_session() -> AsyncIterator[AsyncSession]:
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        yield session
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\messages.py ---
from __future__ import annotations

from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Message
from ....core.ports.repositories import MessageRepository
from ..models import Messages


class PgMessageRepository(MessageRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, message: Message) -> None:  # type: ignore[override]
        self.session.add(
            Messages(
                id=message.id,
                room_id=message.room_id,
                author_id=message.author_id,
                content=message.content,
                sent_at=message.sent_at,
            )
        )
        await self.session.commit()

    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:  # type: ignore[override]
        stmt = select(Messages).where(Messages.room_id == room_id).order_by(Messages.sent_at.asc()).offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Message(id=r.id, room_id=r.room_id, author_id=r.author_id, content=r.content, sent_at=r.sent_at) for r in rows]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\participants.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select, update
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Participant, Role
from ....core.ports.repositories import ParticipantRepository
from ..models import Participants


class PgParticipantRepository(ParticipantRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return Participant(
                id=row.id,
                user_id=row.user_id,
                room_id=row.room_id,
                role=Role(row.role),
                muted=row.muted,
                joined_at=row.joined_at,
                left_at=row.left_at,
            )
        return None

    async def list_active(self, room_id: UUID) -> list[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.left_at.is_(None))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [
            Participant(id=r.id, user_id=r.user_id, room_id=r.room_id, role=Role(r.role), muted=r.muted, joined_at=r.joined_at, left_at=r.left_at)
            for r in rows
        ]

    async def add(self, participant: Participant) -> None:  # type: ignore[override]
        self.session.add(
            Participants(
                id=participant.id,
                user_id=participant.user_id,
                room_id=participant.room_id,
                role=participant.role.value,
                muted=participant.muted,
                joined_at=participant.joined_at,
                left_at=participant.left_at,
            )
        )
        await self.session.commit()

    async def update(self, participant: Participant) -> None:  # type: ignore[override]
        await self.session.execute(
            update(Participants)
            .where(Participants.id == participant.id)
            .values(muted=participant.muted, left_at=participant.left_at)
        )
        await self.session.commit()

    async def remove(self, room_id: UUID, user_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(
            delete(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        )
        await self.session.commit()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\rooms.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Room
from ....core.domain.values import RoomName
from ....core.ports.repositories import RoomRepository
from ..models import Rooms


class PgRoomRepository(RoomRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, room: Room) -> None:  # type: ignore[override]
        self.session.add(
            Rooms(id=room.id, name=str(room.name), owner_id=room.owner_id, is_private=room.is_private, created_at=room.created_at)
        )
        await self.session.commit()

    async def get(self, room_id: UUID) -> Optional[Room]:  # type: ignore[override]
        row = await self.session.get(Rooms, room_id)
        if not row:
            return None
        return Room(id=row.id, name=RoomName(row.name), owner_id=row.owner_id, is_private=row.is_private, created_at=row.created_at)

    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:  # type: ignore[override]
        stmt = select(Rooms)
        if owner_id:
            stmt = stmt.where(Rooms.owner_id == owner_id)
        stmt = stmt.offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Room(id=r.id, name=RoomName(r.name), owner_id=r.owner_id, is_private=r.is_private, created_at=r.created_at) for r in rows]

    async def delete(self, room_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(delete(Rooms).where(Rooms.id == room_id))
        await self.session.commit()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\users.py ---
from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import User
from ....core.domain.values import Email, PasswordHash
from ....core.ports.repositories import UserRepository
from ..models import Users
from ....core.errors import ConflictError


class PgUserRepository(UserRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_email(self, email: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.email == email)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_id(self, user_id: UUID) -> Optional[User]:  # type: ignore[override]
        row = await self.session.get(Users, user_id)
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_username(self, username: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.username == username)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=row.username, password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def add(self, user: User) -> None:  # type: ignore[override]
        self.session.add(Users(id=user.id, email=str(user.email), username=user.username, password_hash=str(user.password_hash), created_at=user.created_at))
        try:
            await self.session.commit()
        except IntegrityError as e:
            await self.session.rollback()
            # Переводим БД-ошибку в доменную 409
            raise ConflictError("User with same email or username already exists") from e
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\provider.py ---
# app/presentation/infrastructure/ice/provider.py
from __future__ import annotations

import json
import os
from typing import Any, Protocol


class IceConfigProvider(Protocol):
    async def get_servers(self) -> dict[str, Any]: ...


def _get_env(name: str, default: str | None = None) -> str | None:
    val = os.getenv(name)
    return val if val is not None else default


class EnvIceConfigProvider:
    """
    Читает STUN/TURN из env и отдаёт структуру WebRTC ICE.
    Поддерживает:
      - STUN_SERVERS: JSON-массив или строка с запятыми
      - TURN_URLS: JSON-массив или строка с запятыми
      - TURN_URL: одиночная строка (legacy)
    """

    async def get_servers(self) -> dict[str, Any]:
        # --- STUN ---
        stun_raw = _get_env("STUN_SERVERS", '["stun:stun.l.google.com:19302"]')
        stun_servers: list[str] = []
        if stun_raw:
            try:
                if stun_raw.strip().startswith("["):
                    stun_servers = json.loads(stun_raw)
                else:
                    stun_servers = [s.strip() for s in stun_raw.split(",") if s.strip()]
            except Exception:
                stun_servers = []

        # --- TURN ---
        # Новое: поддержка списка URL (UDP/TCP и т.д.)
        turn_urls_raw = _get_env("TURN_URLS") or _get_env("TURN_URL")
        turn_username = _get_env("TURN_USERNAME")
        turn_password = _get_env("TURN_PASSWORD")

        turn_urls: list[str] = []
        if turn_urls_raw:
            try:
                if turn_urls_raw.strip().startswith("["):
                    turn_urls = json.loads(turn_urls_raw)
                else:
                    turn_urls = [u.strip() for u in turn_urls_raw.split(",") if u.strip()]
            except Exception:
                turn_urls = [turn_urls_raw]

        ice: list[dict[str, Any]] = []
        if stun_servers:
            ice.append({"urls": stun_servers})
        if turn_urls and turn_username and turn_password:
            ice.append(
                {
                    "urls": turn_urls,
                    "username": turn_username,
                    "credential": turn_password,
                }
            )

        return {"iceServers": ice}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\inmemory_bus.py ---
from __future__ import annotations

import asyncio
from collections import defaultdict
from typing import AsyncIterator, Dict, List
from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class InMemorySignalBus(SignalBus):
    def __init__(self) -> None:
        self.queues: Dict[UUID, List[asyncio.Queue[Signal]]] = defaultdict(list)
        self._presence: Dict[UUID, set[str]] = defaultdict(set)

    async def publish(self, room_id: UUID, signal: Signal) -> None:  # type: ignore[override]
        for q in list(self.queues[room_id]):
            await q.put(signal)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:  # type: ignore[override]
        q: asyncio.Queue[Signal] = asyncio.Queue()
        self.queues[room_id].append(q)
        try:
            while True:
                try:
                    s = await q.get()
                except asyncio.CancelledError:
                    # нормальный выход при отмене таска-подписчика
                    break
                else:
                    yield s
        finally:
            self.queues[room_id].remove(q)

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:  # type: ignore[override]
        if present:
            self._presence[room_id].add(str(user_id))
        else:
            self._presence[room_id].discard(str(user_id))

    async def list_presence(self, room_id: UUID) -> List[dict]:  # type: ignore[override]
        return [{"user_id": uid, "present": True} for uid in self._presence[room_id]]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\redis_bus.py ---
from __future__ import annotations

import asyncio
import json
from typing import Any, AsyncIterator
from uuid import UUID

import redis.asyncio as aioredis

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus
from ..config import get_settings


class RedisSignalBus(SignalBus):
    def __init__(self, redis: aioredis.Redis | None = None) -> None:
        self.settings = get_settings()
        self.redis = redis or aioredis.from_url(self.settings.REDIS_URL, decode_responses=True)

    def _channel(self, room_id: UUID) -> str:
        return f"room:{room_id}:signals"

    def _presence_key(self, room_id: UUID) -> str:
        return f"room:{room_id}:presence"

    async def publish(self, room_id: UUID, signal: Signal) -> None:
        payload = json.dumps(
            {
                "type": signal.type.value,
                "sender_id": str(signal.sender_id),
                "target_id": str(signal.target_id) if signal.target_id else None,
                "room_id": str(signal.room_id),
                "sdp": signal.sdp,
                "candidate": signal.candidate,
                "sent_at": signal.sent_at.isoformat(),
            }
        )
        await self.redis.publish(self._channel(room_id), payload)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:
        pubsub = self.redis.pubsub()
        await pubsub.subscribe(self._channel(room_id))
        try:
            async for msg in pubsub.listen():
                if msg["type"] != "message":
                    continue
                data = json.loads(msg["data"])  # type: ignore[arg-type]
                yield Signal.create(
                    type=data["type"],
                    sender_id=UUID(data["sender_id"]),
                    room_id=UUID(data["room_id"]),
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["target_id"]) if data.get("target_id") else None,
                )
        finally:
            await pubsub.unsubscribe(self._channel(room_id))
            await pubsub.close()

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        key = self._presence_key(room_id)
        if present:
            await self.redis.hset(key, str(user_id), json.dumps({"present": True}))
        else:
            await self.redis.hdel(key, str(user_id))
        await self.redis.expire(key, 60 * 60)

    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        key = self._presence_key(room_id)
        data = await self.redis.hgetall(key)
        result: list[dict[str, Any]] = []
        for uid, v in data.items():
            try:
                obj = json.loads(v)
            except Exception:
                obj = {"present": True}
            obj["user_id"] = uid
            result.append(obj)
        return result
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\jwt_provider.py ---
from __future__ import annotations

from datetime import datetime, timedelta, timezone

from jose import JWTError, jwt

from ...core.ports.services import TokenProvider
from ..config import get_settings


class JoseTokenProvider(TokenProvider):
    def __init__(self) -> None:
        self.settings = get_settings()
        self.algorithm = "HS256"

    def create_access_token(self, subject: str, expires_minutes: int | None = None) -> str:  # type: ignore[override]
        expires_minutes = expires_minutes or self.settings.JWT_EXPIRES_MIN
        now = datetime.now(tz=timezone.utc)
        payload = {"sub": subject, "iat": int(now.timestamp()), "exp": int((now + timedelta(minutes=expires_minutes)).timestamp())}
        return jwt.encode(payload, self.settings.JWT_SECRET, algorithm=self.algorithm)

    def decode_token(self, token: str) -> dict:  # type: ignore[override]
        try:
            return jwt.decode(token, self.settings.JWT_SECRET, algorithms=[self.algorithm])
        except JWTError as e:
            raise ValueError("Invalid token") from e
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\password_hasher.py ---
from __future__ import annotations

from passlib.context import CryptContext

from ...core.ports.services import PasswordHasher


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class BcryptPasswordHasher(PasswordHasher):
    def hash(self, password: str) -> str:
        return pwd_context.hash(password)

    def verify(self, password: str, password_hash: str) -> bool:
        return pwd_context.verify(password, password_hash)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\docs.py ---
from __future__ import annotations

from typing import List


def get_openapi_tags() -> List[dict]:
    return [
        {"name": "auth", "description": "Аутентификация"},
        {"name": "rooms", "description": "Комнаты"},
        {"name": "participants", "description": "Участники"},
        {"name": "messages", "description": "Сообщения"},
        {"name": "webrtc", "description": "WebRTC вспомогательные"},
        {"name": "health", "description": "Health checks"},
    ]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\errors.py ---
from __future__ import annotations

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

from ..core.errors import AuthError, ConflictError, DomainError, NotFoundError, PermissionDenied, ValidationError


def setup_error_handlers(app: FastAPI) -> None:
    @app.exception_handler(ValidationError)
    async def _validation(_: Request, exc: ValidationError):
        return JSONResponse(status_code=400, content={"detail": str(exc)})

    @app.exception_handler(AuthError)
    async def _auth(_: Request, exc: AuthError):
        return JSONResponse(status_code=401, content={"detail": str(exc)})

    @app.exception_handler(NotFoundError)
    async def _not_found(_: Request, exc: NotFoundError):
        return JSONResponse(status_code=404, content={"detail": str(exc)})

    @app.exception_handler(ConflictError)
    async def _conflict(_: Request, exc: ConflictError):
        return JSONResponse(status_code=409, content={"detail": str(exc)})

    @app.exception_handler(PermissionDenied)
    async def _forbidden(_: Request, exc: PermissionDenied):
        return JSONResponse(status_code=403, content={"detail": str(exc)}).
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\auth.py ---
from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

from ....core.errors import NotFoundError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import TokenProvider
from .containers import get_user_repo, get_token_provider


bearer_scheme = HTTPBearer(auto_error=False)


async def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials | None, Depends(bearer_scheme)],
    users: UserRepository = Depends(get_user_repo),
    tokens: TokenProvider = Depends(get_token_provider),
):
    if not credentials:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    try:
        payload = tokens.decode_token(credentials.credentials)
        sub = payload.get("sub")
        user = await users.get_by_id(UUID(sub))
        if not user:
            raise NotFoundError()
        return user
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\containers.py ---
from __future__ import annotations

from fastapi import Depends
from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session
from ....infrastructure.db.session import get_session as _get_session
from ....infrastructure.db.repositories.users import PgUserRepository
from ....infrastructure.db.repositories.rooms import PgRoomRepository
from ....infrastructure.db.repositories.participants import PgParticipantRepository
from ....infrastructure.db.repositories.messages import PgMessageRepository
from ....infrastructure.security.password_hasher import BcryptPasswordHasher
from ....infrastructure.security.jwt_provider import JoseTokenProvider
from ....infrastructure.ice.provider import EnvIceConfigProvider


# DB session
# DB session provider
async def get_db_session() -> AsyncSession:
    async with _get_session() as s:  # type: ignore[misc]
        return s
from ....infrastructure.messaging.redis_bus import RedisSignalBus
from ....infrastructure.messaging.inmemory_bus import InMemorySignalBus
from ....infrastructure.config import get_settings
from functools import lru_cache


# Repositories
async def get_user_repo(session: AsyncSession = Depends(get_db_session)):
    return PgUserRepository(session)


async def get_room_repo(session: AsyncSession = Depends(get_db_session)):
    return PgRoomRepository(session)


async def get_participant_repo(session: AsyncSession = Depends(get_db_session)):
    return PgParticipantRepository(session)


async def get_message_repo(session: AsyncSession = Depends(get_db_session)):
    return PgMessageRepository(session)


# Services
def get_password_hasher():
    return BcryptPasswordHasher()


def get_token_provider():
    return JoseTokenProvider()


def get_signal_bus():
    # Singleton SignalBus per process to ensure all WS share the same bus
    return _get_signal_bus_singleton()


@lru_cache(maxsize=1)
def _get_signal_bus_singleton():
    s = get_settings()
    # Use in-memory bus by default for local/dev/testing; switch to Redis via env
    if s.APP_ENV in {"dev", "test"}:
        return InMemorySignalBus()
    return RedisSignalBus()


def get_ice_provider():
    return EnvIceConfigProvider()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\db.py ---
from __future__ import annotations

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session


async def get_db_session() -> AsyncIterator[AsyncSession]:
    async with get_session() as session:
        yield session
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\auth.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status

from ....application.dto.auth import LoginInput, RegisterInput, RegisterOutput, TokenOutput
from ....core.domain.models import User
from ....core.errors import ConflictError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import PasswordHasher, TokenProvider
from ..deps.containers import get_password_hasher, get_token_provider, get_user_repo

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])


@router.post("/register", response_model=RegisterOutput, status_code=status.HTTP_201_CREATED)
async def register(
    data: RegisterInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
) -> RegisterOutput:  # type: ignore[override]
    from ....application.use_cases.auth import RegisterUser

    use = RegisterUser(users, hasher)
    user = await use.execute(email=data.email, username=data.username, password=data.password)
    return RegisterOutput(id=str(user.id), email=str(user.email), username=user.username)


@router.post("/login", response_model=TokenOutput)
async def login(
    data: LoginInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
    tokens: TokenProvider = Depends(get_token_provider),
) -> TokenOutput:  # type: ignore[override]
    from ....application.use_cases.auth import LoginUser

    use = LoginUser(users, hasher, tokens)
    access = await use.execute(email=data.email, password=data.password)
    return TokenOutput(access_token=access)
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\messages.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.messages import MessageDTO, PostMessageInput
from ....application.use_cases.messages import ListMessages, PostMessage
from ....core.ports.repositories import MessageRepository
from ..deps.containers import get_message_repo

router = APIRouter(prefix="/api/v1/rooms/{room_id}/messages", tags=["messages"])


@router.post("", response_model=MessageDTO)
async def post_message(room_id: str, data: PostMessageInput, messages: MessageRepository = Depends(get_message_repo)) -> MessageDTO:  # type: ignore[override]
    use = PostMessage(messages)
    msg = await use.execute(room_id=UUID(room_id), author_id=UUID(data.author_id), content=data.content)
    return MessageDTO(id=str(msg.id), room_id=str(msg.room_id), author_id=str(msg.author_id), content=msg.content, sent_at=msg.sent_at)


@router.get("", response_model=list[MessageDTO])
async def list_messages(room_id: str, skip: int = 0, limit: int = 50, messages: MessageRepository = Depends(get_message_repo)):  # type: ignore[override]
    use = ListMessages(messages)
    items = await use.execute(room_id=UUID(room_id), skip=skip, limit=limit)
    return [MessageDTO(id=str(m.id), room_id=str(m.room_id), author_id=str(m.author_id), content=m.content, sent_at=m.sent_at) for m in items]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\participants.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException

from ....application.use_cases.participants import JoinRoom, KickParticipant, LeaveRoom, ToggleMute
from ....core.domain.models import Role
from ....core.errors import NotFoundError
from ....core.ports.repositories import ParticipantRepository, RoomRepository
from ..deps.containers import get_participant_repo, get_room_repo
from ....core.services.room_service import RoomService

router = APIRouter(prefix="/api/v1/rooms/{room_id}", tags=["participants"])


@router.post("/join")
async def join_room(
    room_id: str,
    user_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
    rooms: RoomRepository = Depends(get_room_repo),
) -> dict:  # type: ignore[override]
    use = JoinRoom(participants, rooms, RoomService())
    p = await use.execute(room_id=UUID(room_id), user_id=UUID(user_id), role=Role.member)
    return {"status": "ok", "participantId": str(p.id)}


@router.post("/leave")
async def leave_room(room_id: str, user_id: str, participants: ParticipantRepository = Depends(get_participant_repo)) -> dict:  # type: ignore[override]
    use = LeaveRoom(participants)
    await use.execute(room_id=UUID(room_id), user_id=UUID(user_id))
    return {"status": "ok"}


@router.post("/kick/{target_id}")
async def kick(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = KickParticipant(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}


@router.post("/toggle-mute/{target_id}")
async def toggle_mute(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = ToggleMute(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\rooms.py ---
from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.rooms import CreateRoomInput, ListRoomsInput, RoomDTO
from ....application.use_cases.rooms import CreateRoom, GetRoom, ListRooms
from ....core.ports.repositories import RoomRepository
from ..deps.containers import get_room_repo
from ..deps.auth import get_current_user

router = APIRouter(prefix="/api/v1/rooms", tags=["rooms"])


@router.post("", response_model=RoomDTO)
async def create_room(
    data: CreateRoomInput,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = CreateRoom(rooms)
    room = await use.execute(name=data.name, owner_id=UUID(str(current_user.id)), is_private=data.is_private)
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.get("", response_model=list[RoomDTO])
async def list_rooms(
    owner_id: str | None = None,
    skip: int = 0,
    limit: int = 50,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    use = ListRooms(rooms)
    rid = UUID(owner_id) if owner_id else None
    items = await use.execute(owner_id=rid, skip=skip, limit=limit)
    return [RoomDTO(id=str(r.id), name=str(r.name), owner_id=str(r.owner_id), is_private=r.is_private, created_at=r.created_at) for r in items]


@router.get("/{room_id}", response_model=RoomDTO)
async def get_room(
    room_id: str,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = GetRoom(rooms)
    room = await use.execute(UUID(room_id))
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.delete("/{room_id}")
async def delete_room(
    room_id: str,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    from ....application.use_cases.rooms import DeleteRoom, GetRoom

    getter = GetRoom(rooms)
    room = await getter.execute(UUID(room_id))
    if not room or str(room.owner_id) != str(current_user.id):
        from fastapi import HTTPException, status

        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only owner can delete room")
    deleter = DeleteRoom(rooms)
    await deleter.execute(UUID(room_id))
    return {"status": "deleted"}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\webrtc.py ---
from __future__ import annotations

from fastapi import APIRouter, Depends

from ....core.ports.services import IceConfigProvider
from ..deps.containers import get_ice_provider

router = APIRouter(prefix="/api/v1/webrtc", tags=["webrtc"])


@router.get("/ice-servers")
async def ice_servers(provider: IceConfigProvider = Depends(get_ice_provider)) -> dict:  # type: ignore[override]
    return await provider.get_servers()
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\__init__.py ---
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\schemas\api.py ---
from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class ErrorResponse(BaseModel):
    detail: str


class UserOut(BaseModel):
    id: str
    email: str
    username: str


class RoomCreateIn(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomOut(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class MessageIn(BaseModel):
    content: str = Field(min_length=1, max_length=2000)


class MessageOut(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime


class SignalIn(BaseModel):
    signalType: str
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    targetUserId: Optional[str] = None


class PresenceOut(BaseModel):
    users: list[dict]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\app.js ---
// Модульная версия UI подключается через /static/js/main.js
// Этот файл оставлен пустым намеренно.
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\auth.html ---
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Вход | WebCall</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .auth-card { max-width: 520px; margin: 10vh auto; }
      .tabs { display:flex; gap:8px; margin-bottom:12px }
      .tab { padding:8px 12px; border-radius:8px; border:1px solid var(--border); cursor:pointer; background:#0b1220 }
      .tab.active { background: var(--primary); border-color: var(--primary) }
      .hint { color: var(--muted); font-size: 13px }
    </style>
  </head>
  <body>
    <main class="container">
      <div class="card auth-card">
        <h2>Добро пожаловать</h2>
        <div class="tabs">
          <button class="tab active" id="tabLogin">Вход</button>
          <button class="tab" id="tabRegister">Регистрация</button>
        </div>
        <div id="formLogin" class="form-grid">
          <label>
            <span>Email</span>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
          </label>
          <label>
            <span>Пароль</span>
            <input id="loginPassword" type="password" placeholder="••••••••" />
          </label>
          <button id="btnDoLogin" class="btn primary">Войти</button>
          <div class="hint">Если у вас нет аккаунта — перейдите на вкладку «Регистрация».</div>
        </div>
        <div id="formRegister" class="form-grid" style="display:none">
          <label>
            <span>Email</span>
            <input id="regEmail" type="email" placeholder="you@example.com" />
          </label>
          <label>
            <span>Имя пользователя</span>
            <input id="regUsername" type="text" placeholder="Ваше имя" />
          </label>
          <label>
            <span>Пароль</span>
            <input id="regPassword" type="password" placeholder="••••••••" />
          </label>
          <button id="btnDoRegister" class="btn success">Зарегистрироваться</button>
          <div class="hint">После регистрации вы будете перенаправлены в звонок.</div>
        </div>
        <div id="authLog" class="logs" style="margin-top:12px;min-height:60px"></div>
      </div>
    </main>
    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>
    <script type="module" src="/static/js/auth.js"></script>
  </body>
</html>
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\index.html ---
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebCall Demo</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <header class="app-header">
      <div class="container header-inner">
        <div class="brand">
          <span class="logo" aria-hidden>●</span>
          <span class="title">WebCall</span>
        </div>
        <nav class="actions">
          <button class="btn ghost" id="btnToggleTheme" title="Переключить тему">🌓</button>
          <a class="btn ghost" href="/docs" target="_blank" rel="noreferrer">Docs</a>
        </nav>
      </div>
    </header>

    <main class="container app-main">
      <section class="panel grid-2">
        <div class="card">
          <h2>Комната</h2>
          <div class="form-grid">
            <label>
              <span>Room ID</span>
              <input id="roomId" placeholder="room-123" />
            </label>
            <div class="row">
              <button id="btnConnect" class="btn success">Подключиться</button>
              <button id="btnLeave" class="btn" disabled>Выйти</button>
              <button id="btnCopyLink" class="btn ghost">Скопировать ссылку</button>
            </div>
            <div class="muted" id="connStatus">Не подключено</div>
          </div>
        </div>

        <div class="card">
          <h2>Участники</h2>
          <div class="form-grid" style="grid-template-columns:1fr;">
            <div>
              <div class="muted">Вы</div>
              <div class="row">
                <button id="btnToggleMic" class="btn" disabled>🎤 Вкл/Выкл</button>
                <button id="btnToggleCam" class="btn" disabled>🎥 Вкл/Выкл</button>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section class="panel grid-3">
        <div class="card video-card">
          <div class="video-wrap">
            <video id="localVideo" autoplay playsinline muted></video>
          </div>
          <div class="controls"><span class="muted">Моё превью (камера по умолчанию выключена)</span></div>
        </div>

        <div class="card video-card">
          <div class="video-grid" id="peersGrid" aria-live="polite">
            <!-- динамические плитки участников появятся здесь -->
          </div>
          <div class="controls">
            <span class="muted">Участники комнаты</span>
          </div>
        </div>

        <div class="card chat-card">
          <h2>Чат</h2>
          <div id="chat" class="chat-log" aria-live="polite"></div>
          <div class="chat-input">
            <input id="chatInput" placeholder="Напишите сообщение..." />
            <button id="btnSend" class="btn" disabled>Отправить</button>
          </div>
        </div>
      </section>

      <section class="card panel">
        <h2>Логи</h2>
        <div id="logs" class="logs"></div>
      </section>
    </main>

    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>

    <template id="tpl-peer-tile">
      <div class="peer-tile" data-peer="">
        <div class="media">
          <video autoplay playsinline></video>
          <div class="avatar" aria-hidden>👤</div>
          <button class="unmute-btn" title="Включить звук">▶️ Включить звук</button>
        </div>
        <div class="hud">
          <div class="name">Participant</div>
          <div class="level-bar"><span></span></div>
          <div class="row">
            <button class="btn xs mute">Mute</button>
            <input class="volume" type="range" min="0" max="1" step="0.01" value="1" />
          </div>
        </div>
      </div>
    </template>

    <script type="module" src="/static/js/main.js"></script>
  </body>
  </html>
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\styles.css ---
/* Theme */
:root{
  --bg:#060913;
  --panel:#0a1020;
  --card:#0b1220;
  --text:#e6f0ff;
  --muted:#98a3b8;
  --primary:#7c3aed; /* violet-600 */
  --primary-2:#06b6d4; /* cyan-500 */
  --success:#22c55e;
  --border:#1a2236;
  --ring:rgba(124,58,237,0.35);
}

html,body{height:100%}
body{
  margin:0; font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  background:radial-gradient(1200px 600px at 10% -10%, rgba(124,58,237,0.18), transparent), radial-gradient(1000px 600px at 100% 10%, rgba(6,182,212,0.12), transparent), linear-gradient(180deg, #070a14 0%, #0b1220 100%);
  color:var(--text);
}
.container{max-width:1200px;margin:0 auto;padding:16px}
.app-header{position:sticky;top:0;backdrop-filter: blur(6px);background:rgba(15,23,42,0.6);border-bottom:1px solid var(--border);}
.header-inner{display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;align-items:center;gap:10px}
.logo{display:inline-grid;place-items:center;width:24px;height:24px;border-radius:50%;background:conic-gradient(from 180deg, var(--primary), var(--primary-2));box-shadow:0 0 20px rgba(124,58,237,0.45)}
.title{font-weight:700;letter-spacing:0.4px}
.actions{display:flex;gap:8px}

.app-main{display:flex;flex-direction:column;gap:16px}
.panel{background:transparent;border-radius:12px}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
.grid-3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:16px}
@media(max-width:1000px){.grid-3{grid-template-columns:1fr 1fr}}
@media(max-width:700px){.grid-2,.grid-3{grid-template-columns:1fr}}

.card{background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.015));border:1px solid var(--border);border-radius:14px;padding:16px;box-shadow:0 10px 40px rgba(0,0,0,0.3);transition:transform .2s ease, box-shadow .2s ease}
.card:hover{transform:translateY(-2px);box-shadow:0 16px 50px rgba(0,0,0,0.35)}
.card h2{margin:0 0 12px 0;font-size:18px}

.form-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.form-grid .row{grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap}
label{display:flex;flex-direction:column;gap:6px;font-size:14px;color:var(--muted)}
input{background:#0b1220;border:1px solid var(--border);color:var(--text);padding:10px 12px;border-radius:8px;outline:none}
input:focus{border-color:var(--primary);box-shadow:0 0 0 4px var(--ring)}

.btn{background:#0f172a;border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:10px;cursor:pointer;transition:transform .1s ease, box-shadow .2s ease, border-color .2s ease}
.btn:hover{border-color:#2a3347;box-shadow:0 0 0 4px rgba(124,58,237,0.08);transform:translateY(-1px)}
.btn:disabled{opacity:0.6;cursor:not-allowed}
.btn.primary{background:linear-gradient(90deg, var(--primary), var(--primary-2));border-color:transparent}
.btn.success{background:var(--success);border-color:var(--success)}
.btn.ghost{background:transparent}

.video-card .video-wrap{position:relative;aspect-ratio:16/9;background:#000;border-radius:10px;overflow:hidden;border:1px solid var(--border)}
video{width:100%;height:100%;object-fit:cover}
.controls{display:flex;gap:8px;margin-top:8px}

/* Multi-peer grid */
.video-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;min-height:260px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid var(--border);border-radius:14px;padding:12px}
@media(max-width:900px){.video-grid{grid-template-columns:1fr}}
@media(min-width:1100px){.video-grid{grid-template-columns:repeat(3,1fr)}}
.peer-tile{position:relative;background:linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.015));border:1px solid var(--border);border-radius:14px;overflow:hidden;animation:tile-in .25s ease both}
.peer-tile:hover{box-shadow:0 0 0 4px rgba(6,182,212,0.08) inset}
.peer-tile .media:after{content:"";position:absolute;inset:auto 0 0 0;height:60px;background:linear-gradient(180deg, transparent, rgba(0,0,0,0.5))}
.peer-tile .media{position:relative;aspect-ratio:16/10;background:#0b1220}
.peer-tile video{width:100%;height:100%;object-fit:cover;display:block}
.peer-tile .avatar{position:absolute;inset:0;display:grid;place-items:center;font-size:42px;color:#94a3b8;filter:drop-shadow(0 6px 14px rgba(0,0,0,0.4))}
.peer-tile .unmute-btn{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.6);border:1px solid var(--border);color:#fff;border-radius:999px;padding:8px 12px;backdrop-filter:blur(6px);display:none}
.peer-tile:hover .unmute-btn{display:block}
.peer-tile .hud{display:flex;flex-direction:column;gap:6px;padding:8px}
.peer-tile .name{font-size:13px;color:#e5edff;letter-spacing:0.2px}
.peer-tile .row{display:flex;gap:8px;align-items:center}
.peer-tile .btn.xs{padding:4px 8px;font-size:12px;border-radius:6px}
.peer-tile .volume{flex:1}

.chat-card{display:flex;flex-direction:column;gap:8px}
.chat-log{height:260px;overflow:auto;border:1px dashed var(--border);border-radius:8px;padding:8px;background:#0b1220}
.chat-input{display:flex;gap:8px}

.logs{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;background:#0b1220;border:1px solid var(--border);border-radius:8px;min-height:120px;max-height:200px;overflow:auto;padding:8px;color:#cbd5e1}
.log-line{display:flex;gap:8px}
.log-line .time{color:#64748b}
.log-line .msg{flex:1}

.muted{color:var(--muted)}

/* Audio level meter */
.level-bar{position:relative;flex:1;height:10px;background:#0b1220;border:1px solid var(--border);border-radius:6px;overflow:hidden;min-width:120px}
.level-bar>span{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg, #06b6d4, #7c3aed);transition:width .08s linear}

/* Glow accents */
.peer-tile:before{content:"";position:absolute;inset:0;border-radius:14px;pointer-events:none;box-shadow:inset 0 0 40px rgba(124,58,237,0.08)}

@keyframes tile-in{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\api.js ---
// api.js - REST helpers
const base = '';

export async function getIceServers() {
  const res = await fetch(`${base}/api/v1/webrtc/ice-servers`);
  if (!res.ok) throw new Error('Failed to fetch ICE servers');
  return res.json();
}

export async function login(email, password) {
  const res = await fetch(`${base}/api/v1/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, password }),
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Login failed: ${res.status} ${text}`);
  }
  return res.json(); // { access_token }
}

export async function register(email, username, password) {
  const res = await fetch(`${base}/api/v1/auth/register`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ email, username, password }),
  });
  if (!res.ok) {
    const text = await res.text().catch(()=> '');
    throw new Error(`Register failed: ${res.status} ${text}`);
  }
  return res.json(); // { id, email, username }
}

export function buildWs(roomId, token) {
  const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
  const qp = token ? `?token=${encodeURIComponent(token)}` : '';
  return new WebSocket(`${wsProto}://${location.host}/ws/rooms/${encodeURIComponent(roomId)}${qp}`);
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\auth.js ---
// auth.js — регистрация/вход
import { login, register } from './api.js';

const els = {
  tabLogin: document.getElementById('tabLogin'),
  tabRegister: document.getElementById('tabRegister'),
  formLogin: document.getElementById('formLogin'),
  formRegister: document.getElementById('formRegister'),
  loginEmail: document.getElementById('loginEmail'),
  loginPassword: document.getElementById('loginPassword'),
  regEmail: document.getElementById('regEmail'),
  regUsername: document.getElementById('regUsername'),
  regPassword: document.getElementById('regPassword'),
  btnDoLogin: document.getElementById('btnDoLogin'),
  btnDoRegister: document.getElementById('btnDoRegister'),
  log: document.getElementById('authLog'),
};

function log(msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  els.log.appendChild(node);
  els.log.scrollTop = els.log.scrollHeight;
}

function setTab(isLogin){
  els.tabLogin.classList.toggle('active', isLogin);
  els.tabRegister.classList.toggle('active', !isLogin);
  els.formLogin.style.display = isLogin ? '' : 'none';
  els.formRegister.style.display = isLogin ? 'none' : '';
}

function getRedirect(){
  const url = new URL(location.href);
  return url.searchParams.get('redirect') || '/call';
}

function applyPostLogin(token){
  localStorage.setItem('wc_token', token);
  localStorage.setItem('wc_seen', '1');
  try{ const payload = JSON.parse(atob(token.split('.')[1])); localStorage.setItem('wc_user', payload.sub || ''); }catch{}
  const url = new URL(location.href);
  const redirect = getRedirect();
  const room = url.searchParams.get('room');
  if (room) {
    // поддержим /call/{room}
    if (redirect.startsWith('/call')) {
      location.href = `/call/${encodeURIComponent(room)}`;
      return;
    }
  }
  location.href = redirect;
}

async function doLogin(){
  const email = els.loginEmail.value.trim();
  const password = els.loginPassword.value;
  try{
    const data = await login(email, password);
    applyPostLogin(data.access_token);
  }catch(e){ log(String(e)); }
}

async function doRegister(){
  const email = els.regEmail.value.trim();
  const username = els.regUsername.value.trim();
  const password = els.regPassword.value;
  try{
    await register(email, username, password);
    log('Регистрация успешна. Выполняем вход...');
    const data = await login(email, password);
    applyPostLogin(data.access_token);
  }catch(e){ log(String(e)); }
}

// Инициализация
(function init(){
  const seen = localStorage.getItem('wc_seen') === '1';
  setTab(seen); // если уже были — показываем логин

  els.tabLogin.addEventListener('click', ()=> setTab(true));
  els.tabRegister.addEventListener('click', ()=> setTab(false));
  els.btnDoLogin.addEventListener('click', doLogin);
  els.btnDoRegister.addEventListener('click', doRegister);
})();
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\main.js ---
// main.js - entry
import { buildWs } from './api.js';
import { sendChat, isWsOpen } from './signal.js';
import { WebRTCManager } from './webrtc.js';
import { bind, setText, setEnabled, appendLog, appendChat } from './ui.js';

let token = null;
let ws = null;
let rtc = null;
let outputDeviceId = null;
let userId = null;

const els = {
  roomId: document.getElementById('roomId'),
  btnConnect: document.getElementById('btnConnect'),
  btnLeave: document.getElementById('btnLeave'),
  btnCopyLink: document.getElementById('btnCopyLink'),
  btnSend: document.getElementById('btnSend'),
  chatInput: document.getElementById('chatInput'),
  connStatus: document.getElementById('connStatus'),
  logs: document.getElementById('logs'),
  chat: document.getElementById('chat'),
  btnToggleMic: document.getElementById('btnToggleMic'),
  btnToggleCam: document.getElementById('btnToggleCam'),
  localVideo: document.getElementById('localVideo'),
  remoteVideo: document.getElementById('remoteVideo'),
  peersGrid: document.getElementById('peersGrid'),
  remoteMute: document.getElementById('remoteMute'),
  remoteVolume: document.getElementById('remoteVolume'),
  btnToggleTheme: document.getElementById('btnToggleTheme'),
};

function log(msg){ appendLog(els.logs, msg); }

function setConnectedState(connected){
  setText(els.connStatus, connected ? 'Подключено' : 'Не подключено');
  setEnabled(els.btnSend, connected);
  setEnabled(els.btnLeave, connected);
  setEnabled(els.btnToggleMic, connected);
  setEnabled(els.btnToggleCam, connected);
}

function ensureToken(){
  token = localStorage.getItem('wc_token');
  if (!token){
    const params = new URLSearchParams({ redirect: '/call' });
    if (els.roomId.value) params.set('room', els.roomId.value);
    location.href = `/auth?${params.toString()}`;
    return false;
  }
  try{ userId = JSON.parse(atob(token.split('.')[1])).sub; }catch{}
  return true;
}

async function connect(){
  const roomId = els.roomId.value.trim();
  if (!roomId){ log('Введите Room ID'); return; }
  if (!ensureToken()) return;
  // Закроем предыдущий сокет, если он ещё не закрыт
  try{ if (ws && ws.readyState !== WebSocket.CLOSED) ws.close(); }catch{}
  // Диагностика устройств перед подключением и выбор аудио-выхода
  if (navigator.mediaDevices?.enumerateDevices) {
    try {
      const devs = await navigator.mediaDevices.enumerateDevices();
      const summary = devs.map(d => `${d.kind}:${d.label||'(no label)'}:${(d.deviceId||'').slice(0,6)}`).join(' | ');
      log(`Devices: ${summary}`);
      const outs = devs.filter(d => d.kind === 'audiooutput');
      const concrete = outs.find(d => d.deviceId && !['default','communications'].includes(d.deviceId));
      outputDeviceId = (concrete || outs[0] || {}).deviceId || null;
      if (outputDeviceId) {
        const chosen = concrete || outs.find(d => d.deviceId === outputDeviceId) || {};
        log(`Using audiooutput: ${chosen.label || outputDeviceId}`);
      }
    } catch(e){ log(`enumerateDevices error: ${e?.name||e}`); }
  }
  ws = buildWs(roomId, token);
  ws.onopen = async () => {
    log('WS connected');
    setConnectedState(true);
    rtc = new WebRTCManager({
      localVideo: els.localVideo,
      remoteVideo: null, // мультипир — не используем единый remoteVideo
      outputDeviceId,
      onLog: log,
    });
    if (!userId){
      // dev/test: временный случайный id (для работы без логина)
      userId = crypto.randomUUID();
    }
    try {
      // мультипир: только инициализация локального PC состояния, без немедленного оффера
      await rtc.init(ws, userId);
      // сообщаем о входе для presence
      try{
        if (isWsOpen(ws)) ws.send(JSON.stringify({ type: 'join', fromUserId: userId }));
      }catch(e){ log(`join send failed: ${e?.name||e}`); }
    } catch (e) {
      log(`Ошибка старта WebRTC: ${e?.name || e}`);
    }
  };
  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);
    if (msg.type === 'signal') {
      await rtc?.handleSignal(msg, attachPeerMedia);
    } else if (msg.type === 'chat') {
      const who = msg.authorName || msg.authorId || 'system';
      appendChat(els.chat, who, msg.content || msg.echo || '');
    } else if (msg.type === 'presence') {
      renderPresence(msg.members || []);
    }
  };
  ws.onclose = (ev) => { log(`WS closed (${ev?.code||''} ${ev?.reason||''})`); setConnectedState(false); };
}

function leave(){
  rtc?.close();
  try{ if (isWsOpen(ws)) ws.send(JSON.stringify({ type: 'leave', fromUserId: userId })); }catch{}
  try{ ws?.close(); }catch{}
  setConnectedState(false);
}

function copyLink(){
  const rid = els.roomId.value.trim();
  const pretty = `${location.origin}/call/${encodeURIComponent(rid)}`;
  navigator.clipboard.writeText(pretty);
  log('Ссылка скопирована');
}

function send(){
  const text = els.chatInput.value.trim();
  if (!text) return;
  sendChat(ws, text, userId);
  els.chatInput.value='';
}

function toggleMic(){
  const on = rtc?.toggleMic();
  log(`Микрофон: ${on ? 'вкл' : 'выкл'}`);
}

function toggleCam(){
  const on = rtc?.toggleCam();
  log(`Камера: ${on ? 'вкл' : 'выкл'}`);
}

function restoreFromUrl(){
  const url = new URL(location.href);
  const rid = url.searchParams.get('room');
  if (rid) { els.roomId.value = rid; return; }
  const parts = location.pathname.split('/').filter(Boolean);
  if (parts[0] === 'call' && parts[1]) {
    els.roomId.value = decodeURIComponent(parts[1]);
  }
}

function toggleTheme(){
  document.documentElement.classList.toggle('light');
}

// Presence rendering and media hookups
function renderPresence(members){
  if (!els.peersGrid) return;
  const my = userId;
  const list = members.map(m=> (typeof m === 'string'? {id:m, name:m.slice(0,8)} : m));
  const others = list.filter(x=>x.id!==my);
  const grid = els.peersGrid;
  const existing = new Set(Array.from(grid.querySelectorAll('.peer-tile')).map(n=>n.dataset.peer));
  // Remove tiles of peers no longer present
  for (const peer of existing){
    if (!others.some(o=>o.id===peer)) grid.querySelector(`.peer-tile[data-peer="${peer}"]`)?.remove();
  }
  // Add tiles for new peers
  const tpl = document.getElementById('tpl-peer-tile');
  for (const peer of others){
    if (grid.querySelector(`.peer-tile[data-peer="${peer.id}"]`)) continue;
    const node = tpl.content.firstElementChild.cloneNode(true);
    node.dataset.peer = peer.id;
    node.querySelector('.name').textContent = peer.name || peer.id.slice(0,8);
    const v = node.querySelector('video');
    const bar = node.querySelector('.level-bar>span');
    const volume = node.querySelector('.volume');
    const muteBtn = node.querySelector('.mute');
    const unmuteBtn = node.querySelector('.unmute-btn');
    // Attach media when first track arrives
    attachPeerMedia(peer.id, {
      onTrack: async (stream)=>{
        v.srcObject = stream; node.querySelector('.avatar').style.display='none';
        // попытка воспроизведения; если заблокировано — показать кнопку
        try{
          await v.play();
        }catch{
          unmuteBtn.style.display='block';
        }
      },
      onLevel: (lvl)=>{ if (bar) bar.style.width = `${Math.min(1,Math.max(0,lvl))*100}%`; }
    });
    // Local mute/volume controls
    muteBtn.addEventListener('click', ()=>{ if (v) v.muted = !v.muted; muteBtn.textContent = v.muted? 'Unmute':'Mute'; });
    volume.addEventListener('input', ()=>{ if (v) v.volume = parseFloat(volume.value||'1'); });
    unmuteBtn.addEventListener('click', async ()=>{
      try{ await v.play(); unmuteBtn.style.display='none'; }catch(e){ log(`play failed: ${e?.name||e}`); }
    });
    grid.appendChild(node);

    // Детерминированное правило: инициатор — у кого id строкой меньше
    if (my && peer?.id && my < peer.id) {
      rtc?.startOffer?.(peer.id);
    }
  }
}

// Provide hook to WebRTC manager to connect per-peer media events
function attachPeerMedia(peerId, handlers){
  // Manager will call this when it has media for peer
  rtc?.bindPeerMedia?.(peerId, handlers);
}

// Events
bind(els.btnConnect, 'click', connect);
bind(els.btnLeave, 'click', leave);
bind(els.btnCopyLink, 'click', copyLink);
bind(els.btnSend, 'click', send);
bind(els.btnToggleMic, 'click', toggleMic);
bind(els.btnToggleCam, 'click', toggleCam);
bind(els.btnToggleTheme, 'click', toggleTheme);
els.remoteMute?.addEventListener('change', ()=>{ if (els.remoteVideo) els.remoteVideo.muted = !!els.remoteMute.checked; });
els.remoteVolume?.addEventListener('input', ()=>{ if (els.remoteVideo) els.remoteVideo.volume = parseFloat(els.remoteVolume.value||'1'); });
window.addEventListener('beforeunload', ()=>{ try{ if (isWsOpen(ws)) ws.close(); }catch{} });

// Init
restoreFromUrl();
if (ensureToken()) {
  log('Готово. Введите Room ID и нажмите Подключиться.');
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\signal.js ---
// signal.js — signaling helpers

function isWsOpen(ws) {
  return ws && ws.readyState === WebSocket.OPEN;
}

function _safeSend(ws, obj) {
  if (!isWsOpen(ws)) return false;
  try {
    ws.send(JSON.stringify(obj));
    return true;
  } catch (e) {
    // eslint-disable-next-line no-console
    console.warn("WS send failed:", e);
    return false;
  }
}

/**
 * Отправка сигнального сообщения
 * @param {WebSocket} ws
 * @param {"offer"|"answer"|"ice-candidate"} type
 * @param {object} payload - { sdp } или { candidate }
 * @param {string} fromUserId
 * @param {string=} targetUserId
 */
export function sendSignal(ws, type, payload, fromUserId, targetUserId) {
  const body = { type: "signal", signalType: type, fromUserId, ...payload };
  if (targetUserId) body.targetUserId = targetUserId;
  _safeSend(ws, body);
}

/**
 * Чат
 * @param {WebSocket} ws
 * @param {string} content
 * @param {string} fromUserId
 */
export function sendChat(ws, content, fromUserId) {
  _safeSend(ws, { type: "chat", content, fromUserId });
}

export { isWsOpen };
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\ui.js ---
// ui.js - UI helpers
export function bind(el, event, fn){ el?.addEventListener(event, fn); }

export function setText(el, text){ if (el) el.textContent = text; }
export function setEnabled(el, enabled){ if (el) el.disabled = !enabled; }

export function appendLog(container, msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  container.appendChild(node);
  container.scrollTop = container.scrollHeight;
}

export function appendChat(container, who, text){
  const line = document.createElement('div');
  line.innerHTML = `<strong>${who}:</strong> ${escapeHtml(text)}`;
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc.js ---
// webrtc.js — RTCPeerConnection handling

import { sendSignal } from "./signal.js";
import { getIceServers } from "./api.js";

/**
 * Опции конструктора:
 * {
 *   localVideo: HTMLVideoElement|null,
 *   remoteVideo: HTMLMediaElement (audio или video),
 *   outputDeviceId?: string|null,       // динамики (setSinkId), опционально
 *   unmuteButton?: HTMLButtonElement,   // опционально (для явного включения звука)
 *   onLog?: (msg:string)=>void,
 *   onConnected?: ()=>void,
 *   onDisconnected?: ()=>void,
 * }
 */
export class WebRTCManager {
  constructor(opts) {
  this.localVideo = opts.localVideo || null;
  this.remoteVideo = opts.remoteVideo || null; // в мультипире может быть null
    this.outputDeviceId = opts.outputDeviceId || null;
    this.unmuteButton = opts.unmuteButton || null;

    this.onLog = opts.onLog || (() => {});
  this.onConnected = opts.onConnected || (() => {});
  this.onRemoteAudioLevel = opts.onRemoteAudioLevel || (() => {});
    this.onDisconnected = opts.onDisconnected || (() => {});

    // внутренние флаги
  this.ws = null;
  this.userId = null;
  this.localStream = null;
  // мультипир: per-peer PC and streams
  this.peers = new Map(); // peerId -> { pc, stream, candidates:[], remoteSet: bool, level:{ctx,analyser,raf}, handlers }

    this._remoteSet = false;
    this._candidateQueue = [];
    this._started = false;
    this._playbackArmed = false;
  this._audioCtx = null;
  this._analyser = null;
  this._raf = 0;

    // подготовка media-элемента
  if (this.remoteVideo) {
      this.remoteVideo.autoplay = true;
      this.remoteVideo.playsInline = true;
      this.remoteVideo.muted = false;
      this.remoteVideo.volume = 1.0;
    }

    // кнопка "включить звук", если передали
    if (this.unmuteButton) {
      this.unmuteButton.hidden = true;
      this.unmuteButton.disabled = true;
      this.unmuteButton.addEventListener("click", async () => {
        try {
          // Safari/Chrome: иногда нужен user-gesture для AudioContext
          if (window.AudioContext) {
            const ac = new AudioContext();
            if (ac.state === "suspended") await ac.resume();
          }
          await this.remoteVideo.play();
          this.unmuteButton.hidden = true;
          this.unmuteButton.disabled = true;
        } catch (e) {
          this._log(`Manual unmute failed: ${e?.name || e}`);
        }
      });
    }
  }

  _log(msg) {
    try { this.onLog(msg); } catch { /* noop */ }
  }

  async _setOutputSink(deviceId) {
    if (!this.remoteVideo) return;
    if (typeof this.remoteVideo.setSinkId !== "function") {
      this._log("setSinkId is not supported in this browser");
      return;
    }
    try {
      await this.remoteVideo.setSinkId(deviceId);
      this._log(`Using audiooutput: ${deviceId}`);
    } catch (e) {
      this._log(`setSinkId error: ${e?.name || e}`);
    }
  }

  async getMediaStreamWithFallback() {
    const tryGet = async (constraints) => {
      try {
        return await navigator.mediaDevices.getUserMedia(constraints);
      } catch (e) {
        this._log(`getUserMedia error: ${e?.name || e}`);
        return null;
      }
    };

  // 1) по умолчанию ТОЛЬКО АУДИО (камера выключена)
    this._log("Trying getUserMedia: audio only");
  let stream = await tryGet({
      audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true },
      video: false,
    });
    if (stream) return stream;

  // 2) попытка только видео (если нет микрофона)
    this._log("Trying getUserMedia: video only");
    stream = await tryGet({ audio: false, video: true });
    if (stream) return stream;

    // 4) ничего не удалось
    this._log("Нет доступных устройств. Продолжаем без микрофона/камеры.");
    return null;
  }

  async init(ws, userId) {
    this.ws = ws;
    this.userId = userId;
    if (this.localStream) return; // уже инициализировано медиа

    // ICE servers
    const fallbackIce = { iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] };
    let rtcCfg = fallbackIce;
    try {
      const { iceServers } = await getIceServers();
      rtcCfg = { iceServers };
    } catch {
      rtcCfg = fallbackIce;
    }

    // Локальные медиа
    const stream = await this.getMediaStreamWithFallback();
    this.localStream = stream;
    if (stream) {
      this._log(
        `Local tracks: a=${stream.getAudioTracks().length} v=${stream.getVideoTracks().length}`
      );
      if (this.localVideo) this.localVideo.srcObject = stream;
    }
  }
  // Create or get a RTCPeerConnection for peerId
  async _ensurePeer(peerId) {
    if (this.peers.has(peerId)) return this.peers.get(peerId);
    // ICE servers
    const fallbackIce = { iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }] };
    let rtcCfg = fallbackIce;
    try {
      const { iceServers } = await getIceServers();
      rtcCfg = { iceServers };
    } catch { rtcCfg = fallbackIce; }
    const pc = new RTCPeerConnection({ ...rtcCfg, bundlePolicy: "max-bundle", rtcpMuxPolicy: "require" });
    const state = { pc, stream: new MediaStream(), candidates: [], remoteSet: false, handlers: null, level: { ctx: null, analyser: null, raf: 0 } };
    // add local tracks (if any)
    if (this.localStream) {
      for (const track of this.localStream.getTracks()) pc.addTrack(track, this.localStream);
    } else {
      try { pc.addTransceiver("audio", { direction: "recvonly" }); } catch {}
      try { pc.addTransceiver("video", { direction: "recvonly" }); } catch {}
    }
    pc.addEventListener("icecandidate", (e)=>{
      if (e.candidate) sendSignal(this.ws, "ice-candidate", { candidate: e.candidate }, this.userId, peerId);
    });
    pc.addEventListener("track", (e)=>{
      if (e.track && !state.stream.getTracks().some(t=>t.id===e.track.id)) state.stream.addTrack(e.track);
      // notify UI to attach media
      if (state.handlers?.onTrack) state.handlers.onTrack(state.stream);
      // setup level meter for this peer audio
      if (e.track?.kind === 'audio') this._setupPeerLevel(peerId, state);
    });
    pc.addEventListener("connectionstatechange", ()=>{
      this._log(`PC(${peerId}) state: ${pc.connectionState}`);
    });
    pc.addEventListener("iceconnectionstatechange", ()=>{
      this._log(`ICE(${peerId}) state: ${pc.iceConnectionState}`);
    });
    pc.addEventListener("icegatheringstatechange", ()=>{
      this._log(`ICE(${peerId}) gathering: ${pc.iceGatheringState}`);
    });
    this.peers.set(peerId, state);
    return state;
  }

  async handleSignal(msg, mediaBinder) {
    // Никогда не обрабатываем собственные сигналы
    if (msg?.fromUserId && this.userId && msg.fromUserId === this.userId) return;
    // Если сервер передаёт адресата, а он не совпадает с нами — игнорируем
    if (msg?.targetUserId && this.userId && msg.targetUserId !== this.userId) return;
    const peerId = msg.fromUserId;
    const peer = await this._ensurePeer(peerId);
    if (mediaBinder && !peer.handlers) {
      // allow UI to attach media handlers
      peer.handlers = {};
      mediaBinder(peerId, {
        onTrack: (stream)=>{ /* UI will override this via binder; set placeholder */ },
        onLevel: ()=>{}
      });
    }

    if (msg.signalType === "offer") {
      await this.init(this.ws, this.userId);
      const offer = { type: "offer", sdp: msg.sdp };

      // защита от эха собственного оффера (на всякий случай)
      if (peer.pc.localDescription?.type === "offer" &&
          peer.pc.localDescription?.sdp === msg.sdp) {
        this._log("Self-offer echo ignored");
        return;
      }

      // glare-handling: если не stable, откатываем локальный оффер
      if (peer.pc.signalingState !== "stable") {
        try { await peer.pc.setLocalDescription({ type: "rollback" }); }
        catch (e) { this._log(`rollback failed: ${e?.name || e}`); }
      }

      // повторно не применяем тот же самый remote
      if (peer.pc.currentRemoteDescription?.sdp === msg.sdp) {
        this._log("Duplicate offer ignored");
        return;
      }

      try {
        await peer.pc.setRemoteDescription(offer);
      } catch(e) {
        this._log(`setRemoteDescription(offer)[${peerId}] failed in state ${peer.pc.signalingState}: ${e?.name||e}`);
        return;
      }
      peer.remoteSet = true;
      await this._flushQueuedCandidates(peerId);

      const answer = await peer.pc.createAnswer();
      await peer.pc.setLocalDescription(answer);
      sendSignal(this.ws, "answer", { sdp: answer.sdp }, this.userId, peerId);

    } else if (msg.signalType === "answer") {
      if (!peer?.pc) return;

      if (peer.pc.signalingState !== "have-local-offer") {
        this._log(`Ignore answer[${peerId}] in state ${peer.pc.signalingState}`);
        return;
      }

      if (peer.pc.currentRemoteDescription?.type === "answer") {
        this._log("Duplicate answer ignored");
        return;
      }

      try {
        await peer.pc.setRemoteDescription({ type: "answer", sdp: msg.sdp });
      } catch(e) {
        this._log(`setRemoteDescription(answer)[${peerId}] failed in state ${peer.pc.signalingState}: ${e?.name||e}`);
        return;
      }
      peer.remoteSet = true;
      await this._flushQueuedCandidates(peerId);

  } else if (msg.signalType === "ice-candidate") {
      if (!peer.remoteSet) {
        peer.candidates.push(msg.candidate);
      } else if (peer.pc) {
        try { await peer.pc.addIceCandidate(msg.candidate); }
        catch (e) { this._log(`addIceCandidate[${peerId}] failed: ${e?.name || e}`); }
      }
    }
  }

  async _flushQueuedCandidates(peerId) {
    const peer = this.peers.get(peerId);
    if (!peer?.pc) return;
    while (peer.candidates.length) {
      const c = peer.candidates.shift();
      try { await peer.pc.addIceCandidate(c); }
      catch (e) { this._log(`flush ICE[${peerId}] failed: ${e?.name || e}`); }
    }
  }

  // Proactively start an offer to a peer
  async startOffer(peerId){
    await this.init(this.ws, this.userId);
    const st = await this._ensurePeer(peerId);
    const pc = st.pc;
    // idempotent: only if stable and no current local offer
    if (pc.signalingState !== 'stable') {
      this._log(`Skip startOffer(${peerId}) in state ${pc.signalingState}`);
      return;
    }
    try{
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      sendSignal(this.ws, 'offer', { sdp: offer.sdp }, this.userId, peerId);
    }catch(e){ this._log(`startOffer(${peerId}) failed: ${e?.name||e}`); }
  }

  isPeerEstablished(peerId){
    const st = this.peers.get(peerId);
    if (!st) return false;
    const s = st.pc.connectionState;
    return s === 'connected' || s === 'completed';
  }

  toggleMic() {
    if (!this.localStream) return false;
    const track = this.localStream.getAudioTracks()[0];
    if (!track) return false;
    track.enabled = !track.enabled;
    return track.enabled;
  }

  toggleCam() {
    if (!this.localStream) return false;
    let track = this.localStream.getVideoTracks()[0];
    if (!track) {
      // Ленивая инициализация камеры
      navigator.mediaDevices.getUserMedia({ video: true, audio: false }).then((camStream) => {
        const [videoTrack] = camStream.getVideoTracks();
        if (!videoTrack) return false;
        // добавить в локальный стрим
        this.localStream.addTrack(videoTrack);
        if (this.localVideo) {
          const s = this.localVideo.srcObject instanceof MediaStream ? this.localVideo.srcObject : new MediaStream();
          s.addTrack(videoTrack);
          this.localVideo.srcObject = s;
        }
        // добавить sender во все PC
        for (const { pc } of this.peers.values()) {
          try { pc.addTrack(videoTrack, this.localStream); } catch {}
        }
      }).catch((e)=>{
        this._log(`Camera init failed: ${e?.name||e}`);
      });
      return true;
    }
    track.enabled = !track.enabled;
    return track.enabled;
  }

  async close() {
    try { this.ws?.close(); } catch {}
    this.ws = null;
    for (const [pid, st] of this.peers) {
      try { st.pc?.close(); } catch {}
      if (st.level?.raf) cancelAnimationFrame(st.level.raf);
      if (st.level?.ctx) try{ st.level.ctx.close(); }catch{}
    }
    this.peers.clear();
    if (this.localStream) this.localStream.getTracks().forEach(t=>t.stop());
    this.localStream = null;
  }

  _armPlaybackOnGesture() {
    if (this._playbackArmed) return;
    this._playbackArmed = true;

    // Подсказка пользователю
    this._log("Нажмите в окно, чтобы включить звук (браузер блокирует автоплеи).");
    if (this.unmuteButton) {
      this.unmuteButton.hidden = false;
      this.unmuteButton.disabled = false;
    }

    const resume = async () => {
      try {
        if (window.AudioContext) {
          const ac = new AudioContext();
          if (ac.state === "suspended") await ac.resume();
        }
        await this.remoteVideo.play();
        if (this.unmuteButton) {
          this.unmuteButton.hidden = true;
          this.unmuteButton.disabled = true;
        }
      } catch {
        // пусть кнопка остаётся
      } finally {
        window.removeEventListener("click", resume);
        window.removeEventListener("keydown", resume);
        window.removeEventListener("touchstart", resume);
        this._playbackArmed = false;
      }
    };

    window.addEventListener("click", resume, { once: true });
    window.addEventListener("keydown", resume, { once: true });
    window.addEventListener("touchstart", resume, { once: true });
  }

  _setupPeerLevel(peerId, state){
    try{
      if (!state.stream || !state.stream.getAudioTracks().length) return;
      if (!window.AudioContext) return;
      if (!state.level.ctx) state.level.ctx = new AudioContext();
      const src = state.level.ctx.createMediaStreamSource(state.stream);
      state.level.analyser = state.level.ctx.createAnalyser();
      state.level.analyser.fftSize = 256;
      src.connect(state.level.analyser);
      const data = new Uint8Array(state.level.analyser.frequencyBinCount);
      const loop = ()=>{
        state.level.analyser.getByteTimeDomainData(data);
        let sum = 0; for (let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum += v*v; }
        const rms = Math.sqrt(sum/data.length);
        if (state.handlers?.onLevel) state.handlers.onLevel(rms);
        state.level.raf = requestAnimationFrame(loop);
      };
      if (state.level.raf) cancelAnimationFrame(state.level.raf);
      state.level.raf = requestAnimationFrame(loop);
    }catch(e){ this._log(`level meter[${peerId}] error: ${e?.name||e}`); }
  }

  // Allow UI to bind media handlers for a peer
  bindPeerMedia(peerId, handlers){
    const st = this.peers.get(peerId);
    if (st) st.handlers = handlers;
  }
}
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\rooms.py ---
from __future__ import annotations

import asyncio
import json
from typing import Any
from collections import defaultdict
import contextlib
from uuid import UUID, uuid5, NAMESPACE_URL

from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect
from ...infrastructure.config import get_settings

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus, TokenProvider
from ...core.ports.repositories import UserRepository
from ..api.deps.containers import get_signal_bus, get_token_provider, get_user_repo
from ...infrastructure.messaging.redis_bus import RedisSignalBus  # for type-check to enable Redis chat broadcast

router = APIRouter()

# In-process registry of room connections for chat broadcast (dev/test)
_room_clients: dict[UUID, set[WebSocket]] = defaultdict(set)
_ws_user: dict[WebSocket, UUID] = {}
_room_members: dict[UUID, set[UUID]] = defaultdict(set)
_user_names: dict[UUID, str] = {}


@router.websocket("/ws/rooms/{room_id}")
async def ws_room(
    websocket: WebSocket,
    room_id: str,
    bus: SignalBus = Depends(get_signal_bus),
    tokens: TokenProvider = Depends(get_token_provider),
    users: UserRepository = Depends(get_user_repo),
):  # type: ignore[override]
    settings = get_settings()
    token = websocket.query_params.get("token")
    allow_unauth = settings.APP_ENV in {"dev", "test"}
    if token:
        try:
            tokens.decode_token(token)
        except Exception:
            if not allow_unauth:
                await websocket.close(code=4401)
                return
    else:
        if not allow_unauth:
            await websocket.close(code=4401)
            return
    await websocket.accept()
    # Поддержка человекочитаемых room_id: если не UUID, маппим в стабильный UUID v5
    try:
        room_uuid = UUID(room_id)
    except Exception:
        room_uuid = uuid5(NAMESPACE_URL, f"webcall:{room_id}")

    async def sender():
        async for signal in bus.subscribe(room_uuid):
            await websocket.send_json(
                {
                    "type": "signal",
                    "fromUserId": str(signal.sender_id),
                    "signalType": signal.type.value,
                    "sdp": signal.sdp,
                    "candidate": signal.candidate,
                    # передаём target для клиентской фильтрации (если задан)
                    "targetUserId": str(signal.target_id) if getattr(signal, "target_id", None) else None,
                }
            )

    send_task = asyncio.create_task(sender())
    # If Redis is used, also subscribe to chat channel to receive messages from other processes
    chat_task: asyncio.Task | None = None
    chat_channel = f"room:{room_uuid}:chat"
    if isinstance(bus, RedisSignalBus):
        async def chat_listener() -> None:
            pubsub = bus.redis.pubsub()
            await pubsub.subscribe(chat_channel)
            try:
                async for msg in pubsub.listen():
                    if msg.get("type") != "message":
                        continue
                    try:
                        data = json.loads(msg["data"])  # type: ignore[arg-type]
                    except Exception:
                        continue
                    await websocket.send_json({
                        "type": "chat",
                        "authorId": data.get("authorId"),
                        "authorName": data.get("authorName"),
                        "content": data.get("content")
                    })
            finally:
                with contextlib.suppress(Exception):
                    await pubsub.unsubscribe(chat_channel)
                    await pubsub.close()

        chat_task = asyncio.create_task(chat_listener())
    # register connection in room for chat broadcast
    _room_clients[room_uuid].add(websocket)

    try:
        while True:
            msg = await websocket.receive_text()
            data: dict[str, Any] = json.loads(msg)
            if data.get("type") == "signal":
                s = Signal.create(
                    type=data.get("signalType"),
                    sender_id=UUID(data.get("fromUserId")),
                    room_id=room_uuid,
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["targetUserId"]) if data.get("targetUserId") else None,
                )
                await bus.publish(room_uuid, s)
            elif data.get("type") == "join":
                # Register user presence
                try:
                    uid = UUID(data.get("fromUserId"))
                except Exception:
                    # if invalid id, skip presence for this socket
                    continue
                _ws_user[websocket] = uid
                _room_members[room_uuid].add(uid)
                # try resolve username (optional)
                try:
                    u = await users.get_by_id(uid)
                    if u:
                        _user_names[uid] = u.username
                except Exception:
                    # fallback leave name unset; will be derived from uuid
                    pass
                # broadcast presence list to room
                members = []
                for u in sorted(_room_members[room_uuid], key=str):
                    name = _user_names.get(u) or str(u)[:8]
                    members.append({"id": str(u), "name": name})
                for ws in list(_room_clients.get(room_uuid, set())):
                    with contextlib.suppress(Exception):
                        await ws.send_json({"type": "presence", "members": members})
            elif data.get("type") == "leave":
                break
            elif data.get("type") == "chat":
                # Broadcast chat to all participants in room (including sender)
                content = data.get("content")
                author = data.get("fromUserId")
                author_name: str | None = None
                # Попробуем получить имя пользователя по его UUID, если он передан
                try:
                    if author:
                        u = await users.get_by_id(UUID(author))
                        if u:
                            author_name = u.username
                except Exception:
                    # Не прерываем чат при ошибке, просто не заполним имя
                    pass
                if isinstance(bus, RedisSignalBus):
                    # Publish to Redis channel so all processes deliver the message
                    await bus.redis.publish(chat_channel, json.dumps({
                        "authorId": author,
                        "authorName": author_name,
                        "content": content
                    }))
                else:
                    # In-process fallback (dev/test)
                    payload = {"type": "chat", "authorId": author, "authorName": author_name, "content": content}
                    # Backward compat for older UIs relying on 'echo'
                    payload_with_echo = {**payload, "echo": content}
                    dead: list[WebSocket] = []
                    for ws in list(_room_clients.get(room_uuid, set())):
                        try:
                            await ws.send_json(payload_with_echo)
                        except Exception:
                            dead.append(ws)
                    # cleanup dead connections
                    for ws in dead:
                        with contextlib.suppress(KeyError):
                            _room_clients[room_uuid].remove(ws)
            else:
                await websocket.send_json({"type": "error", "message": "Unknown message"})
    except WebSocketDisconnect:
        pass
    finally:
        send_task.cancel()
        if chat_task:
            chat_task.cancel()
        # В Python 3.11 CancelledError наследуется от BaseException — подавляем явно
        with contextlib.suppress(asyncio.CancelledError):
            await send_task
        if chat_task:
            with contextlib.suppress(asyncio.CancelledError):
                await chat_task
        # unregister connection
        with contextlib.suppress(KeyError):
            _room_clients[room_uuid].remove(websocket)
        # presence cleanup and broadcast
        uid = _ws_user.pop(websocket, None)
        if uid is not None:
            with contextlib.suppress(KeyError):
                _room_members[room_uuid].remove(uid)
            # cleanup username mapping if user no longer present in any room instance
            if uid not in _room_members.get(room_uuid, set()):
                with contextlib.suppress(KeyError):
                    _user_names.pop(uid)
            members = []
            for u in sorted(_room_members[room_uuid], key=str):
                name = _user_names.get(u) or str(u)[:8]
                members.append({"id": str(u), "name": name})
            for ws in list(_room_clients.get(room_uuid, set())):
                with contextlib.suppress(Exception):
                    await ws.send_json({"type": "presence", "members": members})
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\create_superuser.py ---
import asyncio
from uuid import UUID

from app.infrastructure.db.session import AsyncSessionLocal
from app.infrastructure.db.repositories.users import PgUserRepository
from app.infrastructure.security.password_hasher import BcryptPasswordHasher


async def main():
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        users = PgUserRepository(session)
        hasher = BcryptPasswordHasher()
        # minimal example: ensure user exists
        from app.core.domain.models import User

        u = User.create("admin@example.com", "admin", hasher.hash("admin"))
        await users.add(u)
        print("Created:", u.id)


if __name__ == "__main__":
    asyncio.run(main())
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\wait_for_db.py ---
# app/scripts/wait_for_db.py
from __future__ import annotations

import asyncio
import os
import sys

import asyncpg


def _to_asyncpg_dsn(url: str) -> str:
    """
    Convert SQLAlchemy async URL (postgresql+asyncpg://...) to asyncpg-compatible DSN.
    """
    if url.startswith("postgresql+asyncpg://"):
        return "postgresql://" + url[len("postgresql+asyncpg://") :]
    return url


async def main() -> None:
    # Берём URL из окружения (как в .env). Фолбэк — только для локалки.
    env_url = os.getenv(
        "DATABASE_URL",
        "postgresql+asyncpg://webcall:secret@postgres:5432/webcall",
    )
    dsn = _to_asyncpg_dsn(env_url)

    # Подождём до 60 сек, печатая причину (чтобы было видно в логах почему ждём)
    last_err: Exception | None = None
    for attempt in range(60):
        try:
            conn = await asyncpg.connect(dsn)
            await conn.close()
            print("db ready")
            return
        except Exception as e:
            last_err = e
            print(f"[wait_for_db] attempt {attempt+1}/60: {e!r}")
            await asyncio.sleep(1)

    print("[wait_for_db] database is not ready, aborting", file=sys.stderr)
    if last_err:
        print(f"[wait_for_db] last error: {last_err!r}", file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\conftest.py ---
import asyncio
import os
import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.fixture(scope="session")
def anyio_backend():
    return 'asyncio'


@pytest.fixture()
async def client():
    # httpx>=0.27: pass ASGITransport instead of deprecated app= argument
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_auth.py ---
import pytest


@pytest.mark.asyncio
async def test_dummy_auth():
    assert True
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_rooms.py ---
import pytest


@pytest.mark.asyncio
async def test_dummy_rooms():
    assert True
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_ws_basic.py ---
import asyncio
import json

import pytest
from starlette.testclient import TestClient

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_ws_basic():
    client = TestClient(app)
    with client.websocket_connect("/ws/rooms/00000000-0000-0000-0000-000000000001") as ws:
        ws.send_json({"type": "chat", "content": "hi"})
        msg = ws.receive_json()
        assert msg["type"] == "chat"
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.Dockerfile ---
# syntax=docker/dockerfile:1
FROM python:3.11-slim AS base

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=on \
    PYTHONPATH=/app

WORKDIR /app

# System deps
RUN apt-get update && apt-get install -y --no-install-recommends build-essential libpq-dev curl && rm -rf /var/lib/apt/lists/*

# Install Poetry
ENV POETRY_HOME=/opt/poetry \
    POETRY_VERSION=1.8.3
ENV PATH="$POETRY_HOME/bin:$PATH"
RUN curl -sSL https://install.python-poetry.org | python3 - && poetry --version

# Copy project files
COPY pyproject.toml README.md ./
RUN poetry config virtualenvs.create false \
    && poetry install --no-interaction --no-ansi --with dev

COPY . .

EXPOSE 8000

CMD ["uvicorn", "app.bootstrap.asgi:app", "--host", "0.0.0.0", "--port", "8000"]
.
--- C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_health.py ---
import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_healthz():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
        r = await client.get("/healthz")
        assert r.status_code == 200
        assert r.json() == {"status": "ok"}

=== Dump finished: 05.09.2025 17:22:38,14
