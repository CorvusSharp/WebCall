Project root: C:\Users\Ярослав\Проекты\webcall\WebCall

===== DIRECTORY TREE (filtered) =====
./
    .github\workflows
  .vscode
  docker
  tests
  webcall
    webcall\aiosqlite
    webcall\alembic
      webcall\alembic\versions
    webcall\app
      webcall\app\application
        webcall\app\application\dto
        webcall\app\application\use_cases
      webcall\app\bootstrap
      webcall\app\core
        webcall\app\core\domain
        webcall\app\core\ports
        webcall\app\core\services
      webcall\app\infrastructure
        webcall\app\infrastructure\db
          webcall\app\infrastructure\db\repositories
        webcall\app\infrastructure\ice
        webcall\app\infrastructure\messaging
        webcall\app\infrastructure\rate_limit
        webcall\app\infrastructure\security
        webcall\app\infrastructure\services
          webcall\app\infrastructure\services\summary_v2
      webcall\app\presentation
        webcall\app\presentation\api
          webcall\app\presentation\api\deps
          webcall\app\presentation\api\routers
        webcall\app\presentation\schemas
        webcall\app\presentation\static
          webcall\app\presentation\static\js
            webcall\app\presentation\static\js\__tests__
            webcall\app\presentation\static\js\modules
              webcall\app\presentation\static\js\modules\core
              webcall\app\presentation\static\js\modules\voice
            webcall\app\presentation\static\js\webrtc
              webcall\app\presentation\static\js\webrtc\strategies
        webcall\app\presentation\ws
      webcall\app\scripts
      webcall\app\tests
      webcall\app\tests_e2e
    webcall\docker
    webcall\monitoring
        webcall\monitoring\grafana\dashboards
        webcall\monitoring\grafana\datasources
    webcall\scripts
      webcall\scripts\legacy
    webcall\tests

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitattributes =====
--- SIZE: 66 bytes ---

# Auto detect text files and perform LF normalization
* text=auto

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitattributes =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.github\workflows\security.yml =====
--- SIZE: 2461 bytes ---

name: Security Scans

on:
  push:
    branches: [main]
  pull_request:

# Глобальные права для загрузки SARIF
permissions:
  contents: read
  security-events: write

concurrency:
  group: security-${{ github.ref }}
  cancel-in-progress: false

jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Semgrep: генерим SARIF (через args ок)
      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: p/ci
          args: --sarif --output=semgrep.sarif
        env:
          SEMGREP_DISABLE_VERSION_CHECK: "1"

      - name: Ensure semgrep.sarif exists
        if: always()
        run: |
          test -s semgrep.sarif || echo '{"version":"2.1.0","runs":[]}' > semgrep.sarif

      # Защита: если PR из форка — пропускаем загрузку SARIF (нет прав)
      - name: Upload SARIF
        if: >
          always() &&
          (github.event_name != 'pull_request' ||
           github.event.pull_request.head.repo.full_name == github.repository)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
          category: semgrep

  bandit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip

      - name: Install bandit + sarif formatter
        run: pip install --upgrade pip && pip install bandit bandit-sarif-formatter

      - name: Run bandit (JSON)
        run: |
          # скорректируй путь, если надо
          bandit -r webcall/app -x webcall/app/alembic -f json -o bandit.json || true

      - name: Convert to SARIF
        run: bandit-sarif-formatter -i bandit.json -o bandit.sarif || true

      - name: Ensure bandit.sarif exists
        if: always()
        run: |
          test -s bandit.sarif || echo '{"version":"2.1.0","runs":[]}' > bandit.sarif

      - name: Upload SARIF
        if: >
          always() &&
          (github.event_name != 'pull_request' ||
           github.event.pull_request.head.repo.full_name == github.repository)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: bandit.sarif
          category: bandit

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.github\workflows\security.yml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitignore =====
--- SIZE: 20 bytes ---

webcall/.env
.env

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitignore =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.vscode\settings.json =====
--- SIZE: 387 bytes ---

{
    "python.testing.unittestArgs": [
        "-v",
        "-s",
        "./webcall",
        "-p",
        "*test.py"
    ],
    "python.testing.pytestEnabled": false,
    "python.testing.unittestEnabled": true,
    "cSpell.words": [
        "звонков",
        "Синхронизируем",
        "состояние",
        "упрощённая"
    ]
}
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.vscode\settings.json =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\CALL_FIXES_README.md =====
--- SIZE: 32797 bytes ---

# Исправления проблем со звонками

## Обнаруженные проблемы

### 1. **Звонящий не видит статус звонка**

**Проблема**: В функции `startOutgoingCall` в `calls_signaling.js` состояние устанавливалось в `outgoing_invite` сразу, но когда приходило WebSocket сообщение `call_invite` от сервера, обработчик проверял `if (state.phase === 'idle')`, что уже было неверно.

**Код с ошибкой**:
```javascript
// В startOutgoingCall:
setState({ phase:'outgoing_invite', roomId: room, otherUserId: friend.user_id, otherUsername: friend.username });

// В handleWsMessage:
} else if (isMine){
  if (state.phase==='idle'){ // ❌ Это условие никогда не выполнялось!
    setState({ phase:'outgoing_invite', roomId: msg.roomId, otherUserId: msg.toUserId, otherUsername: msg.toUsername });
  }
}
```

### 2. **Рассинхронизация между старым и новым слоями звонков**

**Проблема**: 
- `friends_ui.js` использует `getActiveCall()` из старого `calls.js` (состояние в `appState.activeCall`)
- Новая система `calls_signaling.js` использует локальную переменную `state`
- Эти состояния не синхронизировались, поэтому UI не отображал правильное состояние

### 3. **Отсутствие обратной связи при ошибках**

**Проблема**: Если friends WebSocket не готов или API возвращает ошибку, пользователь не получал никаких уведомлений.

## Примененные исправления

### 1. Исправление обработки `call_invite` для звонящего

**Файл**: `calls_signaling.js`

```javascript
// Добавили обработку case когда состояние уже outgoing_invite
} else if (isMine){
  if (state.phase==='idle'){
    setState({ phase:'outgoing_invite', roomId: msg.roomId, otherUserId: msg.toUserId, otherUsername: msg.toUsername });
  } else if (state.phase==='outgoing_invite' && state.roomId === msg.roomId){
    // ✅ Обновляем информацию о получателе, когда приходит подтверждение от сервера
    setState({ otherUsername: msg.toUsername });
  }
}
```

### 2. Исправление логики инициации звонка

**Файл**: `calls_signaling.js`

```javascript
// Убрали преждевременную установку состояния
notifyCall(friend.user_id, room).then(()=> {
  dbg('notifyCall ok');
  // ✅ Устанавливаем состояние только после успешного API вызова
  if (state.phase === 'idle') {
    setState({ phase:'outgoing_invite', roomId: room, otherUserId: friend.user_id, otherUsername: friend.username });
  }
}).catch(e=> {
  dbg('notifyCall error', e);
  // ✅ Показываем ошибку пользователю
  try {
    if (window.showToast) {
    }
  } catch {}
});
```

### 3. Добавление синхронизации между слоями

**Файл**: `calls_signaling.js`

```javascript
// Добавили синхронизацию с legacy calls.js
function setState(patch){
  // ... existing code ...
  
  // ✅ Синхронизируем с legacy calls.js для совместимости UI
  try {
    syncWithLegacyCalls(state, prev);
  } catch (e) {
    dbg('legacy sync error', e);
  }
  
  emit();
}

// ✅ Функция синхронизации состояний
async function syncWithLegacyCalls(currentState, prevState) {
  if (typeof window === 'undefined' || !window.appState) return;
  
  try {
    const { setActiveOutgoingCall, setActiveIncomingCall, markCallAccepted, markCallDeclined, resetActiveCall } = await import('./calls.js');
    
    if (currentState.phase === 'outgoing_invite' && prevState.phase !== 'outgoing_invite' && currentState.otherUserId && currentState.roomId) {
      setActiveOutgoingCall(
        { user_id: currentState.otherUserId, username: currentState.otherUsername }, 
        currentState.roomId
      );
    } else if (currentState.phase === 'incoming_invite' && prevState.phase !== 'incoming_invite' && currentState.otherUserId && currentState.roomId) {
      setActiveIncomingCall(currentState.otherUserId, currentState.otherUsername, currentState.roomId);
    } else if (currentState.phase === 'active' && prevState.phase !== 'active' && currentState.roomId) {
      markCallAccepted(currentState.roomId);
    } else if (currentState.phase === 'ended' && prevState.phase !== 'ended' && currentState.roomId) {
      markCallDeclined(currentState.roomId);
    } else if (currentState.phase === 'idle' && prevState.phase !== 'idle') {
      resetActiveCall('idle');
    }
  } catch (e) {
    // Игнорируем ошибки import для совместимости
  }
}
```

### 4. Улучшение обратной связи

**Файл**: `calls_signaling.js`

```javascript
// Улучшили сообщение когда WebSocket не готов
if (!ws || ws.readyState !== WebSocket.OPEN){
  dbg('friends WS not ready, abort startOutgoingCall');
  try { window.__CALL_DEBUG && window.__CALL_DEBUG.push({ ts:Date.now(), warn:'friends_ws_not_ready' }); } catch {}
  
  // ✅ Показываем уведомление пользователю
  try {
    if (typeof window !== 'undefined' && window.showToast) {
      window.showToast('Подключение не готово. Попробуйте позже.', 'warning');
    } else {
      alert('Подключение не готово. Попробуйте позже.');
    }
  } catch {}
  return false;
}
```

**Файл**: `app_init.js`

```javascript
// ✅ Сделали showToast доступной глобально
try { window.showToast = showToast; } catch {}
```

## Диагностика проблем

### Сообщение "Подключение не готово. Попробуйте позже."

Это сообщение появляется когда WebSocket соединение для друзей не готово. Причины:

1. **Нет токена авторизации** - нужно войти в систему
2. **WebSocket не создан** - проблема с инициализацией
3. **WebSocket в состоянии CONNECTING** - соединение устанавливается
4. **WebSocket закрыт** - проблема с сервером или сетью
5. **Цикл переподключений** - WebSocket постоянно подключается и отключается (исправлено в v2)

### Сообщение "Устанавливается соединение. Попробуйте через несколько секунд."

Это улучшенное сообщение означает, что система попытается восстановить соединение автоматически.

### Диагностика через консоль браузера

Выполните в консоли браузера:
```javascript
window.debugWebSocket()
```

Или более подробную диагностику:
```javascript
// Скопируйте и выполните содержимое файла debug_websocket.js
```

### Возможные решения

1. **Обновите страницу** - перезапустится WebSocket подключение
2. **Проверьте авторизацию** - выйдите и войдите заново
3. **Проверьте консоль** - ищите ошибки WebSocket
4. **Принудительное переподключение**:
   ```javascript
   window.appState.friendsWs = null;
   window.startFriendsWs();
   ```

## Тестирование

Для тестирования исправлений создан файл `test_call_fixes.html`, который можно открыть в браузере для проверки:

1. Исходящие звонки теперь правильно обрабатываются 
2. Входящие звонки работают корректно
3. Ошибки WebSocket подключения показывают уведомления
4. Состояния синхронизируются между новым и старым слоями

## Ожидаемый результат

После применения исправлений:

1. ✅ **Звонящий видит статус звонка** - состояние правильно обновляется при получении подтверждения от сервера
2. ✅ **Получатель получает уведомления о звонке** - входящие звонки обрабатываются корректно  
3. ✅ **UI отображает правильное состояние** - синхронизация между слоями работает
4. ✅ **Пользователь получает обратную связь об ошибках** - показываются уведомления при проблемах

## Исправления v2 (проблема бесконечных переподключений)

### Обнаруженная проблема
Из серверных логов видно, что WebSocket соединения постоянно открываются и сразу закрываются, создавая бесконечный цикл переподключений:

```
INFO: connection open
INFO: connection closed
WS_REPLACE user=... old_ws=... new_ws=...
```

Также появилась ошибка "Устанавливается соединение. Попробуйте через несколько секунд" при попытках звонков.

### Примененные исправления v2

1. **Предотвращение множественных подключений** - добавлен флаг `friendsWsConnecting`
2. **Ограничение попыток переподключения** - максимум 10 попыток
3. **Увеличение интервалов переподключения** - от 5 до 30 секунд с экспоненциальным ростом
4. **Улучшенная логика onclose** - не переподключаться при нормальном закрытии или скрытой странице
5. **Обработчик beforeunload** - предотвращение переподключений при закрытии страницы


### Дополнительные проблемы
- Флаг `friendsWsConnecting` иногда не сбрасывался, блокируя звонки
- Отсутствовал таймаут для подключений, что могло приводить к зависанию
- Недостаточно информативные сообщения об ошибках
### Примененные исправления v3

1. **Улучшенная логика состояний WebSocket**:
   - Проверка активности соединения перед созданием нового
   - Принудительное закрытие старых соединений
   - Таймаут подключения (10 секунд) с автоматическим сбросом флагов

2. **Исправление обработчиков ошибок**:
   - Упрощена логика onerror - не создает дополнительных переподключений
   - Корректное освобождение ресурсов при ошибках
   - Отмена автоматических ретраев при ошибках создания соединения

3. **Улучшенная проверка готовности в calls_signaling.js**:
   - Учет состояния `friendsWsConnecting` при проверке готовности
   - Более информативные сообщения пользователю
   - Предотвращение повторных попыток переподключения

4. **Расширенная диагностика**:
   - `window.debugWebSocket()` - детальная информация о состоянии
   - `window.debugCalls()` - полная системная диагностика
   - `window.forceReconnectWebSocket()` - безопасное переподключение

### Новые функции диагностики

- `window.debugWebSocket()` - показывает состояние соединения и счетчик попыток
- `window.debugCalls()` - полная диагностика системы звонков
- `window.forceReconnectWebSocket()` - принудительное переподключение с сбросом счетчика
- `websocket_debug_v2.html` - расширенная диагностическая страница

## Измененные файлы

1. `webcall/app/presentation/static/js/modules/calls_signaling.js` - **v3**: улучшенная логика проверки готовности WebSocket, учет состояния подключения
2. `webcall/app/presentation/static/js/modules/core/app_init.js` - **v3**: полная переработка логики WebSocket с таймаутами, корректным управлением состояниями и расширенной диагностикой
3. `webcall/app/presentation/static/test_call_fixes.html` - тестовая страница (новый файл)
4. `webcall/app/presentation/static/debug_websocket.js` - скрипт диагностики WebSocket (новый файл)
5. `webcall/app/presentation/static/websocket_test.html` - базовый тест WebSocket подключения (новый файл)
6. `webcall/app/presentation/static/reconnection_test.html` - тест логики переподключений (новый файл)
7. `webcall/app/presentation/static/websocket_debug_v2.html` - **НОВЫЙ**: расширенная диагностическая страница с автоматическими тестами

Добавлены улучшения диагностики и UX для списка друзей и поиска пользователей:

1. Расширенные сообщения об ошибках в `friends_ui.js` при загрузке друзей и заявок: показывается `Ошибка загрузки: <деталь>` вместо общего слова.
2. В `api.js` функции `listFriends`, `listFriendRequests`, `findUsers` теперь формируют человеко-понятные тексты ошибок (401 → «Не авторизован», 422 → «некорректный запрос» и т.д.).
3. Поиск отображает: `Поиск...`, затем либо результаты, либо `Ничего не найдено`, либо конкретную причину ошибки (`Ошибка поиска: <деталь>` / `Неверный ответ сервера`).
4. Консольные предупреждения (`console.warn`) помогают оперативно увидеть формат ответов backend при аномалиях.
5. Улучшена устойчивость к неожиданному формату ответа (проверка `Array.isArray`).

Как диагностировать:
* Откройте DevTools → Network. Убедитесь, что `/api/v1/friends/` и `/api/v1/friends/requests` возвращают 200.
* При 401: истёк токен — выполните повторный вход, проверьте `localStorage.wc_token`.
* При 422 на поиске: длина запроса меньше минимальной (валидируется backend). Увеличьте запрос.
* Вкладка Console: ищите префикс `[friends_ui]` для технических подробностей.

Идеи на будущее (пока не реализованы):
* Debounce поиска (300–400мс) + отмена предыдущего запроса.
* Кнопка «Повторить» при сетевой ошибке.
* Авто-logout при повторном 401.
* Пагинация друзей / lazy load.

---

### Edge-case: 400 Username must be 3-32 chars

Если backend отвечает 400 (detail: `Username must be 3-32 chars [A-Za-z0-9_.-]`) на запросы `/api/v1/friends/` или `/api/v1/friends/requests`, причина в том, что при сборке DTO дергается доменный value object `Username`, а в таблице `users` есть записи с невалидным username.

Проверка: 
```sql
SELECT id, username FROM users WHERE username !~ '^[A-Za-z0-9_.-]{3,32}$';
```

Варианты решения:
1. Миграция: нормализовать (`LOWER`, заменить пробелы на `_`, обрезать до 32, удалить запрещённые символы) и обновить.
2. Временный ручной фикс проблемных записей через UPDATE.
3. (Опционально) внедрить fallback при чтении: если regex не проходит — подставлять `user_<первые8символов id>` (пока не реализовано, чтобы явно подсветить несоответствия).

UI теперь показывает кнопку «Исправить профиль», ведущую на `profile.html`, если ловит эту ошибку при загрузке друзей.

Рекомендация: выполнить миграцию до продакшена, чтобы не держать невалидные данные.

---

### Возможности
1. Кнопки медиа с иконками: `🎥 Камера`, `🖥 Экран`. Активное состояние подсвечено классом `.btn-media-active`.
2. Мини-индикатор `🖥 Экран шарится` поверх локального превью при активном screen share.
3. Горячая смена устройства камеры без renegotiation: селект камеры вызывает `switchCamera()` если активна камера.
4. Ограничения качества:
  - Камера: 1280x720 @ ~24fps (max 30)
  - Экран: 15fps
  Определяются через объект `videoConstraints` в `webrtc.js`.
5. Колбэк состояния видео `onVideoState(kind, track)` обновляет UI (badge, активные кнопки, видимость локальной карточки).
6. Автовозврат к камере после завершения демонстрации экрана (если возможно), иначе полное отключение видео.

### Использование
— Включить/выключить камеру: кнопка `🎥 Камера`.
— Начать/остановить шаринг: кнопка `🖥 Экран` (во время трансляции текст меняется на `🛑 Остановить`).
— Сменить камеру: выбрать устройство в селекте — трек подменяется через `RTCRtpSender.replaceTrack` без разрыва соединений.

### Технические детали
— При смене источника прежние `MediaStreamTrack` останавливаются для экономии ресурсов.
— Badge адаптируется под тему (зелёная / красная палитра).
— Локальная карточка скрывается при отсутствии активного видеоконтента.
— Screen share использует отдельный stream, но трек маппится в общий `localStream` для унификации.

### Потенциальные улучшения (TODO)
— Одновременное отображение камеры (PiP) вместе с экраном.
— Динамическая адаптация fps при высокой потере пакетов.
— UI индикатор текущей частоты кадров / разрешения.

### Fullscreen и фиксы локального видео
Добавлено:
 - Кнопки ⛶ для разворачивания как локального, так и любого peer видео на весь экран (Fullscreen API).
 - Делегирование событий в `app_init.js` (по `data-action="fullscreen"`).
 - Класс `.fullscreen-active` (обводка активного контейнера).
 - Принудительные `video.play()` вызовы после установки `srcObject` (и обработчик `loadedmetadata`) — снижает риск черного экрана при строгих autoplay политиках браузера.
 - Если элемент уже в fullscreen и нажать кнопку снова — выход из полноэкранного режима.

Причина проблемы «черный экран»: в ряде случаев браузер откладывает воспроизведение до gesture или требуется явный `play()`. Теперь это компенсировано.

## Страницы профиля и смены пароля (новые)

Добавлены страницы управления учётной записью:

- `profile.html` — изменение Email и имени пользователя.
  - Запрос: `GET /api/v1/auth/me` для автозаполнения полей.
  - Сохранение: `PATCH /api/v1/auth/me` (частичное — можно отправлять только email или username).
  - LocalStorage синхронизация (`wc_email`, `wc_username`) обновляет бейдж в шапке.
  - Ошибки: 400 (валидация), 409 (конфликт), 401 (нет авторизации).

- `password.html` — смена пароля в отдельной странице.
  - Поля: текущий, новый, подтверждение нового.
  - Запрос: `POST /api/v1/auth/me/password` (ответ `{ "status": "ok" }`).
  - Ошибка 400: «Старый пароль неверен или новый некорректен».

Навигация:
 - Из главной через панель настроек → «Изменить данные».
 - С `profile.html` переход на смену пароля и обратно.
 - На `password.html` ссылки назад: главная и профиль.

Backend детали:
 - `PgUserRepository.update_profile` и `update_password` коммитят транзакции, возвращают актуальные данные.
 - Эндпоинт смены пароля изменён на `200 OK` вместо `204`, чтобы избежать `AssertionError` FastAPI о теле ответа.

Идеи на будущее:
 - Подтверждение email при изменении.
 - Аватар / загрузка изображения.
 - История смен пароля или журнал входов.

## Одновременная трансляция камеры и экрана + очистка последнего кадра

Проблемы (до фикса):
* Включение демонстрации экрана заменяло камеру — нельзя транслировать оба потока.
* После остановки видеопотока оставался «замороженный» последний кадр локально.
* Нельзя было переключить окно/вкладку без полного выключения screen share.

Решения:
1. Введены отдельные сущности `_cameraTrack/_cameraSender` и `_screenTrack/_screenSender`.
2. Разрешено существование двух активных видеотреков (камера + экран); приоритет отображения в локальном превью — экран.
3. `stopCamera()` и `stopScreenShare()` останавливают/отвязывают только соответствующий трек, legacy `stopVideo()` выключает оба.
4. Очищается превью при отсутствии активных треков (`video.srcObject=null; video.load()`), убирая последний кадр.
5. `switchScreenShareWindow()` выполняет повторный `getDisplayMedia` и `replaceTrack`, позволяя сменить окно без разрыва.
6. `_currentVideoKind`: `none | camera | screen | multi` — при двух треках устанавливается `multi` (для UI/статуса).
7. Автоматическая renegotiation остаётся через `negotiationneeded`; при необходимости fallback форс-оффер также покрывает второй видеотрек.

API обновления (WebRTCManager):
* `startCamera() / stopCamera()`
* `startScreenShare() / stopScreenShare()`
* `switchScreenShareWindow()`
* `toggleCameraStream()` / `toggleScreenShare()` (поведение обновлено под новую модель)

Визуализация локального превью:
* Отдельный комбинированный поток не микшируется (для упрощения). В будущем возможен Canvas микшер для PiP камеры над экраном.

Edge cases:
* Ограничение браузера по количеству одновременных видео-сендов: тогда второй трек может потребовать renegotiation с удалением первого.
* Safari иногда задерживает `negotiationneeded` — компенсируется уже существующим таймерным форсом.

Планы на улучшения:
* Canvas-композиция (экран + миникамера) без второго RTP потока.
* Динамический bitrate adaptation: снижение fps камеры при активном screen share.
* UI-индикатор «multi» состояния и отдельные кнопки отключения каждого канала.

## Расширения (PiP, Adaptive, Multi Badges, Canvas Mix)

### Что добавлено сверх ранее описанного
1. Два одновременных видеотрека отправляются параллельно (камера + экран) с отдельными `RTCRtpSender` (`_cameraSender`, `_screenSender`).
2. PiP (картинка‑в‑картинке) UX:
  - Локально: при `multi` состояние на карточке появляется badge `🎥+🖥` и отдельные кнопки `✖︎ Кам` / `✖︎ Экран`.
  - Удалённо: плитка участника содержит стек из основного видео (`peer-main`) и PiP наложения (`peer-pip`). Эвристика: экран определяется по `label` (`screen|display|share`).
3. Adaptive понижение качества камеры при активном screen share: метод `_adaptVideoQualities()` снижает камеру до ~960x540 @12fps, возвращает исходные constraints после остановки экрана.
4. Кнопки мгновенной остановки отдельных источников (`stopCamera()`, `stopScreenShare()`).
5. Индикатор `multi` вместо двух отдельных badge, если активны оба трека.
6. Canvas-композиция (опционально): локальный скрытый `<canvas id="localCompositeCanvas">` рисует экран + камеру (PiP) единым кадром. Включается кнопкой `🧩 Mix` при состоянии `multi`.

### Canvas Mix (архитектура)
* Не отправляет композицию в сеть: это только локальный визуальный слой для пользователя.
* Метод `enableComposite(canvas)` запускает рендер‑петлю `_runCompositeLoop()`.
* Приоритет: фон = экран, PiP = камера (22% ширины, 16:9, с белой рамкой) в правом нижнем углу.
* Автоматическое отключение композиции, если исчезли оба трека.

### API дополняющие
```
// webrtc.js
enableComposite(canvas: HTMLCanvasElement)
disableComposite()
toggleComposite(canvas?)
```

### UI / Состояния
| State | local badge | Кнопка Mix | Поведение превью |
|-------|-------------|------------|------------------|
| none  | скрыто      | скрыта     | нет видео        |
| camera| скрыто      | скрыта     | камера           |
| screen| 🖥 badge    | скрыта     | экран            |
| multi | 🎥+🖥 badge  | показана   | экран (основное) + кнопки stop | 

### Ограничения и соображения
* Safari: может игнорировать часть `applyConstraints`; деградация камеры необязательна, но попытка безопасна.
* Дополнительный второй RTP поток увеличивает uplink; Canvas Mix может служить основой для будущего режима «один поток наружу» (нужен `canvas.captureStream()`). Пока не активировано осознанно, чтобы не ломать текущие peer соединения.
* При переключении окна шаринга `switchScreenShareWindow()` сохраняет камеру без мигания.

### Возможные следующие шаги
* Добавить настройку «Отправлять один композиционный поток вместо двух» (замена senders на `canvas.captureStream()` + отключение `_screenTrack/_cameraTrack`).
* Динамический выбор позиции PiP (drag & drop + сохранение в localStorage).
* Отображение текущих фактических параметров (реальное разрешение, fps) через `getStats()`.

## Shortcuts & Metrics

Горячие клавиши (когда фокус не в поле ввода):
* `m` — toggle микрофон
* `c` — toggle камера
* `s` — toggle демонстрация экрана
* `x` — принудительно остановить экран
* `k` — принудительно остановить камеру
* `Shift+M` (буква `M`) — включить/выключить локальную Canvas композицию (кнопка `🧩 Mix`)

Оверлей метрик (`#localVideoMetrics`):
* Показывает текущее состояние (`camera|screen|multi`) + `width x height @fps`.
* Обновление 1 раз в секунду через `track.getSettings()`.
* Автоматически скрывается при отсутствии видеотреков.



===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\CALL_FIXES_README.md =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\README.md =====
--- SIZE: 15669 bytes ---

docker compose exec api alembic upgrade head
﻿# WebCall

Минималистичная платформа для аудио/WebRTC звонков и чата: FastAPI + WebSocket сигналинг, PostgreSQL, Redis, STUN/TURN, модульный frontend (vanilla ES modules).

## Основные возможности
- Регистрация / вход (JWT + секрет регистрации)
- Комнаты и многопользовательский WebRTC сигналинг
- Чат комнат + личные (direct) сообщения
- E2EE (клиентские ключи) + хранение публичных ключей
- Push уведомления (WebPush) для инвайтов / сообщений
- Управление участниками (роли, mute)
- Простая SPA (`/static`) без зависимостей фреймворков

## Архитектурные слои
```
presentation/  (REST, WS, схемы, статические файлы)
application/   (use-cases, DTO)
core/          (доменные модели, value objects, порты, ошибки)
infrastructure/(DB репозитории, Redis, security, messaging, services)
bootstrap/     (инициализация FastAPI, middleware, статик)
```
Принципы: зависимость направлена внутрь (presentation -> application -> core), infrastructure реализует порты core.

## Недавние технические улучшения
- Введение Value Object `Username` (валидация: 3-32 символа `[A-Za-z0-9_.-]`).
- Перенос проверки владельца комнаты в use-case `DeleteRoom` (чистая бизнес-логика, router стал тоньше).
- Observability middleware: `X-Request-ID`, Server-Timing, структурированные логи с латентностью.
- Prometheus метрики: `/metrics` (счётчик и гистограмма запросов).
- Простой in-memory rate limiting для `auth/register`, `auth/login`, `rooms` (создание).
- Рефактор спец-рингтона: переезд файла в `static/media/special_ringtone.mp3` + fallback.
- Housekeeping: `dump.bat` перемещён в `scripts/legacy/`.
- Добавлен `@ts-check` + JSDoc типы в модулях фронтенда (статический анализ без TS-транспиляции).
- Mypy усилен (строже конфиг), добавлен pre-commit hook; Value Objects типизированы.

## Безопасность / Hardening (сделано)
- SQL: параметризация через SQLAlchemy, helper `safe_like`, лимиты на `IN()`.
- XSS: отказ от небезопасных `innerHTML` для пользовательского контента.
- Headers: CSP (временно с `'unsafe-inline'`), HSTS (prod), X-Content-Type-Options, X-Frame-Options, Referrer-Policy.
- Auth: JWT + обязательный `REGISTRATION_SECRET`.
- Пароли: bcrypt (passlib).
- Rate limiting на чувствительных эндпоинтах (in-memory).
- Логирование: request id, латентность, унифицированный формат (готово к интеграции с ELK/Tempo).

## Следующие шаги (roadmap)
1. Ужесточить CSP — убрать `'unsafe-inline'`, вынеся inline скрипты.
2. Добавить semgrep / bandit в CI.
3. Redis/Cluster rate limit (горизонтальное масштабирование).
4. Redis-бэкенд для CallInviteService / очередь уведомлений.
5. E2E тесты WebRTC сигналинга (smoke) + нагрузочные сценарии.
6. Экспорт метрик в Grafana / Alerting (SLO latency, error rate).

## Запуск (локально)
```powershell
cp .env.example .env
docker compose up -d --build
docker compose exec api alembic upgrade head
```
Либо через poetry:
```powershell
poetry install
poetry run alembic upgrade head
poetry run uvicorn app.bootstrap.asgi:app --reload
```

Frontend (esbuild):
```powershell
cd webcall
npm ci
npm run build
```

Тесты:
```powershell
pytest -q
```

## Переменные окружения (ключевые)
`APP_ENV`, `PORT`, `JWT_SECRET`, `REGISTRATION_SECRET`, `DATABASE_URL`, `REDIS_URL`, `STUN_SERVERS`, `TURN_URLS`, `TURN_USERNAME`, `TURN_PASSWORD`, `CORS_ORIGINS`.

### Дополнительно (AI summary / Telegram)
| Переменная | Назначение | По умолчанию |
|------------|------------|--------------|
| `AI_SUMMARY_ENABLED` | Включает генерацию выжимки чата комнаты при завершении | `False` |
| `AI_MODEL_PROVIDER` | Идентификатор провайдера/модели (зарезервировано) | `None` |
| `AI_SUMMARY_MAX_MESSAGES` | Лимит сообщений, удерживаемых для суммаризации | `200` |
| `AI_SUMMARY_MIN_CHARS` | Минимальное суммарное количество символов содержимого (без обвязки) для вызова внешнего AI; если меньше — формируется короткий fallback без полноценной AI выжимки | `60` |
| `TELEGRAM_BOT_TOKEN` | Токен бота для отправки выжимок | `None` |
| `TELEGRAM_CHAT_ID` | (DEPRECATED) Глобальный чат / канал / пользователь. Используется только как fallback если у инициатора нет персональной привязки | `None` |
| `OPENAI_API_KEY` | Ключ OpenAI для генерации выжимки | `None` |
| `AI_MODEL_FALLBACK` | Запасная модель если основная недоступна | `None` |

Механика (ручной триггер):

1. Сообщения чата (`type=chat`) и расщеплённый на предложения голосовой транскрипт (если включён voice capture) буферизуются в памяти.
2. Автоматическая генерация при уходе участников отключена.
3. Первый клик по кнопке «AI Agent» — подключает агент-присутствие и начинает поток голосовых чанков во `voice_capture` WebSocket.
4. Второй клик — останавливает запись, закрывает вспомогательные WS и через ~650 мс отправляет в основной room WebSocket сообщение `{"type":"agent_summary"}`.
5. Сервер по получении `agent_summary` собирает итог (voice > chat) и, если заданы Telegram переменные, отправляет отчёт (однократно per room).
6. Если общий объём контента < `AI_SUMMARY_MIN_CHARS`, внешний AI не вызывается — возвращается эвристический fallback с пометкой о короткой сессии.
7. При ручном триггере сервер ожидает до ~6 секунд готовности транскрипта (poll каждые 300мс) перед формированием отчёта. Если за это время транскрипт не появился и нет сообщений чата — результат пуст и можно повторить попытку (agent_summary снова).

Пример настройки для OpenAI:
```
AI_SUMMARY_ENABLED=true
AI_MODEL_PROVIDER=openai:gpt-4o-mini
OPENAI_API_KEY=sk-...  # НЕ коммитить в репозиторий
AI_MODEL_FALLBACK=gpt-4o-mini
```

## Персональная привязка Telegram

Реализована таблица `telegram_links` для привязки пользователя к своему `chat_id`.

Флоу:
1. Клиент запрашивает `POST /api/v1/telegram/link` — сервер возвращает токен и deep-link вида `https://t.me/<BOT>?start=<token>`.
2. Пользователь переходит по ссылке, бот получает `/start <token>` и отправляет webhook `POST /api/v1/telegram/webhook`.
3. Сервер помечает ссылку `status=confirmed`, сохраняет `chat_id`.
4. Клиент периодически опрашивает `GET /api/v1/telegram/status` пока `confirmed`.

### Отвязка Telegram

Если пользователь хочет отключить получение AI выжимок в Telegram:

1. Нажимает кнопку "Отвязать Telegram" в настройках (иконка шестерёнки в интерфейсе).
2. Клиент вызывает `DELETE /api/v1/telegram/link`.
3. Сервер помечает все `confirmed` записи пользователя как `revoked`.
4. Статус `GET /api/v1/telegram/status` вернётся `absent`. Для повторной привязки нужно снова пройти процедуру `/link` → `/start <token>`.

Это позволяет безопасно переключать устройства или отключать доставку отчётов.

## Кастомный AI System Prompt

По умолчанию для генерации итоговой выжимки используется системный prompt:

```
Ты ассистент, делающий краткую структурированную выжимку группового чата: 1) Основные темы 2) Принятые решения 3) Открытые вопросы. Пиши лаконично на русском, без лишних вступлений.
```

Пользователь может задать собственный prompt через API или UI:

* `GET  /api/v1/ai/prompt` — получить текущий (если кастом не задан, возвращается дефолт и `is_default=true`).
* `PUT  /api/v1/ai/prompt` — сохранить новый (`{"prompt": "..."}`), длина 10..4000.
* `DELETE /api/v1/ai/prompt` — сброс к стандартному.

Во фронтенде в панели настроек доступно поле редактирования prompt с кнопками "Сохранить" и "Сброс". Если ввести дефолтный текст без изменений — он не дублируется в БД (поле очищается).

При генерации summary (OpenAI провайдер) если инициатор ручного триггера имеет кастомный prompt — он используется как system message вместо дефолта.

## Настройка TURN (coturn)

Если в логах coturn появляется ошибка вида:

```
ERROR: session ... check_stun_auth: Cannot find credentials of user <webcall>
```

Причины и решение:

1. Клиент (браузер / WebRTC) использует long-term auth и шлёт `username=webcall`, но сервер не знает пользователя.
2. В исходной версии конфиг `turnserver.conf` содержал плейсхолдеры `${TURN_USERNAME}` и др. — coturn НЕ подставляет переменные окружения внутри файла.

Актуальная схема:

* В `docker-compose.yml` параметры пробрасываются через команду запуска: `--realm=... --user=USERNAME:PASSWORD --external-ip=...`.
* Файл `turnserver.conf` содержит только статические опции (порты/флаги).

Проверь, что переменные окружения заданы в `.env`:

```
TURN_REALM=example.com
TURN_USERNAME=webcall
TURN_PASSWORD=strongsecret
TURN_PUBLIC_IP=YOUR_PUBLIC_IP
TURN_CLI_PASSWORD=adminpass
```

И что клиент действительно использует те же `username`/`credential`. Если используется динамическая авторизация — нужно реализовать REST API или `userdb`, но для простоты сейчас применяется статический пользователь.

5. При ручном триггере AI summary сервер отправляет отчёт ТОЛЬКО инициатору (его `chat_id`). Если привязки нет — пытается отправить всем подтверждённым (глобальный broadcast) или, в качестве устаревшего fallback, в `TELEGRAM_CHAT_ID`.

## Миграции / устранение multiple heads

Если при запуске контейнера возникает ошибка Alembic `Multiple head revisions are present`, причины:
- В БД остались ссылки на ревизии, которых больше нет в каталоге `alembic/versions`.
- Либо ранее существовал merge-point.

Решение (без потери данных):
1. Определить фактическое состояние таблиц (сравнить со схемой последней миграции).
2. Войти в контейнер: `docker compose exec api bash` (или `sh`).
3. Получить текущие ревизии: `alembic history --verbose | tail -n 40` и `alembic current -v` (если падает из-за multiple heads — перейти к ручному штампу).
4. Открыть `psql` и посмотреть содержимое `alembic_version`: `SELECT * FROM alembic_version;` (может быть несколько строк при split head scenario).
5. Сделать резервную копию (опционально): `pg_dump -U webcall -d webcall > /tmp/backup.sql`.
6. Проставить единый штамп на последнюю существующую ревизию из кода (например `0006_telegram_links`):
	- Удалить лишние строки: `DELETE FROM alembic_version;`
	- Вставить одну: `INSERT INTO alembic_version (version_num) VALUES ('0006_telegram_links');`
7. Запустить `alembic upgrade head` — он теперь ничего не применит (schema already up-to-date) и не будет жаловаться.

Если схема в БД не соответствует миграциям (рассинхронизация), используйте:
1. `alembic downgrade base` (если безопасно потерять данные) → затем `alembic upgrade head`.
2. Либо вручную примените недостающие изменения и затем `alembic stamp <revision>`.

Checklist после фикса:
- `alembic current` показывает одну ревизию.
- `alembic heads` == `alembic current`.
- Приложение стартует без ошибки.

Примечание: глобальный noop stub миграции удалён, цепочка линейная 0001 → 0006.


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\README.md =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\conftest.py =====
--- SIZE: 672 bytes ---

import os, sys

def _early_path():
    ROOT = os.path.abspath(os.path.dirname(__file__))
    PKG_ROOT = os.path.join(ROOT, 'webcall')
    if PKG_ROOT not in sys.path:
        sys.path.insert(0, PKG_ROOT)
_early_path()

# Provide minimal required env vars so Settings() doesn't fail in tests
os.environ.setdefault('JWT_SECRET', 'test-jwt-secret')
os.environ.setdefault('REGISTRATION_SECRET', 'test-registration')
os.environ.setdefault('DATABASE_URL', 'sqlite+aiosqlite:///:memory:')
os.environ.setdefault('REDIS_URL', 'redis://localhost:6379/0')

def pytest_configure():  # noqa: D401
    # Re-assert path very early in pytest lifecycle
    _early_path()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\conftest.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\docker\nginx_security.conf =====
--- SIZE: 2602 bytes ---

# nginx security snippet for reversing proxying the WebCall app
# Place this file in your nginx conf and include it in the server block.
# Example: include /etc/nginx/conf.d/webcall_security.conf;

# Always add these headers
add_header X-Content-Type-Options "nosniff" always;
add_header X-Frame-Options "DENY" always;
add_header Referrer-Policy "no-referrer" always;
add_header X-XSS-Protection "1; mode=block" always;

# HSTS: enable only when serving over HTTPS
# The following line enforces HTTPS for one year and includes subdomains
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

# Content-Security-Policy: conservative default
# WARNING: this is a starting point. You should tailor CSP to your app (move inline scripts to files or use nonces)
# For example, to allow only scripts from own origin and disallow inline scripts:
# add_header Content-Security-Policy "default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self'; connect-src 'self' wss:; img-src 'self' data:; style-src 'self' 'unsafe-inline'" always;

add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; connect-src 'self' wss:; img-src 'self' data:; style-src 'self' 'unsafe-inline'" always;

# Deny access to sensitive files
location ~* (?:\.|\b)(?:env|git|htpasswd|docker-compose\.yml)$ {
    deny all;
    return 404;
}

# Also deny access to hidden files and directories (starting with .)
location ~ (^|/)[.] {
    deny all;
    return 404;
}

# Recommended: add a location for static files with efficient caching
location /static/ {
    alias /app/app/presentation/static/; # adjust to your container static path
    tcp_nopush on;
    sendfile on;
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    add_header Cache-Control "public, max-age=31536000, immutable";
}

# Proxy pass to uvicorn/gunicorn upstream
location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # WebSocket support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;

    proxy_pass http://127.0.0.1:8000; # change to your upstream
}

# small helper for Connection header when proxying WebSockets
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\docker\nginx_security.conf =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\dump.txt =====
--- SIZE: 58509 bytes ---

﻿Project root: C:\Users\Ярослав\Проекты\webcall\WebCall

===== DIRECTORY TREE (filtered) =====
./
    .github\workflows
  .vscode
  docker
  tests
  webcall
    webcall\aiosqlite
    webcall\alembic
      webcall\alembic\versions
    webcall\app
      webcall\app\application
        webcall\app\application\dto
        webcall\app\application\use_cases
      webcall\app\bootstrap
      webcall\app\core
        webcall\app\core\domain
        webcall\app\core\ports
        webcall\app\core\services
      webcall\app\infrastructure
        webcall\app\infrastructure\db
          webcall\app\infrastructure\db\repositories
        webcall\app\infrastructure\ice
        webcall\app\infrastructure\messaging
        webcall\app\infrastructure\rate_limit
        webcall\app\infrastructure\security
        webcall\app\infrastructure\services
          webcall\app\infrastructure\services\summary_v2
      webcall\app\presentation
        webcall\app\presentation\api
          webcall\app\presentation\api\deps
          webcall\app\presentation\api\routers
        webcall\app\presentation\schemas
        webcall\app\presentation\static
          webcall\app\presentation\static\js
            webcall\app\presentation\static\js\__tests__
            webcall\app\presentation\static\js\modules
              webcall\app\presentation\static\js\modules\core
              webcall\app\presentation\static\js\modules\voice
            webcall\app\presentation\static\js\webrtc
              webcall\app\presentation\static\js\webrtc\strategies
        webcall\app\presentation\ws
      webcall\app\scripts
      webcall\app\tests
      webcall\app\tests_e2e
    webcall\docker
    webcall\monitoring
        webcall\monitoring\grafana\dashboards
        webcall\monitoring\grafana\datasources
    webcall\scripts
      webcall\scripts\legacy
    webcall\tests

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitattributes =====
--- SIZE: 66 bytes ---

# Auto detect text files and perform LF normalization
* text=auto

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitattributes =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.github\workflows\security.yml =====
--- SIZE: 2461 bytes ---

name: Security Scans

on:
  push:
    branches: [main]
  pull_request:

# Глобальные права для загрузки SARIF
permissions:
  contents: read
  security-events: write

concurrency:
  group: security-${{ github.ref }}
  cancel-in-progress: false

jobs:
  semgrep:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Semgrep: генерим SARIF (через args ок)
      - name: Run Semgrep
        uses: returntocorp/semgrep-action@v1
        with:
          config: p/ci
          args: --sarif --output=semgrep.sarif
        env:
          SEMGREP_DISABLE_VERSION_CHECK: "1"

      - name: Ensure semgrep.sarif exists
        if: always()
        run: |
          test -s semgrep.sarif || echo '{"version":"2.1.0","runs":[]}' > semgrep.sarif

      # Защита: если PR из форка — пропускаем загрузку SARIF (нет прав)
      - name: Upload SARIF
        if: >
          always() &&
          (github.event_name != 'pull_request' ||
           github.event.pull_request.head.repo.full_name == github.repository)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep.sarif
          category: semgrep

  bandit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip

      - name: Install bandit + sarif formatter
        run: pip install --upgrade pip && pip install bandit bandit-sarif-formatter

      - name: Run bandit (JSON)
        run: |
          # скорректируй путь, если надо
          bandit -r webcall/app -x webcall/app/alembic -f json -o bandit.json || true

      - name: Convert to SARIF
        run: bandit-sarif-formatter -i bandit.json -o bandit.sarif || true

      - name: Ensure bandit.sarif exists
        if: always()
        run: |
          test -s bandit.sarif || echo '{"version":"2.1.0","runs":[]}' > bandit.sarif

      - name: Upload SARIF
        if: >
          always() &&
          (github.event_name != 'pull_request' ||
           github.event.pull_request.head.repo.full_name == github.repository)
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: bandit.sarif
          category: bandit

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.github\workflows\security.yml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitignore =====
--- SIZE: 20 bytes ---

webcall/.env
.env

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.gitignore =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.vscode\settings.json =====
--- SIZE: 387 bytes ---

{
    "python.testing.unittestArgs": [
        "-v",
        "-s",
        "./webcall",
        "-p",
        "*test.py"
    ],
    "python.testing.pytestEnabled": false,
    "python.testing.unittestEnabled": true,
    "cSpell.words": [
        "звонков",
        "Синхронизируем",
        "состояние",
        "упрощённая"
    ]
}
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\.vscode\settings.json =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\CALL_FIXES_README.md =====
--- SIZE: 32797 bytes ---

# Исправления проблем со звонками

## Обнаруженные проблемы

### 1. **Звонящий не видит статус звонка**

**Проблема**: В функции `startOutgoingCall` в `calls_signaling.js` состояние устанавливалось в `outgoing_invite` сразу, но когда приходило WebSocket сообщение `call_invite` от сервера, обработчик проверял `if (state.phase === 'idle')`, что уже было неверно.

**Код с ошибкой**:
```javascript
// В startOutgoingCall:
setState({ phase:'outgoing_invite', roomId: room, otherUserId: friend.user_id, otherUsername: friend.username });

// В handleWsMessage:
} else if (isMine){
  if (state.phase==='idle'){ // ❌ Это условие никогда не выполнялось!
    setState({ phase:'outgoing_invite', roomId: msg.roomId, otherUserId: msg.toUserId, otherUsername: msg.toUsername });
  }
}
```

### 2. **Рассинхронизация между старым и новым слоями звонков**

**Проблема**: 
- `friends_ui.js` использует `getActiveCall()` из старого `calls.js` (состояние в `appState.activeCall`)
- Новая система `calls_signaling.js` использует локальную переменную `state`
- Эти состояния не синхронизировались, поэтому UI не отображал правильное состояние

### 3. **Отсутствие обратной связи при ошибках**

**Проблема**: Если friends WebSocket не готов или API возвращает ошибку, пользователь не получал никаких уведомлений.

## Примененные исправления

### 1. Исправление обработки `call_invite` для звонящего

**Файл**: `calls_signaling.js`

```javascript
// Добавили обработку case когда состояние уже outgoing_invite
} else if (isMine){
  if (state.phase==='idle'){
    setState({ phase:'outgoing_invite', roomId: msg.roomId, otherUserId: msg.toUserId, otherUsername: msg.toUsername });
  } else if (state.phase==='outgoing_invite' && state.roomId === msg.roomId){
    // ✅ Обновляем информацию о получателе, когда приходит подтверждение от сервера
    setState({ otherUsername: msg.toUsername });
  }
}
```

### 2. Исправление логики инициации звонка

**Файл**: `calls_signaling.js`

```javascript
// Убрали преждевременную установку состояния
notifyCall(friend.user_id, room).then(()=> {
  dbg('notifyCall ok');
  // ✅ Устанавливаем состояние только после успешного API вызова
  if (state.phase === 'idle') {
    setState({ phase:'outgoing_invite', roomId: room, otherUserId: friend.user_id, otherUsername: friend.username });
  }
}).catch(e=> {
  dbg('notifyCall error', e);
  // ✅ Показываем ошибку пользователю
  try {
    if (window.showToast) {
    }
  } catch {}
});
```

### 3. Добавление синхронизации между слоями

**Файл**: `calls_signaling.js`

```javascript
// Добавили синхронизацию с legacy calls.js
function setState(patch){
  // ... existing code ...
  
  // ✅ Синхронизируем с legacy calls.js для совместимости UI
  try {
    syncWithLegacyCalls(state, prev);
  } catch (e) {
    dbg('legacy sync error', e);
  }
  
  emit();
}

// ✅ Функция синхронизации состояний
async function syncWithLegacyCalls(currentState, prevState) {
  if (typeof window === 'undefined' || !window.appState) return;
  
  try {
    const { setActiveOutgoingCall, setActiveIncomingCall, markCallAccepted, markCallDeclined, resetActiveCall } = await import('./calls.js');
    
    if (currentState.phase === 'outgoing_invite' && prevState.phase !== 'outgoing_invite' && currentState.otherUserId && currentState.roomId) {
      setActiveOutgoingCall(
        { user_id: currentState.otherUserId, username: currentState.otherUsername }, 
        currentState.roomId
      );
    } else if (currentState.phase === 'incoming_invite' && prevState.phase !== 'incoming_invite' && currentState.otherUserId && currentState.roomId) {
      setActiveIncomingCall(currentState.otherUserId, currentState.otherUsername, currentState.roomId);
    } else if (currentState.phase === 'active' && prevState.phase !== 'active' && currentState.roomId) {
      markCallAccepted(currentState.roomId);
    } else if (currentState.phase === 'ended' && prevState.phase !== 'ended' && currentState.roomId) {
      markCallDeclined(currentState.roomId);
    } else if (currentState.phase === 'idle' && prevState.phase !== 'idle') {
      resetActiveCall('idle');
    }
  } catch (e) {
    // Игнорируем ошибки import для совместимости
  }
}
```

### 4. Улучшение обратной связи

**Файл**: `calls_signaling.js`

```javascript
// Улучшили сообщение когда WebSocket не готов
if (!ws || ws.readyState !== WebSocket.OPEN){
  dbg('friends WS not ready, abort startOutgoingCall');
  try { window.__CALL_DEBUG && window.__CALL_DEBUG.push({ ts:Date.now(), warn:'friends_ws_not_ready' }); } catch {}
  
  // ✅ Показываем уведомление пользователю
  try {
    if (typeof window !== 'undefined' && window.showToast) {
      window.showToast('Подключение не готово. Попробуйте позже.', 'warning');
    } else {
      alert('Подключение не готово. Попробуйте позже.');
    }
  } catch {}
  return false;
}
```

**Файл**: `app_init.js`

```javascript
// ✅ Сделали showToast доступной глобально
try { window.showToast = showToast; } catch {}
```

## Диагностика проблем

### Сообщение "Подключение не готово. Попробуйте позже."

Это сообщение появляется когда WebSocket соединение для друзей не готово. Причины:

1. **Нет токена авторизации** - нужно войти в систему
2. **WebSocket не создан** - проблема с инициализацией
3. **WebSocket в состоянии CONNECTING** - соединение устанавливается
4. **WebSocket закрыт** - проблема с сервером или сетью
5. **Цикл переподключений** - WebSocket постоянно подключается и отключается (исправлено в v2)

### Сообщение "Устанавливается соединение. Попробуйте через несколько секунд."

Это улучшенное сообщение означает, что система попытается восстановить соединение автоматически.

### Диагностика через консоль браузера

Выполните в консоли браузера:
```javascript
window.debugWebSocket()
```

Или более подробную диагностику:
```javascript
// Скопируйте и выполните содержимое файла debug_websocket.js
```

### Возможные решения

1. **Обновите страницу** - перезапустится WebSocket подключение
2. **Проверьте авторизацию** - выйдите и войдите заново
3. **Проверьте консоль** - ищите ошибки WebSocket
4. **Принудительное переподключение**:
   ```javascript
   window.appState.friendsWs = null;
   window.startFriendsWs();
   ```

## Тестирование

Для тестирования исправлений создан файл `test_call_fixes.html`, который можно открыть в браузере для проверки:

1. Исходящие звонки теперь правильно обрабатываются 
2. Входящие звонки работают корректно
3. Ошибки WebSocket подключения показывают уведомления
4. Состояния синхронизируются между новым и старым слоями

## Ожидаемый результат

После применения исправлений:

1. ✅ **Звонящий видит статус звонка** - состояние правильно обновляется при получении подтверждения от сервера
2. ✅ **Получатель получает уведомления о звонке** - входящие звонки обрабатываются корректно  
3. ✅ **UI отображает правильное состояние** - синхронизация между слоями работает
4. ✅ **Пользователь получает обратную связь об ошибках** - показываются уведомления при проблемах

## Исправления v2 (проблема бесконечных переподключений)

### Обнаруженная проблема
Из серверных логов видно, что WebSocket соединения постоянно открываются и сразу закрываются, создавая бесконечный цикл переподключений:

```
INFO: connection open
INFO: connection closed
WS_REPLACE user=... old_ws=... new_ws=...
```

Также появилась ошибка "Устанавливается соединение. Попробуйте через несколько секунд" при попытках звонков.

### Примененные исправления v2

1. **Предотвращение множественных подключений** - добавлен флаг `friendsWsConnecting`
2. **Ограничение попыток переподключения** - максимум 10 попыток
3. **Увеличение интервалов переподключения** - от 5 до 30 секунд с экспоненциальным ростом
4. **Улучшенная логика onclose** - не переподключаться при нормальном закрытии или скрытой странице
5. **Обработчик beforeunload** - предотвращение переподключений при закрытии страницы


### Дополнительные проблемы
- Флаг `friendsWsConnecting` иногда не сбрасывался, блокируя звонки
- Отсутствовал таймаут для подключений, что могло приводить к зависанию
- Недостаточно информативные сообщения об ошибках
### Примененные исправления v3

1. **Улучшенная логика состояний WebSocket**:
   - Проверка активности соединения перед созданием нового
   - Принудительное закрытие старых соединений
   - Таймаут подключения (10 секунд) с автоматическим сбросом флагов

2. **Исправление обработчиков ошибок**:
   - Упрощена логика onerror - не создает дополнительных переподключений
   - Корректное освобождение ресурсов при ошибках
   - Отмена автоматических ретраев при ошибках создания соединения

3. **Улучшенная проверка готовности в calls_signaling.js**:
   - Учет состояния `friendsWsConnecting` при проверке готовности
   - Более информативные сообщения пользователю
   - Предотвращение повторных попыток переподключения

4. **Расширенная диагностика**:
   - `window.debugWebSocket()` - детальная информация о состоянии
   - `window.debugCalls()` - полная системная диагностика
   - `window.forceReconnectWebSocket()` - безопасное переподключение

### Новые функции диагностики

- `window.debugWebSocket()` - показывает состояние соединения и счетчик попыток
- `window.debugCalls()` - полная диагностика системы звонков
- `window.forceReconnectWebSocket()` - принудительное переподключение с сбросом счетчика
- `websocket_debug_v2.html` - расширенная диагностическая страница

## Измененные файлы

1. `webcall/app/presentation/static/js/modules/calls_signaling.js` - **v3**: улучшенная логика проверки готовности WebSocket, учет состояния подключения
2. `webcall/app/presentation/static/js/modules/core/app_init.js` - **v3**: полная переработка логики WebSocket с таймаутами, корректным управлением состояниями и расширенной диагностикой
3. `webcall/app/presentation/static/test_call_fixes.html` - тестовая страница (новый файл)
4. `webcall/app/presentation/static/debug_websocket.js` - скрипт диагностики WebSocket (новый файл)
5. `webcall/app/presentation/static/websocket_test.html` - базовый тест WebSocket подключения (новый файл)
6. `webcall/app/presentation/static/reconnection_test.html` - тест логики переподключений (новый файл)
7. `webcall/app/presentation/static/websocket_debug_v2.html` - **НОВЫЙ**: расширенная диагностическая страница с автоматическими тестами

Добавлены улучшения диагностики и UX для списка друзей и поиска пользователей:

1. Расширенные сообщения об ошибках в `friends_ui.js` при загрузке друзей и заявок: показывается `Ошибка загрузки: <деталь>` вместо общего слова.
2. В `api.js` функции `listFriends`, `listFriendRequests`, `findUsers` теперь формируют человеко-понятные тексты ошибок (401 → «Не авторизован», 422 → «некорректный запрос» и т.д.).
3. Поиск отображает: `Поиск...`, затем либо результаты, либо `Ничего не найдено`, либо конкретную причину ошибки (`Ошибка поиска: <деталь>` / `Неверный ответ сервера`).
4. Консольные предупреждения (`console.warn`) помогают оперативно увидеть формат ответов backend при аномалиях.
5. Улучшена устойчивость к неожиданному формату ответа (проверка `Array.isArray`).

Как диагностировать:
* Откройте DevTools → Network. Убедитесь, что `/api/v1/friends/` и `/api/v1/friends/requests` возвращают 200.
* При 401: истёк токен — выполните повторный вход, проверьте `localStorage.wc_token`.
* При 422 на поиске: длина запроса меньше минимальной (валидируется backend). Увеличьте запрос.
* Вкладка Console: ищите префикс `[friends_ui]` для технических подробностей.

Идеи на будущее (пока не реализованы):
* Debounce поиска (300–400мс) + отмена предыдущего запроса.
* Кнопка «Повторить» при сетевой ошибке.
* Авто-logout при повторном 401.
* Пагинация друзей / lazy load.

---

### Edge-case: 400 Username must be 3-32 chars

Если backend отвечает 400 (detail: `Username must be 3-32 chars [A-Za-z0-9_.-]`) на запросы `/api/v1/friends/` или `/api/v1/friends/requests`, причина в том, что при сборке DTO дергается доменный value object `Username`, а в таблице `users` есть записи с невалидным username.

Проверка: 
```sql
SELECT id, username FROM users WHERE username !~ '^[A-Za-z0-9_.-]{3,32}$';
```

Варианты решения:
1. Миграция: нормализовать (`LOWER`, заменить пробелы на `_`, обрезать до 32, удалить запрещённые символы) и обновить.
2. Временный ручной фикс проблемных записей через UPDATE.
3. (Опционально) внедрить fallback при чтении: если regex не проходит — подставлять `user_<первые8символов id>` (пока не реализовано, чтобы явно подсветить несоответствия).

UI теперь показывает кнопку «Исправить профиль», ведущую на `profile.html`, если ловит эту ошибку при загрузке друзей.

Рекомендация: выполнить миграцию до продакшена, чтобы не держать невалидные данные.

---

### Возможности
1. Кнопки медиа с иконками: `🎥 Камера`, `🖥 Экран`. Активное состояние подсвечено классом `.btn-media-active`.
2. Мини-индикатор `🖥 Экран шарится` поверх локального превью при активном screen share.
3. Горячая смена устройства камеры без renegotiation: селект камеры вызывает `switchCamera()` если активна камера.
4. Ограничения качества:
  - Камера: 1280x720 @ ~24fps (max 30)
  - Экран: 15fps
  Определяются через объект `videoConstraints` в `webrtc.js`.
5. Колбэк состояния видео `onVideoState(kind, track)` обновляет UI (badge, активные кнопки, видимость локальной карточки).
6. Автовозврат к камере после завершения демонстрации экрана (если возможно), иначе полное отключение видео.

### Использование
— Включить/выключить камеру: кнопка `🎥 Камера`.
— Начать/остановить шаринг: кнопка `🖥 Экран` (во время трансляции текст меняется на `🛑 Остановить`).
— Сменить камеру: выбрать устройство в селекте — трек подменяется через `RTCRtpSender.replaceTrack` без разрыва соединений.

### Технические детали
— При смене источника прежние `MediaStreamTrack` останавливаются для экономии ресурсов.
— Badge адаптируется под тему (зелёная / красная палитра).
— Локальная карточка скрывается при отсутствии активного видеоконтента.
— Screen share использует отдельный stream, но трек маппится в общий `localStream` для унификации.

### Потенциальные улучшения (TODO)
— Одновременное отображение камеры (PiP) вместе с экраном.
— Динамическая адаптация fps при высокой потере пакетов.
— UI индикатор текущей частоты кадров / разрешения.

### Fullscreen и фиксы локального видео
Добавлено:
 - Кнопки ⛶ для разворачивания как локального, так и любого peer видео на весь экран (Fullscreen API).
 - Делегирование событий в `app_init.js` (по `data-action="fullscreen"`).
 - Класс `.fullscreen-active` (обводка активного контейнера).
 - Принудительные `video.play()` вызовы после установки `srcObject` (и обработчик `loadedmetadata`) — снижает риск черного экрана при строгих autoplay политиках браузера.
 - Если элемент уже в fullscreen и нажать кнопку снова — выход из полноэкранного режима.

Причина проблемы «черный экран»: в ряде случаев браузер откладывает воспроизведение до gesture или требуется явный `play()`. Теперь это компенсировано.

## Страницы профиля и смены пароля (новые)

Добавлены страницы управления учётной записью:

- `profile.html` — изменение Email и имени пользователя.
  - Запрос: `GET /api/v1/auth/me` для автозаполнения полей.
  - Сохранение: `PATCH /api/v1/auth/me` (частичное — можно отправлять только email или username).
  - LocalStorage синхронизация (`wc_email`, `wc_username`) обновляет бейдж в шапке.
  - Ошибки: 400 (валидация), 409 (конфликт), 401 (нет авторизации).

- `password.html` — смена пароля в отдельной странице.
  - Поля: текущий, новый, подтверждение нового.
  - Запрос: `POST /api/v1/auth/me/password` (ответ `{ "status": "ok" }`).
  - Ошибка 400: «Старый пароль неверен или новый некорректен».

Навигация:
 - Из главной через панель настроек → «Изменить данные».
 - С `profile.html` переход на смену пароля и обратно.
 - На `password.html` ссылки назад: главная и профиль.

Backend детали:
 - `PgUserRepository.update_profile` и `update_password` коммитят транзакции, возвращают актуальные данные.
 - Эндпоинт смены пароля изменён на `200 OK` вместо `204`, чтобы избежать `AssertionError` FastAPI о теле ответа.

Идеи на будущее:
 - Подтверждение email при изменении.
 - Аватар / загрузка изображения.
 - История смен пароля или журнал входов.

## Одновременная трансляция камеры и экрана + очистка последнего кадра

Проблемы (до фикса):
* Включение демонстрации экрана заменяло камеру — нельзя транслировать оба потока.
* После остановки видеопотока оставался «замороженный» последний кадр локально.
* Нельзя было переключить окно/вкладку без полного выключения screen share.

Решения:
1. Введены отдельные сущности `_cameraTrack/_cameraSender` и `_screenTrack/_screenSender`.
2. Разрешено существование двух активных видеотреков (камера + экран); приоритет отображения в локальном превью — экран.
3. `stopCamera()` и `stopScreenShare()` останавливают/отвязывают только соответствующий трек, legacy `stopVideo()` выключает оба.
4. Очищается превью при отсутствии активных треков (`video.srcObject=null; video.load()`), убирая последний кадр.
5. `switchScreenShareWindow()` выполняет повторный `getDisplayMedia` и `replaceTrack`, позволяя сменить окно без разрыва.
6. `_currentVideoKind`: `none | camera | screen | multi` — при двух треках устанавливается `multi` (для UI/статуса).
7. Автоматическая renegotiation остаётся через `negotiationneeded`; при необходимости fallback форс-оффер также покрывает второй видеотрек.

API обновления (WebRTCManager):
* `startCamera() / stopCamera()`
* `startScreenShare() / stopScreenShare()`
* `switchScreenShareWindow()`
* `toggleCameraStream()` / `toggleScreenShare()` (поведение обновлено под новую модель)

Визуализация локального превью:
* Отдельный комбинированный поток не микшируется (для упрощения). В будущем возможен Canvas микшер для PiP камеры над экраном.

Edge cases:
* Ограничение браузера по количеству одновременных видео-сендов: тогда второй трек может потребовать renegotiation с удалением первого.
* Safari иногда задерживает `negotiationneeded` — компенсируется уже существующим таймерным форсом.

Планы на улучшения:
* Canvas-композиция (экран + миникамера) без второго RTP потока.
* Динамический bitrate adaptation: снижение fps камеры при активном screen share.
* UI-индикатор «multi» состояния и отдельные кнопки отключения каждого канала.

## Расширения (PiP, Adaptive, Multi Badges, Canvas Mix)

### Что добавлено сверх ранее описанного
1. Два одновременных видеотрека отправляются параллельно (камера + экран) с отдельными `RTCRtpSender` (`_cameraSender`, `_screenSender`).
2. PiP (картинка‑в‑картинке) UX:
  - Локально: при `multi` состояние на карточке появляется badge `🎥+🖥` и отдельные кнопки `✖︎ Кам` / `✖︎ Экран`.
  - Удалённо: плитка участника содержит стек из основного видео (`peer-main`) и PiP наложения (`peer-pip`). Эвристика: экран определяется по `label` (`screen|display|share`).
3. Adaptive понижение качества камеры при активном screen share: метод `_adaptVideoQualities()` снижает камеру до ~960x540 @12fps, возвращает исходные constraints после остановки экрана.
4. Кнопки мгновенной остановки отдельных источников (`stopCamera()`, `stopScreenShare()`).
5. Индикатор `multi` вместо двух отдельных badge, если активны оба трека.
6. Canvas-композиция (опционально): локальный скрытый `<canvas id="localCompositeCanvas">` рисует экран + камеру (PiP) единым кадром. Включается кнопкой `🧩 Mix` при состоянии `multi`.

### Canvas Mix (архитектура)
* Не отправляет композицию в сеть: это только локальный визуальный слой для пользователя.
* Метод `enableComposite(canvas)` запускает рендер‑петлю `_runCompositeLoop()`.
* Приоритет: фон = экран, PiP = камера (22% ширины, 16:9, с белой рамкой) в правом нижнем углу.
* Автоматическое отключение композиции, если исчезли оба трека.

### API дополняющие
```
// webrtc.js
enableComposite(canvas: HTMLCanvasElement)
disableComposite()
toggleComposite(canvas?)
```

### UI / Состояния
| State | local badge | Кнопка Mix | Поведение превью |
|-------|-------------|------------|------------------|
| none  | скрыто      | скрыта     | нет видео        |
| camera| скрыто      | скрыта     | камера           |
| screen| 🖥 badge    | скрыта     | экран            |
| multi | 🎥+🖥 badge  | показана   | экран (основное) + кнопки stop | 

### Ограничения и соображения
* Safari: может игнорировать часть `applyConstraints`; деградация камеры необязательна, но попытка безопасна.
* Дополнительный второй RTP поток увеличивает uplink; Canvas Mix может служить основой для будущего режима «один поток наружу» (нужен `canvas.captureStream()`). Пока не активировано осознанно, чтобы не ломать текущие peer соединения.
* При переключении окна шаринга `switchScreenShareWindow()` сохраняет камеру без мигания.

### Возможные следующие шаги
* Добавить настройку «Отправлять один композиционный поток вместо двух» (замена senders на `canvas.captureStream()` + отключение `_screenTrack/_cameraTrack`).
* Динамический выбор позиции PiP (drag & drop + сохранение в localStorage).
* Отображение текущих фактических параметров (реальное разрешение, fps) через `getStats()`.

## Shortcuts & Metrics

Горячие клавиши (когда фокус не в поле ввода):
* `m` — toggle микрофон
* `c` — toggle камера
* `s` — toggle демонстрация экрана
* `x` — принудительно остановить экран
* `k` — принудительно остановить камеру
* `Shift+M` (буква `M`) — включить/выключить локальную Canvas композицию (кнопка `🧩 Mix`)

Оверлей метрик (`#localVideoMetrics`):
* Показывает текущее состояние (`camera|screen|multi`) + `width x height @fps`.
* Обновление 1 раз в секунду через `track.getSettings()`.
* Автоматически скрывается при отсутствии видеотреков.



===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\CALL_FIXES_README.md =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\README.md =====
--- SIZE: 15669 bytes ---

docker compose exec api alembic upgrade head
﻿# WebCall

Минималистичная платформа для аудио/WebRTC звонков и чата: FastAPI + WebSocket сигналинг, PostgreSQL, Redis, STUN/TURN, модульный frontend (vanilla ES modules).

## Основные возможности
- Регистрация / вход (JWT + секрет регистрации)
- Комнаты и многопользовательский WebRTC сигналинг
- Чат комнат + личные (direct) сообщения
- E2EE (клиентские ключи) + хранение публичных ключей
- Push уведомления (WebPush) для инвайтов / сообщений
- Управление участниками (роли, mute)
- Простая SPA (`/static`) без зависимостей фреймворков

## Архитектурные слои
```
presentation/  (REST, WS, схемы, статические файлы)
application/   (use-cases, DTO)
core/          (доменные модели, value objects, порты, ошибки)
infrastructure/(DB репозитории, Redis, security, messaging, services)
bootstrap/     (инициализация FastAPI, middleware, статик)
```
Принципы: зависимость направлена внутрь (presentation -> application -> core), infrastructure реализует порты core.

## Недавние технические улучшения
- Введение Value Object `Username` (валидация: 3-32 символа `[A-Za-z0-9_.-]`).
- Перенос проверки владельца комнаты в use-case `DeleteRoom` (чистая бизнес-логика, router стал тоньше).
- Observability middleware: `X-Request-ID`, Server-Timing, структурированные логи с латентностью.
- Prometheus метрики: `/metrics` (счётчик и гистограмма запросов).
- Простой in-memory rate limiting для `auth/register`, `auth/login`, `rooms` (создание).
- Рефактор спец-рингтона: переезд файла в `static/media/special_ringtone.mp3` + fallback.
- Housekeeping: `dump.bat` перемещён в `scripts/legacy/`.
- Добавлен `@ts-check` + JSDoc типы в модулях фронтенда (статический анализ без TS-транспиляции).
- Mypy усилен (строже конфиг), добавлен pre-commit hook; Value Objects типизированы.

## Безопасность / Hardening (сделано)
- SQL: параметризация через SQLAlchemy, helper `safe_like`, лимиты на `IN()`.
- XSS: отказ от небезопасных `innerHTML` для пользовательского контента.
- Headers: CSP (временно с `'unsafe-inline'`), HSTS (prod), X-Content-Type-Options, X-Frame-Options, Referrer-Policy.
- Auth: JWT + обязательный `REGISTRATION_SECRET`.
- Пароли: bcrypt (passlib).
- Rate limiting на чувствительных эндпоинтах (in-memory).
- Логирование: request id, латентность, унифицированный формат (готово к интеграции с ELK/Tempo).

## Следующие шаги (roadmap)
1. Ужесточить CSP — убрать `'unsafe-inline'`, вынеся inline скрипты.
2. Добавить semgrep / bandit в CI.
3. Redis/Cluster rate limit (горизонтальное масштабирование).
4. Redis-бэкенд для CallInviteService / очередь уведомлений.
5. E2E тесты WebRTC сигналинга (smoke) + нагрузочные сценарии.
6. Экспорт метрик в Grafana / Alerting (SLO latency, error rate).

## Запуск (локально)
```powershell
cp .env.example .env
docker compose up -d --build
docker compose exec api alembic upgrade head
```
Либо через poetry:
```powershell
poetry install
poetry run alembic upgrade head
poetry run uvicorn app.bootstrap.asgi:app --reload
```

Frontend (esbuild):
```powershell
cd webcall
npm ci
npm run build
```

Тесты:
```powershell
pytest -q
```

## Переменные окружения (ключевые)
`APP_ENV`, `PORT`, `JWT_SECRET`, `REGISTRATION_SECRET`, `DATABASE_URL`, `REDIS_URL`, `STUN_SERVERS`, `TURN_URLS`, `TURN_USERNAME`, `TURN_PASSWORD`, `CORS_ORIGINS`.

### Дополнительно (AI summary / Telegram)
| Переменная | Назначение | По умолчанию |
|------------|------------|--------------|
| `AI_SUMMARY_ENABLED` | Включает генерацию выжимки чата комнаты при завершении | `False` |
| `AI_MODEL_PROVIDER` | Идентификатор провайдера/модели (зарезервировано) | `None` |
| `AI_SUMMARY_MAX_MESSAGES` | Лимит сообщений, удерживаемых для суммаризации | `200` |
| `AI_SUMMARY_MIN_CHARS` | Минимальное суммарное количество символов содержимого (без обвязки) для вызова внешнего AI; если меньше — формируется короткий fallback без полноценной AI выжимки | `60` |
| `TELEGRAM_BOT_TOKEN` | Токен бота для отправки выжимок | `None` |
| `TELEGRAM_CHAT_ID` | (DEPRECATED) Глобальный чат / канал / пользователь. Используется только как fallback если у инициатора нет персональной привязки | `None` |
| `OPENAI_API_KEY` | Ключ OpenAI для генерации выжимки | `None` |
| `AI_MODEL_FALLBACK` | Запасная модель если основная недоступна | `None` |

Механика (ручной триггер):

1. Сообщения чата (`type=chat`) и расщеплённый на предложения голосовой транскрипт (если включён voice capture) буферизуются в памяти.
2. Автоматическая генерация при уходе участников отключена.
3. Первый клик по кнопке «AI Agent» — подключает агент-присутствие и начинает поток голосовых чанков во `voice_capture` WebSocket.
4. Второй клик — останавливает запись, закрывает вспомогательные WS и через ~650 мс отправляет в основной room WebSocket сообщение `{"type":"agent_summary"}`.
5. Сервер по получении `agent_summary` собирает итог (voice > chat) и, если заданы Telegram переменные, отправляет отчёт (однократно per room).
6. Если общий объём контента < `AI_SUMMARY_MIN_CHARS`, внешний AI не вызывается — возвращается эвристический fallback с пометкой о короткой сессии.
7. При ручном триггере сервер ожидает до ~6 секунд готовности транскрипта (poll каждые 300мс) перед формированием отчёта. Если за это время транскрипт не появился и нет сообщений чата — результат пуст и можно повторить попытку (agent_summary снова).

Пример настройки для OpenAI:
```
AI_SUMMARY_ENABLED=true
AI_MODEL_PROVIDER=openai:gpt-4o-mini
OPENAI_API_KEY=sk-...  # НЕ коммитить в репозиторий
AI_MODEL_FALLBACK=gpt-4o-mini
```

## Персональная привязка Telegram

Реализована таблица `telegram_links` для привязки пользователя к своему `chat_id`.

Флоу:
1. Клиент запрашивает `POST /api/v1/telegram/link` — сервер возвращает токен и deep-link вида `https://t.me/<BOT>?start=<token>`.
2. Пользователь переходит по ссылке, бот получает `/start <token>` и отправляет webhook `POST /api/v1/telegram/webhook`.
3. Сервер помечает ссылку `status=confirmed`, сохраняет `chat_id`.
4. Клиент периодически опрашивает `GET /api/v1/telegram/status` пока `confirmed`.

### Отвязка Telegram

Если пользователь хочет отключить получение AI выжимок в Telegram:

1. Нажимает кнопку "Отвязать Telegram" в настройках (иконка шестерёнки в интерфейсе).
2. Клиент вызывает `DELETE /api/v1/telegram/link`.
3. Сервер помечает все `confirmed` записи пользователя как `revoked`.
4. Статус `GET /api/v1/telegram/status` вернётся `absent`. Для повторной привязки нужно снова пройти процедуру `/link` → `/start <token>`.

Это позволяет безопасно переключать устройства или отключать доставку отчётов.

## Кастомный AI System Prompt

По умолчанию для генерации итоговой выжимки используется системный prompt:

```
Ты ассистент, делающий краткую структурированную выжимку группового чата: 1) Основные темы 2) Принятые решения 3) Открытые вопросы. Пиши лаконично на русском, без лишних вступлений.
```

Пользователь может задать собственный prompt через API или UI:

* `GET  /api/v1/ai/prompt` — получить текущий (если кастом не задан, возвращается дефолт и `is_default=true`).
* `PUT  /api/v1/ai/prompt` — сохранить новый (`{"prompt": "..."}`), длина 10..4000.
* `DELETE /api/v1/ai/prompt` — сброс к стандартному.

Во фронтенде в панели настроек доступно поле редактирования prompt с кнопками "Сохранить" и "Сброс". Если ввести дефолтный текст без изменений — он не дублируется в БД (поле очищается).

При генерации summary (OpenAI провайдер) если инициатор ручного триггера имеет кастомный prompt — он используется как system message вместо дефолта.

## Настройка TURN (coturn)

Если в логах coturn появляется ошибка вида:

```
ERROR: session ... check_stun_auth: Cannot find credentials of user <webcall>
```

Причины и решение:

1. Клиент (браузер / WebRTC) использует long-term auth и шлёт `username=webcall`, но сервер не знает пользователя.
2. В исходной версии конфиг `turnserver.conf` содержал плейсхолдеры `${TURN_USERNAME}` и др. — coturn НЕ подставляет переменные окружения внутри файла.

Актуальная схема:

* В `docker-compose.yml` параметры пробрасываются через команду запуска: `--realm=... --user=USERNAME:PASSWORD --external-ip=...`.
* Файл `turnserver.conf` содержит только статические опции (порты/флаги).

Проверь, что переменные окружения заданы в `.env`:

```
TURN_REALM=example.com
TURN_USERNAME=webcall
TURN_PASSWORD=strongsecret
TURN_PUBLIC_IP=YOUR_PUBLIC_IP
TURN_CLI_PASSWORD=adminpass
```

И что клиент действительно использует те же `username`/`credential`. Если используется динамическая авторизация — нужно реализовать REST API или `userdb`, но для простоты сейчас применяется статический пользователь.

5. При ручном триггере AI summary сервер отправляет отчёт ТОЛЬКО инициатору (его `chat_id`). Если привязки нет — пытается отправить всем подтверждённым (глобальный broadcast) или, в качестве устаревшего fallback, в `TELEGRAM_CHAT_ID`.

## Миграции / устранение multiple heads

Если при запуске контейнера возникает ошибка Alembic `Multiple head revisions are present`, причины:
- В БД остались ссылки на ревизии, которых больше нет в каталоге `alembic/versions`.
- Либо ранее существовал merge-point.

Решение (без потери данных):
1. Определить фактическое состояние таблиц (сравнить со схемой последней миграции).
2. Войти в контейнер: `docker compose exec api bash` (или `sh`).
3. Получить текущие ревизии: `alembic history --verbose | tail -n 40` и `alembic current -v` (если падает из-за multiple heads — перейти к ручному штампу).
4. Открыть `psql` и посмотреть содержимое `alembic_version`: `SELECT * FROM alembic_version;` (может быть несколько строк при split head scenario).
5. Сделать резервную копию (опционально): `pg_dump -U webcall -d webcall > /tmp/backup.sql`.
6. Проставить единый штамп на последнюю существующую ревизию из кода (например `0006_telegram_links`):
	- Удалить лишние строки: `DELETE FROM alembic_version;`
	- Вставить одну: `INSERT INTO alembic_version (version_num) VALUES ('0006_telegram_links');`
7. Запустить `alembic upgrade head` — он теперь ничего не применит (schema already up-to-date) и не будет жаловаться.

Если схема в БД не соответствует миграциям (рассинхронизация), используйте:
1. `alembic downgrade base` (если безопасно потерять данные) → затем `alembic upgrade head`.
2. Либо вручную примените недостающие изменения и затем `alembic stamp <revision>`.

Checklist после фикса:
- `alembic current` показывает одну ревизию.
- `alembic heads` == `alembic current`.
- Приложение стартует без ошибки.

Примечание: глобальный noop stub миграции удалён, цепочка линейная 0001 → 0006.


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\README.md =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\conftest.py =====
--- SIZE: 672 bytes ---

import os, sys

def _early_path():
    ROOT = os.path.abspath(os.path.dirname(__file__))
    PKG_ROOT = os.path.join(ROOT, 'webcall')
    if PKG_ROOT not in sys.path:
        sys.path.insert(0, PKG_ROOT)
_early_path()

# Provide minimal required env vars so Settings() doesn't fail in tests
os.environ.setdefault('JWT_SECRET', 'test-jwt-secret')
os.environ.setdefault('REGISTRATION_SECRET', 'test-registration')
os.environ.setdefault('DATABASE_URL', 'sqlite+aiosqlite:///:memory:')
os.environ.setdefault('REDIS_URL', 'redis://localhost:6379/0')

def pytest_configure():  # noqa: D401
    # Re-assert path very early in pytest lifecycle
    _early_path()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\conftest.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\docker\nginx_security.conf =====
--- SIZE: 2602 bytes ---

# nginx security snippet for reversing proxying the WebCall app
# Place this file in your nginx conf and include it in the server block.
# Example: include /etc/nginx/conf.d/webcall_security.conf;

# Always add these headers
add_header X-Content-Type-Options "nosniff" always;
add_header X-Frame-Options "DENY" always;
add_header Referrer-Policy "no-referrer" always;
add_header X-XSS-Protection "1; mode=block" always;

# HSTS: enable only when serving over HTTPS
# The following line enforces HTTPS for one year and includes subdomains
add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

# Content-Security-Policy: conservative default
# WARNING: this is a starting point. You should tailor CSP to your app (move inline scripts to files or use nonces)
# For example, to allow only scripts from own origin and disallow inline scripts:
# add_header Content-Security-Policy "default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self'; connect-src 'self' wss:; img-src 'self' data:; style-src 'self' 'unsafe-inline'" always;

add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'self'; connect-src 'self' wss:; img-src 'self' data:; style-src 'self' 'unsafe-inline'" always;

# Deny access to sensitive files
location ~* (?:\.|\b)(?:env|git|htpasswd|docker-compose\.yml)$ {
    deny all;
    return 404;
}

# Also deny access to hidden files and directories (starting with .)
location ~ (^|/)[.] {
    deny all;
    return 404;
}

# Recommended: add a location for static files with efficient caching
location /static/ {
    alias /app/app/presentation/static/; # adjust to your container static path
    tcp_nopush on;
    sendfile on;
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    add_header Cache-Control "public, max-age=31536000, immutable";
}

# Proxy pass to uvicorn/gunicorn upstream
location / {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;

    # WebSocket support
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection $connection_upgrade;

    proxy_pass http://127.0.0.1:8000; # change to your upstream
}

# small helper for Connection header when proxying WebSockets
map $http_upgrade $connection_upgrade {
    default upgrade;
    '' close;
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\docker\nginx_security.conf =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\dump.txt =====
--- SIZE: 58509 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\dump.txt =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\package-lock.json =====
--- SIZE: 86 bytes ---

{
  "name": "WebCall",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {}
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\package-lock.json =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\pytest.ini =====
--- SIZE: 32 bytes ---

[pytest]
pythonpath = webcall

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\pytest.ini =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_autoresume.py =====
--- SIZE: 1584 bytes ---

import pytest
from webcall.app.infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator

class DummyAIProvider:
    async def generate_summary(self, messages, system_prompt=None):  # type: ignore
        return " || ".join(m for m in messages)

@pytest.mark.asyncio
async def test_auto_resume_session_after_stop():
    orch = get_summary_orchestrator()
    room_id = "auto-room"
    user_id = "u1"
    # Старт и первое сообщение
    await orch.start_user_window(room_id, user_id)
    orch.add_chat(room_id, user_id, "User", "Первое сообщение")
    res1 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res1.message_count == 1
    # Останавливаем окно
    orch.end_user_window(room_id, user_id)
    # Появляются новые сообщения без явного рестарта
    orch.add_chat(room_id, user_id, "User", "Второе сообщение после стопа")
    orch.add_chat(room_id, user_id, "User", "Третье сообщение после стопа")
    # Запрашиваем summary — должно авто создать новую сессию и учесть только новые сообщения
    res2 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res2.message_count >= 2, res2.summary_text
    assert "Первое сообщение" not in res2.summary_text

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_autoresume.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_lazy_voice.py =====
--- SIZE: 1826 bytes ---

import pytest
from webcall.app.infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator

class DummyAIProvider:
    async def generate_summary(self, messages, system_prompt=None):  # type: ignore
        return " :: ".join(m for m in messages)

@pytest.mark.asyncio
async def test_lazy_attach_after_restart():
    orch = get_summary_orchestrator()
    room_id = "lazy-room"
    user_id = "user-lazy"
    # Старт + voice
    await orch.start_user_window(room_id, user_id)
    orch.add_voice_transcript(room_id, "Первая запись речи о тестировании", user_id=user_id)
    res1 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res1.message_count > 0
    # Стоп без новых данных
    orch.end_user_window(room_id, user_id)
    # Повторный старт (без новой voice) — старый транскрипт не должен автоматически появиться (мы создали новую сессию без прогрессивного attach)
    await orch.start_user_window(room_id, user_id)
    # Эмулируем, что глобальный collector всё ещё хранит текст (в реальном случае мы бы не pop-или). Добавим ещё раз вручную, чтобы проверить отсутствие дубликатов.
    orch.add_voice_transcript(room_id, "Первая запись речи о тестировании", user_id=user_id)
    res2 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res2.message_count > 0
    assert "Первая запись" in res2.summary_text

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_lazy_voice.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_restart.py =====
--- SIZE: 2952 bytes ---

import pytest
import asyncio
from webcall.app.infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator

class DummyAIProvider:
    async def generate_summary(self, messages, system_prompt=None):  # type: ignore
        # Простейшая агрегация для теста
        return " | ".join(m.split(':',1)[-1].strip() for m in messages)

@pytest.mark.asyncio
async def test_summary_v2_restart_two_voice_segments(monkeypatch):
    orch = get_summary_orchestrator()
    room_id = "test-room-restart"
    user_id = "user-1"

    # Старт сессии
    await orch.start_user_window(room_id, user_id)
    # Добавляем voice транскрипт (эмуляция)
    orch.add_voice_transcript(room_id, "Первый сеанс разговора о погоде и планах", user_id=user_id)

    res1 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res1.message_count > 0, "Первое summary должно содержать сообщение из voice"
    assert "Первый сеанс" in res1.summary_text

    # Завершение и перезапуск
    orch.end_user_window(room_id, user_id)
    await orch.start_user_window(room_id, user_id)

    # Вторая транскрипция
    orch.add_voice_transcript(room_id, "Второй сеанс обсуждаем технологии и код", user_id=user_id)

    res2 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res2.message_count > 0, "Второе summary должно быть непустым"
    assert "Второй сеанс" in res2.summary_text
    # Убедимся что текст первого сеанса не смешался во второй (простая эвристика)
    assert "Первый сеанс" not in res2.summary_text

@pytest.mark.asyncio
async def test_summary_v2_multiple_voice_segments_single_session(monkeypatch):
    orch = get_summary_orchestrator()
    room_id = "test-room-multi"
    user_id = "user-2"
    await orch.start_user_window(room_id, user_id)
    orch.add_voice_transcript(room_id, "Первая часть беседы про погоду", user_id=user_id)
    orch.add_voice_transcript(room_id, "Вторая часть беседы про технологии", user_id=user_id)

    res = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res.message_count > 0
    # Оба сегмента должны присутствовать в источниках (через объединение strategy)
    assert "погоду" in res.summary_text or "погоду" in res.summary_text.lower()
    assert "технолог" in res.summary_text.lower()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_restart.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_reuse.py =====
--- SIZE: 1298 bytes ---

import pytest, time
from webcall.app.infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator

class DummyAIProvider:
    async def generate_summary(self, messages, system_prompt=None):  # type: ignore
        return " | ".join(m for m in messages)

@pytest.mark.asyncio
async def test_reuse_previous_voice_fast_restart():
    orch = get_summary_orchestrator()
    room_id = "reuse-room"
    user_id = "reuse-user"
    await orch.start_user_window(room_id, user_id)
    orch.add_voice_transcript(room_id, "Запоминание первой транскрипции для переиспользования", user_id=user_id)
    res1 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    assert res1.message_count > 0
    # Быстрый рестарт (<7s) без новой речи
    orch.end_user_window(room_id, user_id)
    await orch.start_user_window(room_id, user_id)
    res2 = await orch.build_personal_summary(room_id=room_id, user_id=user_id, ai_provider=DummyAIProvider(), db_session=None)
    # Должен сработать reuse — summary не пустое
    assert res2.message_count > 0
    assert "переиспольз" in res2.summary_text.lower()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\tests\test_summary_v2_reuse.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.dockerignore =====
--- SIZE: 709 bytes ---

# Базовое
.git
.gitignore
README.md
ARCHITECTURE.md
DEPLOYMENT.md

# Python виртуальные окружения
.venv
venv

# Кэш / артефакты
__pycache__/
*.py[cod]
*.pyo
*.pyd
*.tmp
*.log
*.sqlite
.build/
.dist/
.coverage
htmlcov/
.pytest_cache/

# Node
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-store/

# Тесты (не нужны в прод окружении образа)
app/tests/
app/tests_e2e/
webcall/tests/

# IDE
.vscode/
.idea/
*.swp

# Docker
Dockerfile.*~

# Monitoring локальные артефакты (пока нет, но на будущее)
monitoring/tmp/

# Прочее
*.orig

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.dockerignore =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore =====
--- SIZE: 1648 bytes ---

############################################
# Python
############################################
__pycache__/
*.py[cod]
*.pyd
*.so
*.egg
*.egg-info/
dist/
build/
.eggs/
.venv/
.env
.env.*
.python-version
.mypy_cache/
.pytest_cache/
.ruff_cache/
.coverage
coverage.xml
htmlcov/
.cache/
.tox/
.benchmarks/

############################################
# Node / Frontend
############################################
node_modules/
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
*.log
# Optional: ignore built bundles if не хотите коммитить артефакты сборки
# app/presentation/static/js/*.bundle.js.map
# app/presentation/static/js/*.bundle.js

############################################
# Editor / IDE
############################################
.idea/
.vscode/
*.swp
*.swo
*.orig
*.iml

############################################
# OS / Misc
############################################
.DS_Store
Thumbs.db

############################################
# Notebooks / data
############################################
.ipynb_checkpoints/

############################################
# Docker / Runtime / Monitoring (local only)
############################################
docker-compose.override.yml
prometheus-data/
grafana-data/
*.rdb

############################################
# Reports / temp
############################################
reports/
tmp/
*.tmp
*.bak

############################################
# Poetry internals (опционально)
############################################
.poetry/

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.gitignore =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml =====
--- SIZE: 652 bytes ---

repos:
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.6.3
    hooks:
      - id: ruff
        args: ["--fix"]
  - repo: https://github.com/psf/black
    rev: 24.8.0
    hooks:
      - id: black
  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.11.1
    hooks:
      - id: mypy
        additional_dependencies: []
        args: ["--config-file=pyproject.toml"]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\.pre-commit-config.yaml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\DEPLOYMENT.md =====
--- SIZE: 11937 bytes ---

# DEPLOYMENT GUIDE

## 1. Overview
Two primary deployment modes:
1. Docker Compose (recommended: fastest, reproducible, includes Prometheus & Grafana)
2. Bare Metal (systemd + nginx + separate Postgres/Redis)

## 2. Environment Variables
Required:
- `APP_ENV=prod`
- `JWT_SECRET=<random-long-secret>`
- `REGISTRATION_SECRET=<secret-for-initial-user-registration>`
- `DATABASE_URL=postgresql+asyncpg://webcall:<password>@postgres:5432/webcall` (or external DB)
- `REDIS_URL=redis://redis:6379/0`

Recommended:
- `RATE_LIMIT=100/60` (example global per user+path)
- `CALL_INVITES_BACKEND=redis`
- `CORS_ORIGINS=https://your.domain,https://admin.domain`
- TURN (if using self-hosted TURN):
  - `TURN_URLS=turn:turn.your.domain:3478?transport=udp,turn:turn.your.domain:3478?transport=tcp`
  - `TURN_USERNAME=...`
  - `TURN_PASSWORD=...`
  - `TURN_PUBLIC_IP=<public_ip>`
  - `TURN_REALM=your.domain`
- Web Push (optional):
  - `VAPID_PUBLIC_KEY=...`
  - `VAPID_PRIVATE_KEY=...`
  - `VAPID_SUBJECT=mailto:admin@your.domain`
- Observability:
  - `GRAFANA_ADMIN_PASSWORD=StrongPass123!`

## 3. Docker Compose Deployment
Clone repository on server (Ubuntu example):
```bash
sudo apt update && sudo apt install -y docker.io docker-compose-plugin
sudo usermod -aG docker $USER
# relogin
git clone https://your.git/WebCall.git webcall && cd webcall/webcall
cp .env.example .env
# edit .env and set secrets (JWT_SECRET, REGISTRATION_SECRET, DB passwords, etc.)
```
Adjust `docker-compose.yml` if using external Postgres/Redis (remove internal services, set URLs).

Build & start:
```bash
docker compose pull
# production image build (optional alternative build)
DOCKER_BUILDKIT=1 docker build -f docker/api.prod.Dockerfile -t webcall-api:prod .
# use the prod image by editing docker-compose service 'api' to image: webcall-api:prod
# then
docker compose up -d
```

Check:
```bash
curl -f http://localhost:8000/healthz
open http://<SERVER_IP>:3000   # Grafana
```

Run Alembic migrations (compose already runs them on api start). For manual:
```bash
docker compose exec api alembic upgrade head
```

### Updating
```bash
git pull
DOCKER_BUILDKIT=1 docker build -f docker/api.prod.Dockerfile -t webcall-api:prod .
docker compose up -d --no-deps --build api
```

### Logs
```bash
docker compose logs -f api
```

### Scaling API (stateless layer)
Add replica count using docker compose (v2) or run additional containers behind an external load balancer / nginx upstream.
Ensure:
- Shared Redis
- Shared Postgres
- Sticky sessions NOT required (JWT stateless)

Example with `docker compose up --scale api=2 -d` (adjust if health probing & migration race: move migrations to a one-off job).

## 4. Bare Metal Deployment
Install system packages:
```bash
sudo apt update
sudo apt install -y python3.11 python3.11-venv build-essential libpq-dev redis-server nginx
```
Create user & directory:
```bash
sudo useradd -r -m webcall
sudo mkdir -p /opt/webcall
sudo chown webcall:webcall /opt/webcall
su - webcall
git clone https://your.git/WebCall.git src && cd src/webcall
python3.11 -m venv .venv
source .venv/bin/activate
pip install --upgrade pip
pip install poetry==1.8.3
poetry install --without dev
cp .env.example .env  # fill secrets
alembic upgrade head
```

### Systemd unit
`/etc/systemd/system/webcall.service`:
```
[Unit]
Description=WebCall API
After=network.target

[Service]
User=webcall
Group=webcall
WorkingDirectory=/opt/webcall/src/webcall
Environment=PYTHONPATH=/opt/webcall/src/webcall
EnvironmentFile=/opt/webcall/src/webcall/.env
ExecStart=/opt/webcall/src/webcall/.venv/bin/gunicorn app.bootstrap.asgi:app -k uvicorn.workers.UvicornWorker -w 2 -b 0.0.0.0:8000 --graceful-timeout 30 --timeout 60
Restart=always
RestartSec=5
LimitNOFILE=65535

[Install]
WantedBy=multi-user.target
```
Reload & enable:
```bash
sudo systemctl daemon-reload
sudo systemctl enable --now webcall
sudo systemctl status webcall
```

### Nginx reverse proxy + TLS
`/etc/nginx/sites-available/webcall.conf`:
```
server {
    listen 80;
    server_name your.domain;
    location / { proxy_pass http://127.0.0.1:8000; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $remote_addr; }
}
```
Enable & test:
```bash
sudo ln -s /etc/nginx/sites-available/webcall.conf /etc/nginx/sites-enabled/
sudo nginx -t && sudo systemctl reload nginx
```
Add TLS (Certbot):
```bash
sudo apt install -y certbot python3-certbot-nginx
sudo certbot --nginx -d your.domain --redirect --agree-tos -m admin@your.domain
```

## 5. TURN Server (coturn)
If self-hosted (docker-compose already sets one):
1. Open UDP/TCP 3478 + relay ports range (49152-49200).
2. Example coturn service:
```
turnserver --lt-cred-mech --user=$TURN_USERNAME:$TURN_PASSWORD --realm=$TURN_REALM \
  --cert=/etc/letsencrypt/live/your.domain/fullchain.pem --pkey=/etc/letsencrypt/live/your.domain/privkey.pem \
  --fingerprint --log-file=stdout --min-port=49152 --max-port=49200
```
Set env variables so API exposes ICE servers list to clients.

## 6. Observability
Metrics endpoint: `GET /metrics` (Prometheus format).
Provided dashboard: `monitoring/grafana/dashboards/webcall-overview.json`.
Add alert rules via separate Alertmanager (not included).

### Example Prometheus alert rules (add to dedicated rules file):
```
groups:
- name: webcall-alerts
  rules:
    - alert: HighErrorRate
      expr: sum(rate(app_requests_total{status=~"5.."}[5m])) / sum(rate(app_requests_total[5m])) > 0.05
      for: 5m
      labels:
        severity: warning
      annotations:
        summary: ">5% errors (5m)"
    - alert: HighLatencyP95
      expr: histogram_quantile(0.95, sum(rate(app_request_latency_ms_bucket[5m])) by (le)) > 500
      for: 10m
      labels:
        severity: warning
      annotations:
        summary: "p95 latency >500ms"
```

## 7. Secrets Management
Use `.env` only for dev. For prod:
- Docker swarm / compose: `env_file` with restricted permissions or secrets store.
- Bare metal: `EnvironmentFile` root-owned (600).

## 8. Backup Strategy
- Postgres: daily `pg_dump` (retain 7-14 days)
- Redis: snapshot (RDB) or use managed Redis
- Versioned infrastructure (IaC) recommended.

## 9. Zero-Downtime Update (compose)
1. Build new image tag (e.g., `webcall-api:2025-09-19`)
2. Update compose `image:` tag.
3. `docker compose up -d api` (old container stops after new healthy).
4. Rollback: revert tag and re-up.

## 10. Troubleshooting
| Symptom | Check |
|---------|-------|
| 503 on auth endpoints | DB not reachable / migrations failed |
| No metrics in Grafana | Prometheus target state, network, `api:8000/metrics` |
| WebRTC fails to connect | TURN credentials / firewall ports |
| High latency | CPU saturation, gunicorn workers too low |
| Redis warning Memory overcommit | Set `vm.overcommit_memory=1` and reboot |
| duplicate key uq_push_user_endpoint | Frontend sent duplicate subscribe; now handled idempotently (ensure updated image) |
| Unexpected EOF on client connection with open transaction | Client disconnected mid-request; investigate long-running handlers / network stability |

### Redis Overcommit Memory Warning
If you see: `WARNING Memory overcommit must be enabled!` inside Redis logs, enable it on the host:
```
echo 'vm.overcommit_memory=1' | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
```
Reboot for persistence (or keep sysctl -p). This avoids background save failures.

### Postgres `unexpected EOF on client connection with an open transaction`
Indicates a client dropped connection before completing / rolling back a transaction. Common causes:
- Browser tab closed mid-request
- Reverse proxy timeout (adjust idle/read timeouts)
- Application crash or network blip
Mitigation: ensure short transactions, add timeout / cancellation handling in async tasks.

### Coturn Configuration & Metrics
The compose setup now mounts `docker/turnserver.conf`. To enable Prometheus metrics, uncomment the metrics port mapping (`9641:9641`) and ensure `prometheus` scrape job is added:
```
- job_name: turn
  static_configs:
    - targets: ['coturn:9641']
```
Provide TLS certs by mounting a `certs` directory and uncommenting `cert`/`pkey` lines in `turnserver.conf`.

### Push Subscription Idempotency
Backend uses PostgreSQL `ON CONFLICT` upsert; frontend caches a fingerprint (endpoint + keys) for 12h. Duplicate subscribe calls should no longer spam logs.

## 11. Hardening Checklist
### Summary v2 (персональные окна и голос)

Архитектура `summary_v2` реализует:
* Недеструктивный лог (`MessageLog`) – чат сообщения не очищаются при суммаризации.
* Персональное окно: при подключении AI-агента пользователя фиксируется `start_ts`; все последующие сообщения и валидный voice входят в персональное summary.
* Голос: транскрипт помещается в буфер; технические / ошибочные распознавания `(asr failed http 400)` не перезаписывают успешный текст.
* Voice-only режим: если после старта окна ещё не было чата, но есть валидный голос – генерируется сводка только по голосу.
* Фильтрация технических сообщений (`TECHNICAL_PATTERNS`).
* Polling при ручном запросе: до ~2.5s ожидания появления новых данных прежде чем сообщить пользователю о пустой сводке.
* Post-update: если первая выдача была пустой, в течение ещё ~3s может прийти `personal_summary_update`.

Переменная окружения `USE_SUMMARY_V2=0` отключает новую архитектуру для отката.

Типовые причины пустой персональной сводки:
1. Распознавание речи ещё не завершено.
2. После старта окна не было пользовательских сообщений (только технические). 
3. В наличии лишь технический voice (ошибка), а корректный ещё не дозагрузился.
4. Отключён `summary_v2` feature flag.

Диагностика:
* Логи `VOICE_CAPTURE transcript` – убедитесь что последний transcript не совпадает с паттернами ошибок.
* Проверить наличие `add_voice_transcript` вызовов до генерации.
* В случае многократных пустых ответов убедиться, что агент действительно стартовал до появления речи (timestamp окна).

Расширение (roadmap):
* Метрика Prometheus: количество пустых первых персональных сводок и процент последующих успешных догонок.
* Персистентное хранение окон (Redis) для горизонтального масштабирования без «холодного» старта.

- Non-root container user (prod Dockerfile uses `app`).
- Remove dev deps in prod image.
- Enable HTTPS everywhere (HSTS auto set in `APP_ENV=prod`).
- Regularly rotate JWT_SECRET (invalidate old tokens if needed).
- Implement WAF / rate limit via Redis already present.

---
This guide can be iterated further with Terraform / Ansible examples if required.

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\DEPLOYMENT.md =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile =====
--- SIZE: 666 bytes ---

.PHONY: run up down migrate makemigrations test lint fmt precommit install

install:
	poetry install

run:
	poetry run uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000 --reload

up:
	docker compose up --build

down:
	docker compose down -v

migrate:
	poetry run alembic upgrade head

makemigrations:
	poetry run alembic revision --autogenerate -m "auto"

test:
	poetry run pytest -q

lint:
	poetry run ruff check . && poetry run black --check . && poetry run isort --check-only .

fmt:
	poetry run ruff check . --fix; poetry run black .; poetry run isort .

precommit:
	poetry run pre-commit install -f --hook-type pre-commit

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\Makefile =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\__init__.py =====
--- SIZE: 152 bytes ---

"""Top-level package marker for adding 'webcall' root to sys.path if needed.

Tests rely on importing 'app', which lives inside this directory.
"""

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\aiosqlite\__init__.py =====
--- SIZE: 8849 bytes ---

"""Lightweight async wrapper around :mod:`sqlite3` for test environments.

This is not a full implementation of the upstream ``aiosqlite`` package, but
provides enough of the API surface for SQLAlchemy's ``sqlite+aiosqlite``
dialect that our test-suite relies on.  Operations execute synchronously while
protected by an :class:`asyncio.Lock`, which preserves the expected sequential
semantics without introducing background threads.

Only the pieces touched by the application (``connect`` returning an async
context manager, ``Connection``/``Cursor`` methods and attributes, and the
standard DB-API error types) are implemented.  The real library exposes more
helpers; if additional behaviour is required in future the module can be
extended incrementally.
"""

from __future__ import annotations

import asyncio
import sqlite3
from typing import Any, Iterable, Optional, Sequence

__all__ = [
    "connect",
    "Connection",
    "Cursor",
    "Row",
    "Error",
    "Warning",
    "InterfaceError",
    "DatabaseError",
    "DataError",
    "OperationalError",
    "IntegrityError",
    "InternalError",
    "ProgrammingError",
    "NotSupportedError",
    "sqlite_version",
    "sqlite_version_info",
]

# Re-export common sqlite error types so callers can rely on the standard
# DB-API exceptions exposed by the original library.
Error = sqlite3.Error
Warning = sqlite3.Warning
InterfaceError = sqlite3.InterfaceError
DatabaseError = sqlite3.DatabaseError
DataError = sqlite3.DataError
OperationalError = sqlite3.OperationalError
IntegrityError = sqlite3.IntegrityError
InternalError = sqlite3.InternalError
ProgrammingError = sqlite3.ProgrammingError
NotSupportedError = sqlite3.NotSupportedError

Row = sqlite3.Row
sqlite_version = sqlite3.sqlite_version
sqlite_version_info = sqlite3.sqlite_version_info


class Cursor:
    """Async wrapper over :class:`sqlite3.Cursor`."""

    def __init__(self, connection: "Connection", cursor: sqlite3.Cursor):
        self._connection = connection
        self._cursor = cursor

    # ---- standard cursor attributes ----
    @property
    def description(self):  # type: ignore[override]
        return self._cursor.description

    @property
    def rowcount(self) -> int:
        return self._cursor.rowcount

    @property
    def arraysize(self) -> int:
        return getattr(self._cursor, "arraysize", 1)

    @arraysize.setter
    def arraysize(self, value: int) -> None:
        try:
            self._cursor.arraysize = value
        except AttributeError:
            # ``sqlite3.Cursor`` always has ``arraysize``, but we guard just in case.
            pass

    @property
    def lastrowid(self) -> int:
        return self._cursor.lastrowid

    # ---- async helpers ----
    async def _run(self, func, *args, **kwargs):
        async with self._connection._lock:  # noqa: SLF001 - shared lock is intentional
            return func(*args, **kwargs)

    # ---- context manager protocol ----
    async def __aenter__(self) -> "Cursor":
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self.close()

    # ---- DB-API methods ----
    async def close(self) -> None:
        await self._run(self._cursor.close)

    async def execute(self, sql: str, parameters: Optional[Sequence[Any]] = None) -> "Cursor":
        if parameters is None:
            await self._run(self._cursor.execute, sql)
        else:
            await self._run(self._cursor.execute, sql, parameters)
        return self

    async def executemany(self, sql: str, seq_of_parameters: Iterable[Sequence[Any]]) -> "Cursor":
        await self._run(self._cursor.executemany, sql, seq_of_parameters)
        return self

    async def fetchone(self):
        return await self._run(self._cursor.fetchone)

    async def fetchmany(self, size: Optional[int] = None):
        n = size if size is not None else self.arraysize
        return await self._run(self._cursor.fetchmany, n)

    async def fetchall(self):
        return await self._run(self._cursor.fetchall)

    async def setinputsizes(self, *_sizes) -> None:
        # SQLite ignores setinputsizes – keep parity with the DB-API spec.
        return None

    def setoutputsize(self, _size, _column=None) -> None:
        return None

    async def callproc(self, *_args, **_kwargs):
        raise NotSupportedError("SQLite does not support stored procedures")

    async def nextset(self):
        return None

    def __aiter__(self):
        async def iterator():
            while True:
                row = await self.fetchone()
                if row is None:
                    break
                yield row

        return iterator()


class Connection:
    """Async wrapper over :class:`sqlite3.Connection`."""

    def __init__(self, connection: sqlite3.Connection):
        self._conn = connection
        self._lock = asyncio.Lock()

    async def _run(self, func, *args, **kwargs):
        async with self._lock:
            return func(*args, **kwargs)

    # ---- context manager protocol ----
    async def __aenter__(self) -> "Connection":
        return self

    async def __aexit__(self, exc_type, exc, tb) -> None:
        await self.close()

    # ---- high-level helpers ----
    async def cursor(self) -> Cursor:
        cursor = await self._run(self._conn.cursor)
        return Cursor(self, cursor)

    async def execute(self, sql: str, parameters: Optional[Sequence[Any]] = None) -> Cursor:
        cursor = await self.cursor()
        await cursor.execute(sql, parameters)
        return cursor

    async def executemany(self, sql: str, seq_of_parameters: Iterable[Sequence[Any]]) -> Cursor:
        cursor = await self.cursor()
        await cursor.executemany(sql, seq_of_parameters)
        return cursor

    async def executescript(self, script: str) -> Cursor:
        cursor = await self.cursor()
        await cursor._run(cursor._cursor.executescript, script)
        return cursor

    async def create_function(self, *args, **kwargs) -> None:
        await self._run(self._conn.create_function, *args, **kwargs)

    async def create_aggregate(self, *args, **kwargs) -> None:
        await self._run(self._conn.create_aggregate, *args, **kwargs)

    async def create_collation(self, *args, **kwargs) -> None:
        await self._run(self._conn.create_collation, *args, **kwargs)

    async def commit(self) -> None:
        await self._run(self._conn.commit)

    async def rollback(self) -> None:
        await self._run(self._conn.rollback)

    async def close(self) -> None:
        await self._run(self._conn.close)

    # ---- attribute proxies ----
    @property
    def row_factory(self):
        return self._conn.row_factory

    @row_factory.setter
    def row_factory(self, value):
        self._conn.row_factory = value

    @property
    def total_changes(self) -> int:
        return self._conn.total_changes

    @property
    def in_transaction(self) -> bool:
        return self._conn.in_transaction

    @property
    def isolation_level(self):
        return self._conn.isolation_level

    @isolation_level.setter
    def isolation_level(self, value):
        self._conn.isolation_level = value

    def __getattr__(self, item: str) -> Any:
        return getattr(self._conn, item)


class _ConnectFuture:
    """Awaitable helper that mirrors the behaviour of :func:`aiosqlite.connect`."""

    def __init__(self, database: str, args: tuple[Any, ...], kwargs: dict[str, Any]):
        self._database = database
        self._args = args
        self._kwargs = dict(kwargs)
        self.daemon = False  # SQLAlchemy flips this flag; we accept it for compatibility
        self._connection: Connection | None = None

    async def _ensure(self) -> Connection:
        if self._connection is None:
            params = dict(self._kwargs)
            if "check_same_thread" not in params:
                params["check_same_thread"] = False
            raw = sqlite3.connect(self._database, *self._args, **params)
            self._connection = Connection(raw)
        return self._connection

    def __await__(self):
        return self._ensure().__await__()

    async def __aenter__(self):
        return await self._ensure()

    async def __aexit__(self, exc_type, exc, tb):
        if self._connection is not None:
            await self._connection.close()
            self._connection = None


def connect(database: str, *args, **kwargs) -> _ConnectFuture:
    """Return an awaitable that yields a :class:`Connection`."""

    return _ConnectFuture(database, args, kwargs)


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\aiosqlite\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini =====
--- SIZE: 602 bytes ---

[alembic]
script_location = alembic
sqlalchemy.url = postgresql+asyncpg://webcall:secret@postgres:5432/webcall

[loggers]
keys = root,sqlalchemy,alembic

[handlers]
keys = console

[formatters]
keys = generic

[logger_root]
level = WARN
handlers = console

[logger_sqlalchemy]
level = WARN
handlers =
qualname = sqlalchemy.engine

[logger_alembic]
level = INFO
handlers = console
qualname = alembic

[handler_console]
class = StreamHandler
args = (sys.stderr,)
level = NOTSET
formatter = generic

[formatter_generic]
format = %(levelname)-5.5s [%(name)s] %(message)s

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic.ini =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\env.py =====
--- SIZE: 2054 bytes ---

from __future__ import annotations

import asyncio
from logging.config import fileConfig
import os
import sys

# Ensure project root is on PYTHONPATH so `import app` works when running alembic
CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, ".."))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine

from app.infrastructure.config import get_settings
from app.infrastructure.db.base import Base
from app.infrastructure.db import models  # noqa: F401

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)


def get_url() -> str:
    return get_settings().DATABASE_URL


def run_migrations_offline() -> None:
    url = get_url()
    context.configure(
        url=url,
        target_metadata=Base.metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=Base.metadata, compare_type=True)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    connectable = create_async_engine(get_url(), poolclass=pool.NullPool)

    async def run_migrations() -> None:
        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

    asyncio.run(run_migrations())


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\env.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\script.py.mako =====
--- SIZE: 524 bytes ---

"""${message and message + '\n'}Revision ID: ${up_revision}
Revises: ${', '.join(down_revision) if down_revision else None}
Create Date: ${create_date}
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '${up_revision}'
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else 'pass'}


def downgrade():
    ${downgrades if downgrades else 'pass'}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\script.py.mako =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0001_init.py =====
--- SIZE: 2448 bytes ---

from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = "0001_init"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "users",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("email", sa.String(254), nullable=False, unique=True, index=True),
        sa.Column("username", sa.String(50), nullable=False, unique=True, index=True),
        sa.Column("password_hash", sa.String(255), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "rooms",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("name", sa.String(100), nullable=False),
        sa.Column("owner_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("is_private", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
    )

    op.create_table(
        "participants",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("user_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("role", sa.String(20), nullable=False),
        sa.Column("muted", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("joined_at", sa.DateTime(timezone=False), nullable=False),
        sa.Column("left_at", sa.DateTime(timezone=False), nullable=True),
    )

    op.create_table(
        "messages",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("room_id", UUID(as_uuid=True), sa.ForeignKey("rooms.id"), nullable=False, index=True),
        sa.Column("author_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("content", sa.Text(), nullable=False),
        sa.Column("sent_at", sa.DateTime(timezone=False), nullable=False, index=True),
    )


def downgrade() -> None:
    op.drop_table("messages")
    op.drop_table("participants")
    op.drop_table("rooms")
    op.drop_table("users")

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0001_init.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0002_friends_push.py =====
--- SIZE: 1720 bytes ---

from __future__ import annotations

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID

# revision identifiers, used by Alembic.
revision = "0002_friends_push"
down_revision = "0001_init"
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "friendships",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("user_a_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("user_b_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("requested_by", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False),
        sa.Column("status", sa.String(20), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=False), nullable=False),
        sa.UniqueConstraint("user_a_id", "user_b_id", name="uq_friend_pair"),
    )

    op.create_table(
        "push_subscriptions",
        sa.Column("id", UUID(as_uuid=True), primary_key=True),
        sa.Column("user_id", UUID(as_uuid=True), sa.ForeignKey("users.id"), nullable=False, index=True),
        sa.Column("endpoint", sa.Text(), nullable=False),
        sa.Column("p256dh", sa.String(255), nullable=False),
        sa.Column("auth", sa.String(255), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=False), nullable=False),
        sa.UniqueConstraint("user_id", "endpoint", name="uq_push_user_endpoint"),
    )


def downgrade() -> None:
    op.drop_table("push_subscriptions")
    op.drop_table("friendships")

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0002_friends_push.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0003_direct_messages.py =====
--- SIZE: 1977 bytes ---

"""add direct_messages table

Revision ID: 0003_direct_messages
Revises: 0002_friends_push
Create Date: 2025-09-15
"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = "0003_direct_messages"
down_revision = "0002_friends_push"
branch_labels = None
depends_on = None


def upgrade() -> None:
    op.create_table(
        "direct_messages",
        sa.Column("id", sa.dialects.postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column("user_a_id", sa.dialects.postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("user_b_id", sa.dialects.postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("sender_id", sa.dialects.postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("ciphertext", sa.Text(), nullable=False),
        sa.Column("sent_at", sa.DateTime(timezone=False), nullable=False),
    )
    op.create_index("ix_direct_messages_user_a_id", "direct_messages", ["user_a_id"])
    op.create_index("ix_direct_messages_user_b_id", "direct_messages", ["user_b_id"])
    op.create_index("ix_direct_messages_sender_id", "direct_messages", ["sender_id"])
    op.create_index("ix_direct_messages_sent_at", "direct_messages", ["sent_at"])
    # Композитный индекс для выборки истории пары по времени
    op.create_index("ix_direct_pair_sent_at", "direct_messages", ["user_a_id", "user_b_id", "sent_at"])


def downgrade() -> None:
    op.drop_index("ix_direct_pair_sent_at", table_name="direct_messages")
    op.drop_index("ix_direct_messages_sent_at", table_name="direct_messages")
    op.drop_index("ix_direct_messages_sender_id", table_name="direct_messages")
    op.drop_index("ix_direct_messages_user_b_id", table_name="direct_messages")
    op.drop_index("ix_direct_messages_user_a_id", table_name="direct_messages")
    op.drop_table("direct_messages")

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0003_direct_messages.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0003_direct_reads.py =====
--- SIZE: 579 bytes ---

"""noop stub to linearize revisions

Revision ID: 0005_direct_reads_stub
Revises: 0004_direct_reads
Create Date: 2025-09-15
"""

from __future__ import annotations

from alembic import op  # noqa: F401
import sqlalchemy as sa  # noqa: F401

# revision identifiers, used by Alembic.
revision = '0005_direct_reads_stub'
down_revision = '0004_direct_reads'
branch_labels = None
depends_on = None


def upgrade():
	# No-op: this stub exists only to resolve previously duplicated migration filenames.
	pass


def downgrade():
	# No-op stub downgrade.
	pass

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0003_direct_reads.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0004_direct_reads.py =====
--- SIZE: 919 bytes ---

"""add direct_read_states table

Revision ID: 0004_direct_reads
Revises: 0003_direct_messages
Create Date: 2025-09-15
"""
from __future__ import annotations

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '0004_direct_reads'
down_revision = '0003_direct_messages'
branch_labels = None
depends_on = None


def upgrade():
    op.create_table(
        'direct_read_states',
        sa.Column('owner_id', sa.dialects.postgresql.UUID(as_uuid=True), sa.ForeignKey('users.id'), nullable=False),
        sa.Column('other_id', sa.dialects.postgresql.UUID(as_uuid=True), sa.ForeignKey('users.id'), nullable=False),
        sa.Column('last_read_at', sa.DateTime(timezone=False), nullable=False),
        sa.PrimaryKeyConstraint('owner_id', 'other_id', name='pk_direct_read_states')
    )


def downgrade():
    op.drop_table('direct_read_states')

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0004_direct_reads.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0005_add_user_public_key.py =====
--- SIZE: 530 bytes ---

"""add public_key to users

Revision ID: 0005_add_user_public_key
Revises: 0004_direct_reads
Create Date: 2025-09-16 00:00:00.000000
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '0005_add_user_public_key'
down_revision = '0004_direct_reads'
branch_labels = None
depends_on = None


def upgrade():
    op.add_column('users', sa.Column('public_key', sa.String(length=2000), nullable=True))


def downgrade():
    op.drop_column('users', 'public_key')

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0005_add_user_public_key.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0006_telegram_links.py =====
--- SIZE: 2661 bytes ---

"""telegram links table

Revision ID: 0006_telegram_links
Revises: 0005_add_user_public_key
Create Date: 2025-09-22 00:00:00.000000
"""
from alembic import op
import sqlalchemy as sa

revision = '0006_telegram_links'
# Исправлено: корректный предыдущий revision.
down_revision = '0005_add_user_public_key'
branch_labels = None
depends_on = None


def upgrade():
    # Идемпотентность: если таблица уже существует (например, применяли вручную), просто выходим.
    conn = op.get_bind()
    inspector = sa.inspect(conn)
    if 'telegram_links' in inspector.get_table_names():
        # Убедимся что недостающие индексы/констрейнты созданы (проверка по именам)
        existing_indexes = {ix['name'] for ix in inspector.get_indexes('telegram_links')}
        if 'ix_telegram_links_chat_id' not in existing_indexes:
            op.create_index('ix_telegram_links_chat_id', 'telegram_links', ['chat_id'])
        # Для уникального констрейнта проверяем pg catalog через простой запрос
        res = conn.execute(sa.text("""
            SELECT conname FROM pg_constraint c
            JOIN pg_class t ON c.conrelid = t.oid
            WHERE t.relname = 'telegram_links' AND conname = 'uq_user_chat_once'
        """)).fetchone()
        if not res:
            op.create_unique_constraint('uq_user_chat_once', 'telegram_links', ['user_id', 'chat_id'])
        return

    op.create_table(
        'telegram_links',
        sa.Column('user_id', sa.dialects.postgresql.UUID(as_uuid=True),
                  sa.ForeignKey('users.id', ondelete='CASCADE'), primary_key=True),
        sa.Column('token', sa.String(length=64), primary_key=True),
        sa.Column('chat_id', sa.String(length=64), nullable=True),
        sa.Column('status', sa.String(length=16), nullable=False),
        sa.Column('created_at', sa.DateTime(timezone=True), nullable=False),
        sa.Column('confirmed_at', sa.DateTime(timezone=True), nullable=True),
        sa.Column('expires_at', sa.DateTime(timezone=True), nullable=True),
    )
    op.create_index('ix_telegram_links_chat_id', 'telegram_links', ['chat_id'])
    op.create_unique_constraint('uq_user_chat_once', 'telegram_links', ['user_id', 'chat_id'])

def downgrade():
    op.drop_constraint('uq_user_chat_once', 'telegram_links', type_='unique')
    op.drop_index('ix_telegram_links_chat_id', table_name='telegram_links')
    op.drop_table('telegram_links')

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0006_telegram_links.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0007_user_ai_system_prompt.py =====
--- SIZE: 491 bytes ---

"""user ai_system_prompt

Revision ID: 0007_user_ai_system_prompt
Revises: 0006_telegram_links
Create Date: 2025-09-22 00:00:00.000001
"""
from alembic import op
import sqlalchemy as sa

revision = '0007_user_ai_system_prompt'
down_revision = '0006_telegram_links'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('users', sa.Column('ai_system_prompt', sa.Text(), nullable=True))


def downgrade():
    op.drop_column('users', 'ai_system_prompt')

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\alembic\versions\0007_user_ai_system_prompt.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\auth.py =====
--- SIZE: 1355 bytes ---

from __future__ import annotations

from pydantic import BaseModel, EmailStr, Field, model_validator


class RegisterInput(BaseModel):
    email: EmailStr
    username: str = Field(min_length=3, max_length=50)
    password: str = Field(min_length=6, max_length=128)
    secret: str = Field(min_length=1, description="Registration secret")


class RegisterOutput(BaseModel):
    id: str
    email: EmailStr
    username: str


class LoginInput(BaseModel):
    email: EmailStr
    password: str


class TokenOutput(BaseModel):
    access_token: str
    token_type: str = "bearer"


class UpdateProfileInput(BaseModel):
    email: EmailStr | None = None
    username: str | None = Field(default=None, min_length=3, max_length=50)


class ChangePasswordInput(BaseModel):
    # Старый пароль может быть короче (исторические учётки могли иметь 5 символов)
    old_password: str = Field(min_length=3, max_length=128)
    new_password: str = Field(min_length=6, max_length=128)

    @model_validator(mode='after')
    def passwords_different(self):  # type: ignore[override]
        if self.old_password == self.new_password:
            raise ValueError('Новый пароль не должен совпадать со старым')
        return self

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\auth.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\messages.py =====
--- SIZE: 369 bytes ---

from __future__ import annotations

from datetime import datetime
from pydantic import BaseModel, Field


class PostMessageInput(BaseModel):
    room_id: str
    author_id: str
    content: str = Field(min_length=1, max_length=2000)


class MessageDTO(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\messages.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\rooms.py =====
--- SIZE: 735 bytes ---

from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class CreateRoomInput(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomDTO(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class ListRoomsInput(BaseModel):
    owner_id: Optional[str] = None
    skip: int = 0
    limit: int = 50


class VisitedRoomDTO(BaseModel):
    room_id: str
    last_seen: datetime
    # optional metadata if room still exists
    name: Optional[str] = None
    owner_id: Optional[str] = None
    is_private: Optional[bool] = None

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\dto\rooms.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\auth.py =====
--- SIZE: 1669 bytes ---

from __future__ import annotations

from uuid import UUID

from ...core.domain.models import User
from ...core.errors import AuthError, ConflictError, NotFoundError
from ...core.ports.repositories import UserRepository
from ...core.ports.services import PasswordHasher, TokenProvider


class RegisterUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher) -> None:
        self.users = users
        self.hasher = hasher

    async def execute(self, email: str, username: str, password: str) -> User:
        if await self.users.get_by_email(email):
            raise ConflictError("Email already registered")
        if await self.users.get_by_username(username):
            raise ConflictError("Username already taken")
        pwd_hash = self.hasher.hash(password)
        user = User.create(email=email, username=username, password_hash=pwd_hash)
        await self.users.add(user)
        return user


class LoginUser:
    def __init__(self, users: UserRepository, hasher: PasswordHasher, tokens: TokenProvider) -> None:
        self.users = users
        self.hasher = hasher
        self.tokens = tokens

    async def execute(self, email: str, password: str) -> str:
        user = await self.users.get_by_email(email)
        # Keep error message generic (do not leak whether email exists)
        # Provide a user-friendly message in Russian so frontend can show it directly
        if not user or not self.hasher.verify(password, str(user.password_hash)):
            raise AuthError("Неверный email или пароль")
        return self.tokens.create_access_token(str(user.id), None)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\auth.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\messages.py =====
--- SIZE: 813 bytes ---

from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Message
from ...core.ports.repositories import MessageRepository


class PostMessage:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, author_id: UUID, content: str) -> Message:
        msg = Message.post(room_id=room_id, author_id=author_id, content=content)
        await self.messages.add(msg)
        return msg


class ListMessages:
    def __init__(self, messages: MessageRepository) -> None:
        self.messages = messages

    async def execute(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        return await self.messages.list(room_id=room_id, skip=skip, limit=limit)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\messages.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\participants.py =====
--- SIZE: 2678 bytes ---

from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Participant, Role
from ...core.errors import NotFoundError
from ...core.ports.repositories import ParticipantRepository, RoomRepository
from ...core.services.room_service import RoomService


class JoinRoom:
    def __init__(self, participants: ParticipantRepository, rooms: RoomRepository, policy: RoomService) -> None:
        self.participants = participants
        self.rooms = rooms
        self.policy = policy

    async def execute(self, room_id: UUID, user_id: UUID, role: Role = Role.member) -> Participant:
        room = await self.rooms.get(room_id)
        if not room:
            raise NotFoundError("Room not found")
        active = await self.participants.list_active(room_id)
        self.policy.can_join(room, active)
        participant = Participant.join(user_id=user_id, room_id=room_id, role=role)
        await self.participants.add(participant)
        return participant


class LeaveRoom:
    def __init__(self, participants: ParticipantRepository) -> None:
        self.participants = participants

    async def execute(self, room_id: UUID, user_id: UUID) -> None:
        p = await self.participants.get(room_id, user_id)
        if p:
            p.left_at = p.left_at or p.joined_at
            await self.participants.update(p)


class KickParticipant:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_kick(actor.role, target.role)
        await self.participants.remove(room_id, target_id)


class ToggleMute:
    def __init__(self, participants: ParticipantRepository, policy: RoomService) -> None:
        self.participants = participants
        self.policy = policy

    async def execute(self, room_id: UUID, actor_id: UUID, target_id: UUID) -> None:
        actor = await self.participants.get(room_id, actor_id)
        target = await self.participants.get(room_id, target_id)
        if not actor or not target:
            raise NotFoundError("Participants not found")
        self.policy.ensure_can_toggle_mute(actor.role, target.role)
        target.muted = not target.muted
        await self.participants.update(target)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\participants.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\rooms.py =====
--- SIZE: 1538 bytes ---

from __future__ import annotations

from typing import Optional
from uuid import UUID

from ...core.domain.models import Room
from ...core.errors import NotFoundError, ForbiddenError
from ...core.ports.repositories import RoomRepository


class CreateRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, name: str, owner_id: UUID, is_private: bool = False) -> Room:
        room = Room.create(name=name, owner_id=owner_id, is_private=is_private)
        await self.rooms.add(room)
        return room


class ListRooms:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, owner_id: Optional[UUID] = None, skip: int = 0, limit: int = 50) -> list[Room]:
        return await self.rooms.list(owner_id=owner_id, skip=skip, limit=limit)


class GetRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID) -> Optional[Room]:
        return await self.rooms.get(room_id)


class DeleteRoom:
    def __init__(self, rooms: RoomRepository) -> None:
        self.rooms = rooms

    async def execute(self, room_id: UUID, actor_id: UUID) -> None:
        room = await self.rooms.get(room_id)
        if not room:
            raise NotFoundError("Room not found")
        if room.owner_id != actor_id:
            raise ForbiddenError("Only owner can delete room")
        await self.rooms.delete(room_id)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\rooms.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\signals.py =====
--- SIZE: 619 bytes ---

from __future__ import annotations

from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class PublishSignal:
    def __init__(self, bus: SignalBus) -> None:
        self.bus = bus

    async def execute(
        self, *, room_id: UUID, sender_id: UUID, type: str, sdp: str | None = None, candidate: dict | None = None, target_id: UUID | None = None
    ) -> None:
        signal = Signal.create(type=type, sender_id=sender_id, room_id=room_id, sdp=sdp, candidate=candidate, target_id=target_id)
        await self.bus.publish(room_id, signal)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\application\use_cases\signals.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\asgi.py =====
--- SIZE: 90 bytes ---

from __future__ import annotations

from .main import create_app

app = create_app()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\asgi.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\main.py =====
--- SIZE: 13819 bytes ---

from __future__ import annotations

import logging
import time
import uuid
try:
    from prometheus_client import Counter, Histogram, generate_latest, CONTENT_TYPE_LATEST, Gauge as _Gauge
except Exception:  # pragma: no cover - prometheus optional until dependency installed
    Counter = Histogram = None  # type: ignore
    _Gauge = None  # type: ignore
    def generate_latest():  # type: ignore
        return b""
    CONTENT_TYPE_LATEST = "text/plain"
from contextlib import asynccontextmanager

from fastapi import Depends, FastAPI
from fastapi.responses import RedirectResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
import os
from pathlib import Path
# use FastAPI's http middleware decorator instead of importing starlette types

from ..infrastructure.config import get_settings
from ..infrastructure.logging import configure_logging
from ..presentation.docs import get_openapi_tags
from ..presentation.api.routers import auth as auth_router
from ..presentation.api.routers import rooms as rooms_router
from ..presentation.api.routers import participants as participants_router
from ..presentation.api.routers import messages as messages_router
from ..presentation.api.routers import webrtc as webrtc_router
from ..presentation.api.routers import friends as friends_router
from ..presentation.api.routers import push as push_router
from ..presentation.api.routers import users as users_router
from ..presentation.api.routers import direct as direct_router
from ..presentation.api.routers import telegram_link as telegram_router
from ..presentation.api.routers import ai_prompt as ai_prompt_router
from ..presentation.api.deps.containers import (
    get_user_repo,
    get_room_repo,
    get_participant_repo,
    get_message_repo,
    get_password_hasher,
    get_token_provider,
    get_signal_bus,
    get_ice_provider,
)
from ..presentation.ws import rooms as ws_rooms
from ..presentation.ws import friends as ws_friends
from ..presentation.ws import voice_capture as ws_voice
from ..presentation.api.deps.db import get_db_session
from ..infrastructure.db.repositories.users import PgUserRepository
from ..infrastructure.db.repositories.rooms import PgRoomRepository
from ..infrastructure.db.repositories.participants import PgParticipantRepository
from ..infrastructure.db.repositories.messages import PgMessageRepository
from ..infrastructure.security.jwt_provider import JoseTokenProvider
from ..infrastructure.security.password_hasher import BcryptPasswordHasher
from ..infrastructure.messaging.redis_bus import RedisSignalBus
from ..infrastructure.ice.provider import EnvIceConfigProvider
from ..presentation.errors import setup_error_handlers
from redis.asyncio import from_url as redis_from_url
from ..infrastructure.rate_limit.redis_rate_limiter import RedisRateLimiter, parse_rate

# --- Prometheus metric singletons (to avoid duplicate registration in tests) ---
# They are created lazily inside create_app() only once; subsequent create_app calls reuse them.
REQUEST_COUNT = None
REQ_LATENCY = None
WS_CONNECTIONS = None
CALL_SIGNAL_EVENTS = None
ACTIVE_WS = None
ACTIVE_CALLS = None
PENDING_INVITES = None


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Инициализация диспетчера Telegram (lazy start при первой очереди, но можно прогреть)
    try:
        from ..infrastructure.services.telegram_dispatcher import get_dispatcher
        dispatcher = get_dispatcher()
        dispatcher.start()
    except Exception as e:
        logging.getLogger("app.startup").warning("Failed to start telegram dispatcher: %s", e)
    try:
        yield
    finally:
        with contextlib.suppress(Exception):  # type: ignore[name-defined]
            from ..infrastructure.services.telegram_dispatcher import get_dispatcher as _gd
            d = _gd()
            await d.shutdown()


def create_app() -> FastAPI:
    settings = get_settings()
    configure_logging(logging.INFO)

    # В проде отключаем публичный доступ к документации и схеме
    is_docs_enabled = settings.APP_ENV in {"dev", "test"}
    app = FastAPI(
        title=settings.APP_NAME,
        description="WebRTC signaling server with REST and WebSocket",
        version="0.1.0",
        docs_url="/docs" if is_docs_enabled else None,
        redoc_url="/redoc" if is_docs_enabled else None,
        openapi_url="/openapi.json" if is_docs_enabled else None,
        openapi_tags=get_openapi_tags(),
        lifespan=lifespan,
    )

    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.CORS_ORIGINS,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # Security headers middleware: add common HTTP security headers to every response.
    @app.middleware("http")
    async def security_headers_middleware(request, call_next):
        response = await call_next(request)
        # Prevent MIME sniffing
        response.headers.setdefault("X-Content-Type-Options", "nosniff")
        # Clickjacking protection
        response.headers.setdefault("X-Frame-Options", "DENY")
        # Referrer policy
        response.headers.setdefault("Referrer-Policy", "no-referrer")
        # HSTS — only enable when running over HTTPS in production
        if settings.APP_ENV not in {"dev", "test"}:
            # one year, include subdomains, preload
            response.headers.setdefault("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload")
        # Content Security Policy — теперь без 'unsafe-inline' для скриптов.
        # Inline-скрипты вынесены в /static/js/boot.js. Разрешаем только self.
        # Оставляем 'unsafe-inline' в style-src временно из-за множества inline style атрибутов в HTML.
        # Для полного ужесточения можно будет удалить и его после рефакторинга inline style.
        csp = (
            "default-src 'self'; "
            "script-src 'self'; "
            "connect-src 'self' ws: wss:; "
            "img-src 'self' data:; "
            "style-src 'self' 'unsafe-inline'; "
            "font-src 'self' data:; "
            "object-src 'none'; base-uri 'none'; frame-ancestors 'none';"
        )
        response.headers.setdefault("Content-Security-Policy", csp)
        return response

    # Redis / Rate limiter init (lazy) — создаём один клиент
    redis_client = None
    rate_limiter: RedisRateLimiter | None = None
    if settings.RATE_LIMIT:
        try:
            redis_client = redis_from_url(settings.REDIS_URL, decode_responses=True)
            limit, window = parse_rate(settings.RATE_LIMIT)
            rate_limiter = RedisRateLimiter(redis_client, limit, window)
        except Exception as e:  # pragma: no cover - безопасная деградация
            logging.getLogger("app.rate").warning("RateLimiter init failed: %s", e)

    @app.middleware("http")
    async def rate_limit_middleware(request, call_next):  # type: ignore[override]
        if rate_limiter is None:
            return await call_next(request)
        try:
            # Определяем сущность: авторизованный user_id или IP
            user_id = getattr(getattr(request, 'state', None), 'auth_user_id', None)
            ident = user_id or request.headers.get('x-forwarded-for') or request.client.host  # type: ignore[attr-defined]
            path = request.url.path if hasattr(request, 'url') else 'unknown'
            bucket = f"{ident}:{path}" if ident else path
            allowed = await rate_limiter.allow(bucket)
            if not allowed:
                from fastapi import Response
                return Response(status_code=429, content='{"detail":"rate limit exceeded"}', media_type='application/json')
        except Exception:
            pass  # fail-open
        return await call_next(request)

    setup_error_handlers(app)

    # Observability middleware: assign request id & measure latency
    # Prometheus metrics objects (singletons) if library present
    global REQUEST_COUNT, REQ_LATENCY, WS_CONNECTIONS, CALL_SIGNAL_EVENTS, ACTIVE_WS, ACTIVE_CALLS, PENDING_INVITES
    if Counter and REQUEST_COUNT is None:
        try:
            REQUEST_COUNT = Counter('app_requests_total', 'Total HTTP requests', ['method', 'path', 'status'])
            REQ_LATENCY = Histogram('app_request_latency_ms', 'Request latency in ms', ['method', 'path']) if Histogram else None
            WS_CONNECTIONS = Counter('ws_connections_total', 'Total WS connections opened', ['channel'])
            CALL_SIGNAL_EVENTS = Counter('call_signal_events_total', 'Call signaling events', ['event'])
            if _Gauge:
                ACTIVE_WS = _Gauge('ws_active', 'Active WebSocket connections', ['channel'])
                ACTIVE_CALLS = _Gauge('calls_active', 'Active accepted calls')
                PENDING_INVITES = _Gauge('call_invites_pending', 'Pending call invites (approx)')
        except ValueError:
            # Already registered (e.g., in tests) – ignore and rely on existing collectors
            pass

    @app.middleware("http")
    async def request_id_timing_middleware(request, call_next):  # type: ignore[override]
        req_id = str(uuid.uuid4())
        start = time.perf_counter()
        # store in state for handlers/logging if needed
        request.state.request_id = req_id  # type: ignore[attr-defined]
        try:
            response = await call_next(request)
        finally:
            duration_ms = (time.perf_counter() - start) * 1000.0
            # Minimal structured log (structlog configured)
            logging.getLogger("app.request").info(
                "request",
                extra={
                    "request_id": req_id,
                    "method": getattr(request, 'method', '?'),
                    "path": getattr(request, 'url', '?'),
                    "duration_ms": round(duration_ms, 2),
                },
            )
            try:
                if REQUEST_COUNT and REQ_LATENCY:
                    path_label = request.url.path if hasattr(request, 'url') else '?'
                    REQUEST_COUNT.labels(getattr(request, 'method', '?'), path_label, getattr(response, 'status_code', 0)).inc()
                    REQ_LATENCY.labels(getattr(request, 'method', '?'), path_label).observe(duration_ms)
            except Exception:
                pass
        try:
            response.headers.setdefault("X-Request-ID", req_id)
            response.headers.setdefault("Server-Timing", f"app;dur={duration_ms:.2f}")
        except Exception:
            pass
        return response

    # Routers
    app.include_router(auth_router.router)
    app.include_router(rooms_router.router)
    app.include_router(participants_router.router)
    app.include_router(messages_router.router)
    app.include_router(webrtc_router.router)
    app.include_router(friends_router.router)
    app.include_router(push_router.router)
    app.include_router(users_router.router)
    app.include_router(direct_router.router)
    app.include_router(telegram_router.router)
    app.include_router(ai_prompt_router.router)
    logging.getLogger("app.startup").info("Telegram routes registered")

    # WS
    app.include_router(ws_rooms.router)
    app.include_router(ws_friends.router)
    app.include_router(ws_voice.router)

    # Static demo — use absolute path to avoid cwd-related issues and accidental exposure
    static_dir = str(Path(__file__).resolve().parent.parent.joinpath('presentation', 'static'))
    if os.path.isdir(static_dir):
        app.mount("/static", StaticFiles(directory=static_dir), name="static")
    else:
        # fallback to relative path if layout is unexpected
        app.mount("/static", StaticFiles(directory="app/presentation/static"), name="static")

    # Friendly entrypoints instead of /static/index.html
    @app.get("/", include_in_schema=False)
    async def root_redirect():
        return RedirectResponse(url="/call", status_code=307)

    @app.get("/call", include_in_schema=False)
    async def call_page():
        path = Path(static_dir).joinpath('index.html') if 'static_dir' in locals() else Path('app/presentation/static/index.html')
        return FileResponse(str(path))

    @app.get("/call/{room_id}", include_in_schema=False)
    async def call_page_room(room_id: str):  # room_id is used client-side from location
        path = Path(static_dir).joinpath('index.html') if 'static_dir' in locals() else Path('app/presentation/static/index.html')
        return FileResponse(str(path))

    @app.get("/auth", include_in_schema=False)
    async def auth_page():
        path = Path(static_dir).joinpath('auth.html') if 'static_dir' in locals() else Path('app/presentation/static/auth.html')
        return FileResponse(str(path))

    @app.get("/healthz", tags=["health"])
    async def healthz():
        return {"status": "ok"}

    @app.get("/metrics", include_in_schema=False)
    async def metrics():  # type: ignore[override]
        # If prometheus_client not installed, return empty set so that readiness probes succeed
        data = generate_latest()
        from fastapi import Response
        return Response(content=data, media_type=CONTENT_TYPE_LATEST)

    return app

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\bootstrap\main.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\models.py =====
--- SIZE: 4658 bytes ---

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Optional
from uuid import UUID, uuid4

from .values import Email, PasswordHash, RoomName, Username


class Role(str, Enum):
    owner = "owner"
    moderator = "moderator"
    member = "member"


@dataclass(slots=True)
class User:
    id: UUID
    email: Email
    username: Username
    password_hash: PasswordHash
    created_at: datetime
    public_key: str | None = None

    @staticmethod
    def create(email: str, username: str, password_hash: str) -> "User":
        return User(
            id=uuid4(),
            email=Email(email),
            username=Username(username),
            password_hash=PasswordHash(password_hash),
            created_at=datetime.utcnow(),
        )


@dataclass(slots=True)
class Room:
    id: UUID
    name: RoomName
    owner_id: UUID
    is_private: bool
    created_at: datetime

    @staticmethod
    def create(name: str, owner_id: UUID, is_private: bool = False) -> "Room":
        return Room(id=uuid4(), name=RoomName(name), owner_id=owner_id, is_private=is_private, created_at=datetime.utcnow())


@dataclass(slots=True)
class Participant:
    id: UUID
    user_id: UUID
    room_id: UUID
    role: Role
    muted: bool
    joined_at: datetime
    left_at: Optional[datetime] = None

    @staticmethod
    def join(user_id: UUID, room_id: UUID, role: Role) -> "Participant":
        return Participant(id=uuid4(), user_id=user_id, room_id=room_id, role=role, muted=False, joined_at=datetime.utcnow())


@dataclass(slots=True)
class Message:
    id: UUID
    room_id: UUID
    author_id: UUID
    content: str
    sent_at: datetime

    @staticmethod
    def post(room_id: UUID, author_id: UUID, content: str) -> "Message":
        return Message(id=uuid4(), room_id=room_id, author_id=author_id, content=content[:2000], sent_at=datetime.utcnow())


class SignalType(str, Enum):
    offer = "offer"
    answer = "answer"
    ice_candidate = "ice-candidate"


@dataclass(slots=True)
class Signal:
    type: SignalType
    sender_id: UUID
    room_id: UUID
    sent_at: datetime
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    target_id: Optional[UUID] = None

    @staticmethod
    def create(type: str, sender_id: UUID, room_id: UUID, sdp: Optional[str] = None, candidate: Optional[dict] = None, target_id: Optional[UUID] = None) -> "Signal":
        st = SignalType(type)
        return Signal(type=st, sender_id=sender_id, room_id=room_id, sent_at=datetime.utcnow(), sdp=sdp, candidate=candidate, target_id=target_id)


class FriendStatus(str, Enum):
    pending = "pending"
    accepted = "accepted"
    blocked = "blocked"


@dataclass(slots=True)
class Friendship:
    """Undirected friendship with deterministic ordering of user ids.

    user_a_id <= user_b_id lexicographically (as UUID string) to ensure uniqueness.
    """
    id: UUID
    user_a_id: UUID
    user_b_id: UUID
    requested_by: UUID
    status: FriendStatus
    created_at: datetime
    updated_at: datetime

    @staticmethod
    def pair(a: UUID, b: UUID, requested_by: UUID, status: FriendStatus = FriendStatus.pending) -> "Friendship":
        a_s, b_s = str(a), str(b)
        if a_s <= b_s:
            ua, ub = a, b
        else:
            ua, ub = b, a
        now = datetime.utcnow()
        return Friendship(id=uuid4(), user_a_id=ua, user_b_id=ub, requested_by=requested_by, status=status, created_at=now, updated_at=now)


@dataclass(slots=True)
class PushSubscription:
    id: UUID
    user_id: UUID
    endpoint: str
    p256dh: str
    auth: str
    created_at: datetime

    @staticmethod
    def create(user_id: UUID, endpoint: str, p256dh: str, auth: str) -> "PushSubscription":
        return PushSubscription(id=uuid4(), user_id=user_id, endpoint=endpoint, p256dh=p256dh, auth=auth, created_at=datetime.utcnow())


@dataclass(slots=True)
class DirectMessage:
    id: UUID
    user_a_id: UUID
    user_b_id: UUID
    sender_id: UUID
    ciphertext: str
    sent_at: datetime

    @staticmethod
    def create(user1: UUID, user2: UUID, sender_id: UUID, ciphertext: str) -> "DirectMessage":
        a_s, b_s = str(user1), str(user2)
        if a_s <= b_s:
            ua, ub = user1, user2
        else:
            ua, ub = user2, user1
        return DirectMessage(id=uuid4(), user_a_id=ua, user_b_id=ub, sender_id=sender_id, ciphertext=ciphertext, sent_at=datetime.utcnow())

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\models.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\values.py =====
--- SIZE: 1710 bytes ---

from __future__ import annotations

import re
from dataclasses import dataclass

from ..errors import ValidationError


EMAIL_RE = re.compile(r"^[^@\s]+@[^@\s]+\.[^@\s]+$")


@dataclass(frozen=True, slots=True)
class Email:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip().lower()
        if not EMAIL_RE.match(v):
            raise ValidationError("Invalid email format")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:  # for convenience
        return self.value


@dataclass(frozen=True, slots=True)
class RoomName:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip()
        if not (1 <= len(v) <= 100):
            raise ValidationError("Room name must be 1..100 chars")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:
        return self.value


@dataclass(frozen=True, slots=True)
class PasswordHash:
    value: str

    def __post_init__(self) -> None:
        if not self.value or len(self.value) < 10:
            # bcrypt hashes are long; minimal sanity check
            raise ValidationError("Password hash looks invalid")

    def __str__(self) -> str:
        return self.value


USERNAME_RE = re.compile(r"^[A-Za-z0-9_.-]{3,32}$")


@dataclass(frozen=True, slots=True)
class Username:
    value: str

    def __post_init__(self) -> None:
        v = self.value.strip()
        if not USERNAME_RE.match(v):
            raise ValidationError("Username must be 3-32 chars [A-Za-z0-9_.-]")
        object.__setattr__(self, "value", v)

    def __str__(self) -> str:  # convenience
        return self.value

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\domain\values.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\errors.py =====
--- SIZE: 586 bytes ---

from dataclasses import dataclass


class DomainError(Exception):
    """Базовая доменная ошибка."""


class ValidationError(DomainError):
    pass


class AuthError(DomainError):
    pass


class NotFoundError(DomainError):
    pass


class PermissionDenied(DomainError):
    pass

# Backwards compatibility alias after refactor (DeleteRoom use case expects ForbiddenError)
class ForbiddenError(PermissionDenied):
    pass


class ConflictError(DomainError):
    pass


@dataclass(slots=True)
class ErrorResponse:
    detail: str

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\errors.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\repositories.py =====
--- SIZE: 8090 bytes ---

from __future__ import annotations

from abc import ABC, abstractmethod
from typing import Iterable, Optional
from datetime import datetime
from uuid import UUID

from ..domain.models import Message, Participant, Room, User, Friendship, FriendStatus, PushSubscription, DirectMessage


class UserRepository(ABC):
    @abstractmethod
    async def get_by_email(self, email: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_username(self, username: str) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def get_by_id(self, user_id: UUID) -> Optional[User]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, user: User) -> None:
        raise NotImplementedError

    @abstractmethod
    async def search(self, query: str, limit: int = 10) -> list[User]:
        """Search users by username or email (case-insensitive)."""
        raise NotImplementedError

    @abstractmethod
    async def update_profile(self, user_id: UUID, *, email: str | None = None, username: str | None = None) -> User | None:
        """Update email and/or username. Return updated user or None if not found.

        Implementations must enforce uniqueness and raise ConflictError on duplicates.
        """
        raise NotImplementedError

    @abstractmethod
    async def update_password(self, user_id: UUID, password_hash: str) -> bool:
        """Update user's password hash. Return True if user existed and was updated."""
        raise NotImplementedError


class RoomRepository(ABC):
    @abstractmethod
    async def add(self, room: Room) -> None:
        raise NotImplementedError

    @abstractmethod
    async def get(self, room_id: UUID) -> Optional[Room]:
        raise NotImplementedError

    @abstractmethod
    async def get_many(self, ids: Iterable[UUID]) -> list[Room]:
        """Fetch multiple rooms by ids in a single call (order not guaranteed)."""
        raise NotImplementedError

    @abstractmethod
    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:
        raise NotImplementedError

    @abstractmethod
    async def delete(self, room_id: UUID) -> None:
        raise NotImplementedError


class ParticipantRepository(ABC):
    @abstractmethod
    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def get_active(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:
        """Return active (left_at is NULL) participant record for the user in room, if any."""
        raise NotImplementedError

    @abstractmethod
    async def list_active(self, room_id: UUID) -> list[Participant]:
        raise NotImplementedError

    @abstractmethod
    async def add(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def update(self, participant: Participant) -> None:
        raise NotImplementedError

    @abstractmethod
    async def remove(self, room_id: UUID, user_id: UUID) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_visited_rooms(self, user_id: UUID, skip: int = 0, limit: int = 50) -> list[tuple[UUID, datetime]]:
        """Return distinct rooms visited by user with last seen timestamp, ordered by last_seen desc.

        Items are tuples of (room_id, last_seen_at).
        """
        raise NotImplementedError


class MessageRepository(ABC):
    @abstractmethod
    async def add(self, message: Message) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:
        raise NotImplementedError


class FriendshipRepository(ABC):
    @abstractmethod
    async def get_pair(self, user_a: UUID, user_b: UUID) -> Friendship | None:
        """Return friendship record for an unordered pair of users."""
        raise NotImplementedError

    @abstractmethod
    async def list_friends(self, user_id: UUID, status: FriendStatus = FriendStatus.accepted) -> list[Friendship]:
        raise NotImplementedError

    @abstractmethod
    async def list_requests(self, user_id: UUID) -> list[Friendship]:
        """List incoming pending requests for user."""
        raise NotImplementedError

    @abstractmethod
    async def add(self, f: Friendship) -> None:
        raise NotImplementedError

    @abstractmethod
    async def update(self, f: Friendship) -> None:
        raise NotImplementedError

    @abstractmethod
    async def remove(self, user_a: UUID, user_b: UUID) -> None:
        """Удалить дружбу (неупорядоченную пару пользователей), если существует.

        Пара (user_a,user_b) трактуется как неупорядоченная: реализация должна
        привести её к детерминированному порядку перед удалением.
        Отсутствие записи не считается ошибкой.
        """
        raise NotImplementedError


class PushSubscriptionRepository(ABC):
    @abstractmethod
    async def add(self, sub: PushSubscription) -> None:
        raise NotImplementedError

    @abstractmethod
    async def remove(self, user_id: UUID, endpoint: str) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_by_user(self, user_id: UUID) -> list[PushSubscription]:
        raise NotImplementedError


class DirectMessageRepository(ABC):
    @abstractmethod
    async def add(self, dm: DirectMessage) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_pair(self, user_a: UUID, user_b: UUID, limit: int = 50, before: UUID | None = None) -> list[DirectMessage]:
        """Список сообщений между двумя пользователями (упорядоченных по sent_at desc).

        Аргумент before (message id) может использоваться для пагинации (сообщения строго раньше указанного).
        """
        raise NotImplementedError

    @abstractmethod
    async def delete_pair(self, user_a: UUID, user_b: UUID) -> int:
        """Удалить всю переписку между двумя пользователями.

        Возвращает количество удалённых сообщений (для потенциального аудита/логов).
        Пара пользователей рассматривается как неупорядоченная.
        """
        raise NotImplementedError

    @abstractmethod
    async def count_unread(self, user_id: UUID, friend_id: UUID, since: datetime | None) -> int:
        """Подсчитать количество непрочитанных сообщений для пользователя от друга.

        Используется правило: сообщения, где sender_id != user_id и sent_at > (since or эпоха).
        Репозиторий обязан трактовать пару (user_id, friend_id) как неупорядоченную.
        """
        raise NotImplementedError


class DirectReadStateRepository(ABC):
    @abstractmethod
    async def get_last_read(self, user_id: UUID, friend_id: UUID) -> datetime | None:
        """Вернуть момент последнего прочтения переписки user_id<->friend_id пользователем user_id."""
        raise NotImplementedError

    @abstractmethod
    async def set_last_read(self, user_id: UUID, friend_id: UUID, when: datetime) -> None:
        """Обновить момент последнего прочтения (upsert)."""
        raise NotImplementedError

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\repositories.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\services.py =====
--- SIZE: 3333 bytes ---

from __future__ import annotations

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any
from uuid import UUID

from ..domain.models import Signal


class SignalBus(ABC):
    @abstractmethod
    async def publish(self, room_id: UUID, signal: Signal) -> None:
        raise NotImplementedError

    @abstractmethod
    async def subscribe(self, room_id: UUID):
        """Возвращает асинхронный итератор по сообщениям Signal."""
        raise NotImplementedError

    @abstractmethod
    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        raise NotImplementedError

    @abstractmethod
    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        raise NotImplementedError


class PasswordHasher(ABC):
    @abstractmethod
    def hash(self, password: str) -> str:
        raise NotImplementedError

    @abstractmethod
    def verify(self, password: str, password_hash: str) -> bool:
        raise NotImplementedError


class TokenProvider(ABC):
    @abstractmethod
    def create_access_token(self, subject: str, expires_minutes: int) -> str:
        raise NotImplementedError

    @abstractmethod
    def decode_token(self, token: str) -> dict:
        raise NotImplementedError


class Clock(ABC):
    @abstractmethod
    def now(self) -> datetime:
        raise NotImplementedError


class IceConfigProvider(ABC):
    @abstractmethod
    async def get_servers(self) -> list[dict]:
        raise NotImplementedError

class PushNotifier(ABC):
    """Отправка push/webpush уведомлений.

    NOTE: Интерфейс восстановлен после очистки. Если останется неиспользованным в рабочем коде и тестах,
    может быть помечен как @deprecated перед финальным удалением в отдельном PR.
    """

    @abstractmethod
    async def notify_incoming_call(self, to_user_id: UUID, from_user_id: UUID, from_username: str | None, room_id: str) -> None:  # pragma: no cover - интерфейс
        raise NotImplementedError


class CallInviteService(ABC):
    """Сервис управления приглашениями к звонку (in-memory или внешнее хранилище)."""

    @abstractmethod
    async def invite(self, from_user_id: UUID, to_user_id: UUID, room_id: str, from_username: str | None, from_email: str | None) -> None:  # pragma: no cover - интерфейс
        raise NotImplementedError

    @abstractmethod
    async def accept(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:  # pragma: no cover
        raise NotImplementedError

    @abstractmethod
    async def decline(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:  # pragma: no cover
        raise NotImplementedError

    @abstractmethod
    async def cancel(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:  # pragma: no cover
        raise NotImplementedError

    @abstractmethod
    async def list_pending_for(self, user_id: UUID) -> list[dict]:  # pragma: no cover
        raise NotImplementedError

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\ports\services.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\room_service.py =====
--- SIZE: 1471 bytes ---

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Iterable
from uuid import UUID

from ..domain.models import Participant, Role, Room
from ..errors import PermissionDenied, ValidationError


@dataclass(slots=True)
class RoomPolicy:
    max_participants: int = 16


class RoomService:
    def __init__(self, policy: RoomPolicy | None = None) -> None:
        self.policy = policy or RoomPolicy()

    def can_join(self, room: Room, participants: Iterable[Participant]) -> None:
        count = sum(1 for p in participants if p.left_at is None)
        if count >= self.policy.max_participants:
            raise ValidationError("Room is full")

    def ensure_can_kick(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can kick")
        if actor_role == Role.moderator and target_role in {Role.owner, Role.moderator}:
            raise PermissionDenied("Moderator cannot kick owner/moderator")

    def ensure_can_toggle_mute(self, actor_role: Role, target_role: Role) -> None:
        if actor_role == Role.member:
            raise PermissionDenied("Only owner/moderator can mute")

    def leave(self, participant: Participant) -> Participant:
        if participant.left_at is None:
            participant.left_at = datetime.utcnow()
        return participant

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\core\services\room_service.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\config.py =====
--- SIZE: 4818 bytes ---

from __future__ import annotations

from functools import lru_cache
from typing import List

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    model_config = SettingsConfigDict(env_file=".env", env_file_encoding="utf-8", case_sensitive=False)

    # App
    APP_NAME: str = "WebCall"
    APP_ENV: str = "dev"
    API_PREFIX: str = "/api/v1"
    HOST: str = "0.0.0.0"
    PORT: int = 8000

    # Security
    JWT_SECRET: str  # must be provided via .env
    JWT_EXPIRES_MIN: int = 60
    # Registration secret (mandatory gate for /auth/register)
    REGISTRATION_SECRET: str  # must be provided via .env

    # Databases
    DATABASE_URL: str
    REDIS_URL: str

    # CORS
    CORS_ORIGINS: List[str] = Field(default_factory=lambda: ["http://localhost:5173", "http://localhost:8000"])  # type: ignore[assignment]

    # WebRTC ICE
    STUN_SERVERS: List[str] = Field(default_factory=lambda: ["stun:stun.l.google.com:19302"])  # type: ignore[assignment]
    # Поддерживаем как одиночный TURN_URL, так и список TURN_URLS для UDP/TCP
    TURN_URLS: List[str] | None = None  # type: ignore[assignment]
    TURN_URL: str | None = None
    TURN_USERNAME: str | None = None
    TURN_PASSWORD: str | None = None
    # TURN доп переменные
    TURN_PUBLIC_IP: str | None = None
    TURN_REALM: str | None = None
    TURN_CLI_PASSWORD: str | None = None  # чтобы не валилось на extra (используется только для запуска coturn)

    # Доп: пароль Postgres (может понадобиться для генерации URL или вспомогательных задач)
    POSTGRES_PASSWORD: str | None = None

    # Web Push (VAPID)
    VAPID_PUBLIC_KEY: str | None = None
    VAPID_PRIVATE_KEY: str | None = None
    VAPID_SUBJECT: str | None = None

    # Rate limiting (формат: "<limit>/<window_sec>") например 100/60
    RATE_LIMIT: str | None = None
    # Backend приглашений звонков: memory | redis
    CALL_INVITES_BACKEND: str = "memory"

    # AI Summaries / Telegram
    AI_SUMMARY_ENABLED: bool = False  # включение функционала AI выжимок
    AI_MODEL_PROVIDER: str | None = None  # имя провайдера/модели (например 'openai:gpt-4o-mini'), пока не используется напрямую
    AI_SUMMARY_MAX_MESSAGES: int = 200  # лимит сообщений для одного резюме (хвост обрезается)
    AI_SUMMARY_MIN_CHARS: int = 60  # минимальный объём текста (символов) чтобы считать summary содержательным
    # Включает формирование разбивки summary по участникам (персональные вклады)
    AI_SUMMARY_PARTICIPANT_BREAKDOWN: bool = False
    TELEGRAM_BOT_TOKEN: str | None = None  # токен бота для отправки итоговых выжимок
    TELEGRAM_CHAT_ID: str | None = None  # (устаревшее) глобальный chat id; если установлен используется как fallback
    TELEGRAM_BOT_NAME: str | None = None  # username бота без @ для генерации deep-link
    OPENAI_API_KEY: str | None = None  # ключ OpenAI (НЕ хранить в репо)
    AI_MODEL_FALLBACK: str | None = None  # запасная модель если основная недоступна
    # Voice capture / ASR
    VOICE_CAPTURE_ENABLED: bool = False
    VOICE_CHUNK_MAX_MS: int = 5000  # длительность сегмента MediaRecorder
    VOICE_ASR_MODEL: str = "whisper-1"  # модель для распознавания (OpenAI)
    VOICE_MAX_TOTAL_MB: int = 30  # ограничение на суммарный объём аудиоданных


@lru_cache()
def get_settings() -> Settings:
    s = Settings()
    # allow comma-separated env for lists
    if isinstance(s.CORS_ORIGINS, str):  # type: ignore[unreachable]
        s.CORS_ORIGINS = [x.strip() for x in s.CORS_ORIGINS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if isinstance(s.STUN_SERVERS, str):  # type: ignore[unreachable]
        s.STUN_SERVERS = [x.strip() for x in s.STUN_SERVERS.split(",") if x.strip()]  # type: ignore[attr-defined]
    # Нормализуем TURN_URLS / TURN_URL
    if isinstance(s.TURN_URLS, str):  # type: ignore[unreachable]
        s.TURN_URLS = [x.strip() for x in s.TURN_URLS.split(",") if x.strip()]  # type: ignore[attr-defined]
    if not s.TURN_URLS and s.TURN_URL:
        s.TURN_URLS = [s.TURN_URL]
    return s

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\config.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\base.py =====
--- SIZE: 287 bytes ---

from __future__ import annotations

from sqlalchemy.orm import DeclarativeBase, declared_attr


class Base(DeclarativeBase):
    __abstract__ = True

    @declared_attr.directive
    def __tablename__(cls) -> str:  # type: ignore[override]
        return cls.__name__.lower()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\base.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\models.py =====
--- SIZE: 6825 bytes ---

from __future__ import annotations

from datetime import datetime
from uuid import UUID

from sqlalchemy import Boolean, DateTime, ForeignKey, String, Text, UniqueConstraint
from sqlalchemy.dialects.postgresql import UUID as PGUUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from .base import Base


class Users(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    email: Mapped[str] = mapped_column(String(254), unique=True, index=True, nullable=False)
    username: Mapped[str] = mapped_column(String(50), unique=True, index=True, nullable=False)
    password_hash: Mapped[str] = mapped_column(String(255), nullable=False)
    public_key: Mapped[str | None] = mapped_column(String(2000), nullable=True)
    ai_system_prompt: Mapped[str | None] = mapped_column(Text, nullable=True)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    # Связь с созданными пользователем комнатами (users.id -> rooms.owner_id)
    rooms = relationship("Rooms", back_populates="owner", foreign_keys="Rooms.owner_id")


class Rooms(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    name: Mapped[str] = mapped_column(String(100), nullable=False)
    owner_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    is_private: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    # Владелец комнаты (rooms.owner_id -> users.id)
    owner = relationship("Users", back_populates="rooms", foreign_keys=[owner_id])


class Participants(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    user_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    role: Mapped[str] = mapped_column(String(20), nullable=False)
    muted: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)
    joined_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    left_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False), nullable=True)


class Messages(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    room_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("rooms.id"), index=True, nullable=False)
    author_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    content: Mapped[str] = mapped_column(Text, nullable=False)
    sent_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False, index=True)


class Friendships(Base):
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    user_a_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    user_b_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    requested_by: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    status: Mapped[str] = mapped_column(String(20), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    updated_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    __table_args__ = (
        UniqueConstraint("user_a_id", "user_b_id", name="uq_friend_pair"),
    )


class PushSubscriptions(Base):
    __tablename__ = "push_subscriptions"
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    user_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey("users.id"), index=True, nullable=False)
    endpoint: Mapped[str] = mapped_column(Text, nullable=False)
    p256dh: Mapped[str] = mapped_column(String(255), nullable=False)
    auth: Mapped[str] = mapped_column(String(255), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)

    __table_args__ = (
        UniqueConstraint("user_id", "endpoint", name="uq_push_user_endpoint"),
    )


class DirectMessages(Base):
    __tablename__ = 'direct_messages'
    id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), primary_key=True)
    user_a_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey('users.id'), index=True, nullable=False)
    user_b_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey('users.id'), index=True, nullable=False)
    sender_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey('users.id'), index=True, nullable=False)
    ciphertext: Mapped[str] = mapped_column(Text, nullable=False)
    sent_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), index=True, nullable=False)
    __table_args__ = (
        UniqueConstraint('id', name='uq_direct_msg_id'),
    )


class DirectReadStates(Base):
    __tablename__ = 'direct_read_states'
    owner_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey('users.id'), primary_key=True)
    other_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey('users.id'), primary_key=True)
    last_read_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)


class TelegramLinks(Base):
    """Привязка пользователя к Telegram chat_id через одноразовый token.

    Статусы:
      pending  – создан токен, ждём подтверждения через /start <token>
      confirmed – chat_id зафиксирован, можно слать summary
      expired  – токен истёк без подтверждения
    """
    __tablename__ = 'telegram_links'
    user_id: Mapped[UUID] = mapped_column(PGUUID(as_uuid=True), ForeignKey('users.id'), primary_key=True)
    token: Mapped[str] = mapped_column(String(64), primary_key=True)
    chat_id: Mapped[str | None] = mapped_column(String(64), nullable=True, index=True)
    status: Mapped[str] = mapped_column(String(16), nullable=False)
    created_at: Mapped[datetime] = mapped_column(DateTime(timezone=False), nullable=False)
    confirmed_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False), nullable=True)
    expires_at: Mapped[datetime | None] = mapped_column(DateTime(timezone=False), nullable=True)

    __table_args__ = (
        UniqueConstraint('user_id', 'chat_id', name='uq_user_chat_once'),
    )

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\models.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\direct_messages.py =====
--- SIZE: 3625 bytes ---

from __future__ import annotations

from typing import List
from uuid import UUID

from sqlalchemy import select, and_, desc, delete, func
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import DirectMessage
from ....core.ports.repositories import DirectMessageRepository
from .. import models as m


class PgDirectMessageRepository(DirectMessageRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, dm: DirectMessage) -> None:  # type: ignore[override]
        row = m.DirectMessages(
            id=dm.id,
            user_a_id=dm.user_a_id,
            user_b_id=dm.user_b_id,
            sender_id=dm.sender_id,
            ciphertext=dm.ciphertext,
            sent_at=dm.sent_at,
        )
        self.session.add(row)
        await self.session.commit()

    async def list_pair(self, user_a: UUID, user_b: UUID, limit: int = 50, before: UUID | None = None) -> List[DirectMessage]:  # type: ignore[override]
        a_s, b_s = str(user_a), str(user_b)
        if a_s <= b_s:
            ua, ub = user_a, user_b
        else:
            ua, ub = user_b, user_a
        stmt = select(m.DirectMessages).where(and_(m.DirectMessages.user_a_id == ua, m.DirectMessages.user_b_id == ub))
        if before:
            # Понадобится получить sent_at указанного сообщения и фильтровать по времени
            sub = select(m.DirectMessages.sent_at).where(m.DirectMessages.id == before).scalar_subquery()
            stmt = stmt.where(m.DirectMessages.sent_at < sub)
        stmt = stmt.order_by(desc(m.DirectMessages.sent_at)).limit(limit)
        rows = (await self.session.execute(stmt)).scalars().all()
        result: List[DirectMessage] = []
        for r in rows:
            result.append(DirectMessage(
                id=r.id,
                user_a_id=r.user_a_id,
                user_b_id=r.user_b_id,
                sender_id=r.sender_id,
                ciphertext=r.ciphertext,
                sent_at=r.sent_at,
            ))
        return result

    async def delete_pair(self, user_a: UUID, user_b: UUID) -> int:  # type: ignore[override]
        a_s, b_s = str(user_a), str(user_b)
        if a_s <= b_s:
            ua, ub = user_a, user_b
        else:
            ua, ub = user_b, user_a
        # Выполним удаление и получим число удалённых строк по rowcount
        stmt = delete(m.DirectMessages).where(and_(m.DirectMessages.user_a_id == ua, m.DirectMessages.user_b_id == ub))
        res = await self.session.execute(stmt)
        deleted = res.rowcount if res.rowcount is not None else 0
        await self.session.commit()
        return deleted

    async def count_unread(self, user_id: UUID, friend_id: UUID, since: datetime | None) -> int:  # type: ignore[override]
        a_s, b_s = str(user_id), str(friend_id)
        if a_s <= b_s:
            ua, ub = user_id, friend_id
        else:
            ua, ub = friend_id, user_id
        stmt = select(func.count()).select_from(m.DirectMessages).where(
            and_(
                m.DirectMessages.user_a_id == ua,
                m.DirectMessages.user_b_id == ub,
                m.DirectMessages.sender_id != user_id,
            )
        )
        if since is not None:
            stmt = stmt.where(m.DirectMessages.sent_at > since)
        res = await self.session.execute(stmt)
        cnt = res.scalar_one() or 0
        return int(cnt)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\direct_messages.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\direct_reads.py =====
--- SIZE: 1578 bytes ---

from __future__ import annotations

from datetime import datetime
from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.ports.repositories import DirectReadStateRepository
from ..models import DirectReadStates


class PgDirectReadStateRepository(DirectReadStateRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_last_read(self, user_id: UUID, friend_id: UUID) -> datetime | None:  # type: ignore[override]
        res = await self.session.execute(
            select(DirectReadStates).where(
                (DirectReadStates.owner_id == user_id) & (DirectReadStates.other_id == friend_id)
            )
        )
        row = res.scalars().first()
        return row.last_read_at if row else None

    async def set_last_read(self, user_id: UUID, friend_id: UUID, when: datetime) -> None:  # type: ignore[override]
        # upsert-поведение: попробуем загрузить, затем вставить/обновить
        res = await self.session.execute(
            select(DirectReadStates).where(
                (DirectReadStates.owner_id == user_id) & (DirectReadStates.other_id == friend_id)
            )
        )
        row = res.scalars().first()
        if row:
            row.last_read_at = when
        else:
            row = DirectReadStates(owner_id=user_id, other_id=friend_id, last_read_at=when)
            self.session.add(row)
        await self.session.commit()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\direct_reads.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\friends.py =====
--- SIZE: 3613 bytes ---

from __future__ import annotations

from typing import List, Optional
from uuid import UUID

from sqlalchemy import and_, or_, select, update
from sqlalchemy import delete
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Friendship, FriendStatus
from ....core.ports.repositories import FriendshipRepository
from ..models import Friendships


def _order_pair(a: UUID, b: UUID) -> tuple[UUID, UUID]:
    return (a, b) if str(a) <= str(b) else (b, a)


class PgFriendshipRepository(FriendshipRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_pair(self, user_a: UUID, user_b: UUID) -> Optional[Friendship]:  # type: ignore[override]
        ua, ub = _order_pair(user_a, user_b)
        stmt = select(Friendships).where(and_(Friendships.user_a_id == ua, Friendships.user_b_id == ub))
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if not row:
            return None
        return Friendship(id=row.id, user_a_id=row.user_a_id, user_b_id=row.user_b_id, requested_by=row.requested_by, status=FriendStatus(row.status), created_at=row.created_at, updated_at=row.updated_at)

    async def list_friends(self, user_id: UUID, status: FriendStatus = FriendStatus.accepted) -> List[Friendship]:  # type: ignore[override]
        stmt = select(Friendships).where(and_(or_(Friendships.user_a_id == user_id, Friendships.user_b_id == user_id), Friendships.status == status.value))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Friendship(id=r.id, user_a_id=r.user_a_id, user_b_id=r.user_b_id, requested_by=r.requested_by, status=FriendStatus(r.status), created_at=r.created_at, updated_at=r.updated_at) for r in rows]

    async def list_requests(self, user_id: UUID) -> List[Friendship]:  # type: ignore[override]
        stmt = select(Friendships).where(and_(or_(Friendships.user_a_id == user_id, Friendships.user_b_id == user_id), Friendships.status == FriendStatus.pending.value, Friendships.requested_by != user_id))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Friendship(id=r.id, user_a_id=r.user_a_id, user_b_id=r.user_b_id, requested_by=r.requested_by, status=FriendStatus(r.status), created_at=r.created_at, updated_at=r.updated_at) for r in rows]

    async def add(self, f: Friendship) -> None:  # type: ignore[override]
        ua, ub = _order_pair(f.user_a_id, f.user_b_id)
        self.session.add(
            Friendships(
                id=f.id,
                user_a_id=ua,
                user_b_id=ub,
                requested_by=f.requested_by,
                status=f.status.value,
                created_at=f.created_at,
                updated_at=f.updated_at,
            )
        )
        await self.session.commit()

    async def update(self, f: Friendship) -> None:  # type: ignore[override]
        await self.session.execute(
            update(Friendships)
            .where(Friendships.id == f.id)
            .values(status=f.status.value, requested_by=f.requested_by, updated_at=f.updated_at)
        )
        await self.session.commit()

    async def remove(self, user_a: UUID, user_b: UUID) -> None:  # type: ignore[override]
        ua, ub = _order_pair(user_a, user_b)
        await self.session.execute(
            delete(Friendships).where(and_(Friendships.user_a_id == ua, Friendships.user_b_id == ub))
        )
        await self.session.commit()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\friends.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\messages.py =====
--- SIZE: 1274 bytes ---

from __future__ import annotations

from uuid import UUID

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Message
from ....core.ports.repositories import MessageRepository
from ..models import Messages


class PgMessageRepository(MessageRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, message: Message) -> None:  # type: ignore[override]
        self.session.add(
            Messages(
                id=message.id,
                room_id=message.room_id,
                author_id=message.author_id,
                content=message.content,
                sent_at=message.sent_at,
            )
        )
        await self.session.commit()

    async def list(self, room_id: UUID, skip: int = 0, limit: int = 50) -> list[Message]:  # type: ignore[override]
        stmt = select(Messages).where(Messages.room_id == room_id).order_by(Messages.sent_at.asc()).offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Message(id=r.id, room_id=r.room_id, author_id=r.author_id, content=r.content, sent_at=r.sent_at) for r in rows]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\messages.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\participants.py =====
--- SIZE: 4381 bytes ---

from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import delete, select, update, func
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Participant, Role
from ....core.ports.repositories import ParticipantRepository
from ..models import Participants


class PgParticipantRepository(ParticipantRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return Participant(
                id=row.id,
                user_id=row.user_id,
                room_id=row.room_id,
                role=Role(row.role),
                muted=row.muted,
                joined_at=row.joined_at,
                left_at=row.left_at,
            )
        return None

    async def list_active(self, room_id: UUID) -> list[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(Participants.room_id == room_id, Participants.left_at.is_(None))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [
            Participant(id=r.id, user_id=r.user_id, room_id=r.room_id, role=Role(r.role), muted=r.muted, joined_at=r.joined_at, left_at=r.left_at)
            for r in rows
        ]

    async def get_active(self, room_id: UUID, user_id: UUID) -> Optional[Participant]:  # type: ignore[override]
        stmt = select(Participants).where(
            Participants.room_id == room_id, Participants.user_id == user_id, Participants.left_at.is_(None)
        )
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return Participant(
                id=row.id,
                user_id=row.user_id,
                room_id=row.room_id,
                role=Role(row.role),
                muted=row.muted,
                joined_at=row.joined_at,
                left_at=row.left_at,
            )
        return None

    async def add(self, participant: Participant) -> None:  # type: ignore[override]
        self.session.add(
            Participants(
                id=participant.id,
                user_id=participant.user_id,
                room_id=participant.room_id,
                role=participant.role.value,
                muted=participant.muted,
                joined_at=participant.joined_at,
                left_at=participant.left_at,
            )
        )
        await self.session.commit()

    async def update(self, participant: Participant) -> None:  # type: ignore[override]
        await self.session.execute(
            update(Participants)
            .where(Participants.id == participant.id)
            .values(muted=participant.muted, left_at=participant.left_at)
        )
        await self.session.commit()

    async def remove(self, room_id: UUID, user_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(
            delete(Participants).where(Participants.room_id == room_id, Participants.user_id == user_id)
        )
        await self.session.commit()

    async def list_visited_rooms(self, user_id: UUID, skip: int = 0, limit: int = 50) -> list[tuple[UUID, datetime]]:  # type: ignore[override]
        # Для «последнего визита» возьмём max(joined_at, left_at) по каждой комнате
        # Если left_at NULL (ещё в комнате) — используем joined_at
        last_seen = func.coalesce(Participants.left_at, Participants.joined_at)
        stmt = (
            select(Participants.room_id, func.max(last_seen).label("last_seen"))
            .where(Participants.user_id == user_id)
            .group_by(Participants.room_id)
            .order_by(func.max(last_seen).desc())
            .offset(skip)
            .limit(limit)
        )
        res = await self.session.execute(stmt)
        rows = list(res.all())
        return [(r[0], r[1]) for r in rows]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\participants.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\push_subs.py =====
--- SIZE: 3628 bytes ---

from __future__ import annotations

from typing import List
from uuid import UUID

from sqlalchemy import delete, select
from sqlalchemy.dialects.postgresql import insert as pg_insert
import logging

logger = logging.getLogger(__name__)
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import PushSubscription
from ....core.ports.repositories import PushSubscriptionRepository
from ..models import PushSubscriptions


class PgPushSubscriptionRepository(PushSubscriptionRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def add(self, sub: PushSubscription) -> None:  # type: ignore[override]
        """Атомарная регистрация push-подписки.

        Используем PostgreSQL ON CONFLICT для устранения гонок при
        одновременных (или повторных) подписках одного и того же endpoint.

        Поведение: если (user_id, endpoint) уже существует, обновляем ключи.
        Замечание: поле created_at перезаписывается – трактуем его как
        'момент актуализации'. Если важно сохранять первоначальный момент,
        нужно завести отдельное поле updated_at (не делаем сейчас, чтобы не
        добавлять миграцию в рамках быстрого фикса)."""

        stmt = (
            pg_insert(PushSubscriptions)
            .values(
                id=sub.id,
                user_id=sub.user_id,
                endpoint=sub.endpoint,
                p256dh=sub.p256dh,
                auth=sub.auth,
                created_at=sub.created_at,
            )
            .on_conflict_do_update(
                index_elements=[PushSubscriptions.user_id, PushSubscriptions.endpoint],
                set_
                ={
                    "p256dh": sub.p256dh,
                    "auth": sub.auth,
                    "created_at": sub.created_at,
                },
            )
        )
        result = await self.session.execute(stmt)
        await self.session.commit()
        # rowcount == 1 всегда, но можем логировать сам факт upsert.
        # Для более тонкого различения вставка/обновление нужен триггер или
        # добавление столбца updated_at. Здесь достаточно отладочного сообщения.
        logger.debug(
            "push_subscriptions upsert: user_id=%s endpoint_hash=%s", sub.user_id, hash(sub.endpoint)
        )

    async def remove(self, user_id: UUID, endpoint: str) -> None:  # type: ignore[override]
        await self.session.execute(
            delete(PushSubscriptions).where(
                (PushSubscriptions.user_id == user_id) & (PushSubscriptions.endpoint == endpoint)
            )
        )
        await self.session.commit()

    async def list_by_user(self, user_id: UUID) -> List[PushSubscription]:  # type: ignore[override]
        res = await self.session.execute(select(PushSubscriptions).where(PushSubscriptions.user_id == user_id))
        rows = res.scalars().all()
        return [
            PushSubscription(id=r.id, user_id=r.user_id, endpoint=r.endpoint, p256dh=r.p256dh, auth=r.auth, created_at=r.created_at)
            for r in rows
        ]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\push_subs.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\rooms.py =====
--- SIZE: 2567 bytes ---

from __future__ import annotations

from typing import Optional, Iterable
from uuid import UUID

from sqlalchemy import delete, select
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import Room
from ....core.domain.values import RoomName
from ....core.ports.repositories import RoomRepository
from ..models import Rooms


class PgRoomRepository(RoomRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session
        # Maximum number of IDs allowed in an IN() clause to avoid very large queries
        self.MAX_IDS_IN_CLAUSE = 1000

    async def add(self, room: Room) -> None:  # type: ignore[override]
        self.session.add(
            Rooms(id=room.id, name=str(room.name), owner_id=room.owner_id, is_private=room.is_private, created_at=room.created_at)
        )
        await self.session.commit()

    async def get(self, room_id: UUID) -> Optional[Room]:  # type: ignore[override]
        row = await self.session.get(Rooms, room_id)
        if not row:
            return None
        return Room(id=row.id, name=RoomName(row.name), owner_id=row.owner_id, is_private=row.is_private, created_at=row.created_at)

    async def list(self, owner_id: UUID | None = None, skip: int = 0, limit: int = 50) -> list[Room]:  # type: ignore[override]
        stmt = select(Rooms)
        if owner_id:
            stmt = stmt.where(Rooms.owner_id == owner_id)
        stmt = stmt.offset(skip).limit(limit)
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Room(id=r.id, name=RoomName(r.name), owner_id=r.owner_id, is_private=r.is_private, created_at=r.created_at) for r in rows]

    async def get_many(self, ids: Iterable[UUID]) -> list[Room]:  # type: ignore[override]
        if not ids:
            return []
        id_list = list(ids)
        if len(id_list) > self.MAX_IDS_IN_CLAUSE:
            # Truncate to safe size; callers should ideally validate earlier
            id_list = id_list[: self.MAX_IDS_IN_CLAUSE]
        stmt = select(Rooms).where(Rooms.id.in_(id_list))
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [Room(id=r.id, name=RoomName(r.name), owner_id=r.owner_id, is_private=r.is_private, created_at=r.created_at) for r in rows]

    async def delete(self, room_id: UUID) -> None:  # type: ignore[override]
        await self.session.execute(delete(Rooms).where(Rooms.id == room_id))
        await self.session.commit()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\rooms.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\users.py =====
--- SIZE: 5027 bytes ---

from __future__ import annotations

from typing import Optional
from uuid import UUID

from sqlalchemy import select, or_
from sqlalchemy.exc import IntegrityError
from sqlalchemy.ext.asyncio import AsyncSession

from ....core.domain.models import User
from ....core.domain.values import Email, PasswordHash, Username
from ....core.ports.repositories import UserRepository
from ..models import Users
from ....core.errors import ConflictError
from ...db.utils import safe_like


class PgUserRepository(UserRepository):
    def __init__(self, session: AsyncSession) -> None:
        self.session = session

    async def get_by_email(self, email: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.email == email)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=Username(row.username), password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def get_by_id(self, user_id: UUID) -> Optional[User]:  # type: ignore[override]
        row = await self.session.get(Users, user_id)
        if row:
            return User(id=row.id, email=Email(row.email), username=Username(row.username), password_hash=PasswordHash(row.password_hash), created_at=row.created_at, public_key=row.public_key)
        return None

    async def get_by_username(self, username: str) -> Optional[User]:  # type: ignore[override]
        stmt = select(Users).where(Users.username == username)
        res = await self.session.execute(stmt)
        row = res.scalar_one_or_none()
        if row:
            return User(id=row.id, email=Email(row.email), username=Username(row.username), password_hash=PasswordHash(row.password_hash), created_at=row.created_at)
        return None

    async def add(self, user: User) -> None:  # type: ignore[override]
        self.session.add(
            Users(
                id=user.id,
                email=str(user.email),
                username=str(user.username),
                password_hash=str(user.password_hash),
                public_key=user.public_key if hasattr(user, 'public_key') else None,
                created_at=user.created_at,
            )
        )
        try:
            await self.session.commit()
        except IntegrityError as e:
            await self.session.rollback()
            # Переводим БД-ошибку в доменную 409
            raise ConflictError("User with same email or username already exists") from e

    async def set_public_key(self, user_id: UUID, public_key: str) -> None:
        row = await self.session.get(Users, user_id)
        if not row:
            return
        row.public_key = public_key
        self.session.add(row)
        await self.session.commit()

    async def search(self, query: str, limit: int = 10) -> list[User]:  # type: ignore[override]
        pattern = safe_like(query, max_len=100)
        if not pattern:
            return []

        stmt = (
            select(Users)
            .where(
                or_(
                    Users.username.ilike(pattern, escape='\\'),
                    Users.email.ilike(pattern, escape='\\'),
                )
            )
            .order_by(Users.username.asc())
            .limit(limit)
        )
        res = await self.session.execute(stmt)
        rows = res.scalars().all()
        return [
            User(id=r.id, email=Email(r.email), username=Username(r.username), password_hash=PasswordHash(r.password_hash), created_at=r.created_at)
            for r in rows
        ]

    async def update_profile(self, user_id: UUID, *, email: str | None = None, username: str | None = None) -> User | None:  # type: ignore[override]
        if email is None and username is None:
            return await self.get_by_id(user_id)
        row = await self.session.get(Users, user_id)
        if not row:
            return None
        if email is not None:
            row.email = email
        if username is not None:
            row.username = username
        self.session.add(row)
        try:
            await self.session.commit()
        except IntegrityError as e:
            await self.session.rollback()
            raise ConflictError("User with same email or username already exists") from e
        return User(id=row.id, email=Email(row.email), username=Username(row.username), password_hash=PasswordHash(row.password_hash), created_at=row.created_at, public_key=row.public_key)

    async def update_password(self, user_id: UUID, password_hash: str) -> bool:  # type: ignore[override]
        row = await self.session.get(Users, user_id)
        if not row:
            return False
        row.password_hash = password_hash
        self.session.add(row)
        await self.session.commit()
        return True

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\repositories\users.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\session.py =====
--- SIZE: 1408 bytes ---

from __future__ import annotations

from contextlib import asynccontextmanager
from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncEngine, AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker

from ..config import get_settings


_settings = get_settings()
db_url = _settings.DATABASE_URL

engine_kwargs = {"pool_pre_ping": True}
# Для sqlite (особенно :memory: или aiosqlite) параметры пула не поддерживаются — пропустим
if not db_url.startswith("sqlite"):
    engine_kwargs.update({
        "pool_size": 5,
        "max_overflow": 10,
        "pool_timeout": 30,
    })

ENGINE: AsyncEngine = create_async_engine(db_url, **engine_kwargs)
AsyncSessionLocal = sessionmaker(bind=ENGINE, class_=AsyncSession, expire_on_commit=False)


@asynccontextmanager
async def get_session() -> AsyncIterator[AsyncSession]:
    """Базовый контекстный менеджер для получения AsyncSession (основной)."""
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        yield session


# Backward compatibility alias expected by some imports (presentation.ws.rooms)
async def get_db_session() -> AsyncIterator[AsyncSession]:  # pragma: no cover - thin wrapper
    async with get_session() as s:  # type: ignore[misc]
        yield s

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\session.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\utils.py =====
--- SIZE: 727 bytes ---

from __future__ import annotations

from typing import Optional


def safe_like(raw: Optional[str], max_len: int = 100) -> Optional[str]:
    """Prepare a user-provided string for SQL LIKE queries.

    - Trims and lowercases the input.
    - Limits length to `max_len`.
    - Escapes SQL LIKE wildcards '%' and '_' and backslash.
    - Returns pattern string wrapped with leading/trailing '%' or None for empty input.
    """
    if raw is None:
        return None
    s = str(raw).strip().lower()
    if not s:
        return None
    if len(s) > max_len:
        s = s[:max_len]
    # escape backslash first
    s = s.replace('\\', '\\\\').replace('%', '\\%').replace('_', '\\_')
    return f"%{s}%"

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\db\utils.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\provider.py =====
--- SIZE: 3491 bytes ---

# app/presentation/infrastructure/ice/provider.py
from __future__ import annotations

import json
import os
from typing import Any, Protocol


class IceConfigProvider(Protocol):
    async def get_servers(self) -> dict[str, Any]: ...


def _get_env(name: str, default: str | None = None) -> str | None:
    val = os.getenv(name)
    return val if val is not None else default


class EnvIceConfigProvider:
    """
    Читает STUN/TURN из env и отдаёт структуру WebRTC ICE.
    Поддерживает:
      - STUN_SERVERS: JSON-массив или строка с запятыми
      - TURN_URLS: JSON-массив или строка с запятыми
      - TURN_URL: одиночная строка (legacy)
    """

    async def get_servers(self) -> dict[str, Any]:
        # --- STUN ---
        stun_raw = _get_env("STUN_SERVERS", '["stun:stun.l.google.com:19302"]')
        stun_servers: list[str] = []
        if stun_raw:
            try:
                if stun_raw.strip().startswith("["):
                    stun_servers = json.loads(stun_raw)
                else:
                    stun_servers = [s.strip() for s in stun_raw.split(",") if s.strip()]
            except Exception:
                stun_servers = []

        # --- TURN ---
        # Новое: поддержка списка URL (UDP/TCP и т.д.)
        turn_urls_raw = _get_env("TURN_URLS") or _get_env("TURN_URL")
        turn_username = _get_env("TURN_USERNAME")
        turn_password = _get_env("TURN_PASSWORD")

        turn_urls: list[str] = []
        if turn_urls_raw:
            try:
                if turn_urls_raw.strip().startswith("["):
                    turn_urls = json.loads(turn_urls_raw)
                else:
                    turn_urls = [u.strip() for u in turn_urls_raw.split(",") if u.strip()]
            except Exception:
                turn_urls = [turn_urls_raw]

        ice: list[dict[str, Any]] = []
        if stun_servers:
            ice.append({"urls": stun_servers})
        if turn_urls and turn_username and turn_password:
            ice.append(
                {
                    "urls": turn_urls,
                    "username": turn_username,
                    "credential": turn_password,
                }
            )

        has_turn = any(
            any(
                isinstance(url, str) and url.startswith("turn")
                for url in (srv.get("urls") if isinstance(srv.get("urls"), list) else [srv.get("urls")])
            )
            for srv in ice
        )
        if not has_turn:
            ice.append(
                {
                    "urls": [
                        "turn:openrelay.metered.ca:80",
                        "turn:openrelay.metered.ca:443",
                        "turns:openrelay.metered.ca:443",
                    ],
                    "username": "openrelayproject",
                    "credential": "openrelayproject",
                }
            )

        config: dict[str, Any] = {"iceServers": ice}
        policy = _get_env("ICE_TRANSPORT_POLICY")
        if policy:
            config["iceTransportPolicy"] = policy
        pool = _get_env("ICE_CANDIDATE_POOL_SIZE")
        if pool:
            try:
                config["iceCandidatePoolSize"] = int(pool)
            except (TypeError, ValueError):
                pass

        return config

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\ice\provider.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\logging.py =====
--- SIZE: 759 bytes ---

import json
import logging
from typing import Any


class JsonFormatter(logging.Formatter):
    def format(self, record: logging.LogRecord) -> str:  # type: ignore[override]
        data: dict[str, Any] = {
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }
        if record.exc_info:
            data["exc_info"] = self.formatException(record.exc_info)
        return json.dumps(data, ensure_ascii=False)


def configure_logging(level: int = logging.INFO) -> None:
    handler = logging.StreamHandler()
    handler.setFormatter(JsonFormatter())
    root = logging.getLogger()
    root.handlers.clear()
    root.addHandler(handler)
    root.setLevel(level)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\logging.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\inmemory_bus.py =====
--- SIZE: 1684 bytes ---

from __future__ import annotations

import asyncio
from collections import defaultdict
from typing import AsyncIterator, Dict, List
from uuid import UUID

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus


class InMemorySignalBus(SignalBus):
    def __init__(self) -> None:
        self.queues: Dict[UUID, List[asyncio.Queue[Signal]]] = defaultdict(list)
        self._presence: Dict[UUID, set[str]] = defaultdict(set)

    async def publish(self, room_id: UUID, signal: Signal) -> None:  # type: ignore[override]
        for q in list(self.queues[room_id]):
            await q.put(signal)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:  # type: ignore[override]
        q: asyncio.Queue[Signal] = asyncio.Queue()
        self.queues[room_id].append(q)
        try:
            while True:
                try:
                    s = await q.get()
                except asyncio.CancelledError:
                    # нормальный выход при отмене таска-подписчика
                    break
                else:
                    yield s
        finally:
            self.queues[room_id].remove(q)

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:  # type: ignore[override]
        if present:
            self._presence[room_id].add(str(user_id))
        else:
            self._presence[room_id].discard(str(user_id))

    async def list_presence(self, room_id: UUID) -> List[dict]:  # type: ignore[override]
        return [{"user_id": uid, "present": True} for uid in self._presence[room_id]]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\inmemory_bus.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\redis_bus.py =====
--- SIZE: 3007 bytes ---

from __future__ import annotations

import asyncio
import json
from typing import Any, AsyncIterator
from uuid import UUID

import redis.asyncio as aioredis

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus
from ..config import get_settings


class RedisSignalBus(SignalBus):
    def __init__(self, redis: aioredis.Redis | None = None) -> None:
        self.settings = get_settings()
        self.redis = redis or aioredis.from_url(self.settings.REDIS_URL, decode_responses=True)

    def _channel(self, room_id: UUID) -> str:
        return f"room:{room_id}:signals"

    def _presence_key(self, room_id: UUID) -> str:
        return f"room:{room_id}:presence"

    async def publish(self, room_id: UUID, signal: Signal) -> None:
        payload = json.dumps(
            {
                "type": signal.type.value,
                "sender_id": str(signal.sender_id),
                "target_id": str(signal.target_id) if signal.target_id else None,
                "room_id": str(signal.room_id),
                "sdp": signal.sdp,
                "candidate": signal.candidate,
                "sent_at": signal.sent_at.isoformat(),
            }
        )
        await self.redis.publish(self._channel(room_id), payload)

    async def subscribe(self, room_id: UUID) -> AsyncIterator[Signal]:
        pubsub = self.redis.pubsub()
        await pubsub.subscribe(self._channel(room_id))
        try:
            async for msg in pubsub.listen():
                if msg["type"] != "message":
                    continue
                data = json.loads(msg["data"])  # type: ignore[arg-type]
                yield Signal.create(
                    type=data["type"],
                    sender_id=UUID(data["sender_id"]),
                    room_id=UUID(data["room_id"]),
                    sdp=data.get("sdp"),
                    candidate=data.get("candidate"),
                    target_id=UUID(data["target_id"]) if data.get("target_id") else None,
                )
        finally:
            await pubsub.unsubscribe(self._channel(room_id))
            await pubsub.close()

    async def update_presence(self, room_id: UUID, user_id: UUID, present: bool) -> None:
        key = self._presence_key(room_id)
        if present:
            await self.redis.hset(key, str(user_id), json.dumps({"present": True}))
        else:
            await self.redis.hdel(key, str(user_id))
        await self.redis.expire(key, 60 * 60)

    async def list_presence(self, room_id: UUID) -> list[dict[str, Any]]:
        key = self._presence_key(room_id)
        data = await self.redis.hgetall(key)
        result: list[dict[str, Any]] = []
        for uid, v in data.items():
            try:
                obj = json.loads(v)
            except Exception:
                obj = {"present": True}
            obj["user_id"] = uid
            result.append(obj)
        return result

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\messaging\redis_bus.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\rate_limit\redis_rate_limiter.py =====
--- SIZE: 1150 bytes ---

from __future__ import annotations

import time
from dataclasses import dataclass
from typing import Tuple

from redis.asyncio import Redis


def parse_rate(rate: str) -> Tuple[int, int]:
    """Parse rate string like '100/60' -> (100, 60)."""
    parts = rate.split('/')
    if len(parts) != 2:
        raise ValueError("Invalid RATE_LIMIT format, expected '<count>/<seconds>'")
    return int(parts[0]), int(parts[1])


@dataclass
class RedisRateLimiter:
    redis: Redis
    limit: int
    window: int  # seconds

    @classmethod
    def from_config(cls, redis: Redis, rate: str):
        limit, window = parse_rate(rate)
        return cls(redis=redis, limit=limit, window=window)

    async def allow(self, bucket: str) -> bool:
        """Fixed window counter increment. Returns True if allowed."""
        now = int(time.time())
        window_start = now - (now % self.window)
        key = f"rl:{bucket}:{window_start}"
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, self.window + 2)
        count, _ = await pipe.execute()
        return int(count) <= self.limit

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\rate_limit\redis_rate_limiter.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\jwt_provider.py =====
--- SIZE: 1095 bytes ---

from __future__ import annotations

from datetime import datetime, timedelta, timezone

from jose import JWTError, jwt

from ...core.ports.services import TokenProvider
from ..config import get_settings


class JoseTokenProvider(TokenProvider):
    def __init__(self) -> None:
        self.settings = get_settings()
        self.algorithm = "HS256"

    def create_access_token(self, subject: str, expires_minutes: int | None = None) -> str:  # type: ignore[override]
        expires_minutes = expires_minutes or self.settings.JWT_EXPIRES_MIN
        now = datetime.now(tz=timezone.utc)
        payload = {"sub": subject, "iat": int(now.timestamp()), "exp": int((now + timedelta(minutes=expires_minutes)).timestamp())}
        return jwt.encode(payload, self.settings.JWT_SECRET, algorithm=self.algorithm)

    def decode_token(self, token: str) -> dict:  # type: ignore[override]
        try:
            return jwt.decode(token, self.settings.JWT_SECRET, algorithms=[self.algorithm])
        except JWTError as e:
            raise ValueError("Invalid token") from e

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\jwt_provider.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\password_hasher.py =====
--- SIZE: 467 bytes ---

from __future__ import annotations

from passlib.context import CryptContext

from ...core.ports.services import PasswordHasher


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class BcryptPasswordHasher(PasswordHasher):
    def hash(self, password: str) -> str:
        return pwd_context.hash(password)

    def verify(self, password: str, password_hash: str) -> bool:
        return pwd_context.verify(password, password_hash)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\security\password_hasher.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\ai_provider.py =====
--- SIZE: 6704 bytes ---

from __future__ import annotations

"""Простой mock AI провайдера.

Реализация AISummaryProvider, использующая эвристику: считает количество
сообщений, авторов и возвращает несколько последних реплик.
Заменяется на реальный API (OpenAI, etc.) при наличии ключей.
"""

from collections import Counter
from typing import List, Optional
import httpx
import asyncio
from .summary import AISummaryProvider
from ..config import get_settings
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from ..db.models import Users


class HeuristicAIProvider(AISummaryProvider):
    async def generate_summary(self, plain_messages: List[str], system_prompt: str | None = None) -> str:  # type: ignore[override]
        if not plain_messages:
            return "Нет данных для анализа."
        authors = []
        for line in plain_messages:
            try:
                after = line.split('] ', 1)[1]
                name = after.split(':', 1)[0].strip()
                authors.append(name)
            except Exception:
                continue
        top_authors = ", ".join([f"{a}({c})" for a, c in Counter(authors).most_common(5)]) if authors else "—"
        last_lines = "\n".join(plain_messages[-5:])
        prompt_note = ""
        if system_prompt:
            # Вставляем первые 90 символов промпта как индикатор персонализации (hash для приватности?)
            import hashlib
            h = hashlib.sha256(system_prompt.encode('utf-8')).hexdigest()[:10]
            snippet = system_prompt.strip().replace('\n', ' ')[:90]
            prompt_note = f"(prompt-hash={h} :: {snippet})\n"
        return (
            "AI эвристическая выжимка:\n"
            f"{prompt_note}Всего сообщений: {len(plain_messages)}\n"
            f"Активные участники: {top_authors}\n"
            "Последние реплики:\n" + last_lines
        )


class OpenAIAIProvider(AISummaryProvider):
    """Провайдер, использующий OpenAI Chat Completions/Responses API.

    Используем минимальный вызов с моделью из AI_MODEL_PROVIDER (после префикса 'openai:').
    Формат plain_messages: список строк. Мы склеиваем в одну подсказку, обрезая при необходимости.
    """

    def __init__(self, api_key: str, model: str, fallback: str | None = None) -> None:
        self.api_key = api_key
        self.model = model
        self.fallback = fallback

    async def generate_summary(self, plain_messages: List[str], system_prompt: str | None = None) -> str:  # type: ignore[override]
        if not plain_messages:
            return "Нет данных для анализа."
        prompt_messages = plain_messages[-500:]  # safety bound
        joined = "\n".join(prompt_messages)
        system = system_prompt or (
            "Ты ассистент, делающий краткую структурированную выжимку группового чата:"
            " 1) Основные темы 2) Принятые решения 3) Открытые вопросы."
            " Пиши лаконично на русском, без лишних вступлений."
        )
        url = "https://api.openai.com/v1/chat/completions"
        headers = {"Authorization": f"Bearer {self.api_key}", "Content-Type": "application/json"}
        body = {
            "model": self.model,
            "messages": [
                {"role": "system", "content": system},
                {"role": "user", "content": f"Сообщения чата:\n{joined}\n---\nСформируй выжимку."},
            ],
            "temperature": 0.3,
            "max_tokens": 600,
        }
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                r = await client.post(url, json=body, headers=headers)
                if r.status_code == 200:
                    data = r.json()
                    # OpenAI Chat Completion формат
                    content = data['choices'][0]['message']['content']  # type: ignore[index]
                    return content.strip()
                # fallback попытка другой модели если указана
                if self.fallback and r.status_code in {400, 404}:  # модель не найдена / неверна
                    body["model"] = self.fallback
                    async with httpx.AsyncClient(timeout=30.0) as client2:
                        r2 = await client2.post(url, json=body, headers=headers)
                        if r2.status_code == 200:
                            data2 = r2.json()
                            return data2['choices'][0]['message']['content'].strip()  # type: ignore[index]
                return _error_fallback(joined, f"OpenAI HTTP {r.status_code}")
        except Exception as e:  # pragma: no cover
            return _error_fallback(joined, f"exc:{e.__class__.__name__}")


def _error_fallback(joined: str, reason: str) -> str:
    tail = "\n".join(joined.splitlines()[-10:])
    return (
        "Эвристическая выжимка (OpenAI недоступен: " + reason + ")\n" + tail
    )


# Фабрика выбора провайдера
_provider_singleton: AISummaryProvider | None = None


def get_ai_provider() -> AISummaryProvider:
    global _provider_singleton
    if _provider_singleton is not None:
        return _provider_singleton
    settings = get_settings()
    api_key = settings.OPENAI_API_KEY
    model_field = settings.AI_MODEL_PROVIDER or ""
    if api_key and model_field.startswith("openai:"):
        model = model_field.split(":", 1)[1] or "gpt-4o-mini"
        _provider_singleton = OpenAIAIProvider(api_key=api_key, model=model, fallback=settings.AI_MODEL_FALLBACK)
    else:
        _provider_singleton = HeuristicAIProvider()
    return _provider_singleton


async def get_user_system_prompt(session: AsyncSession, user_id) -> str | None:
    """Возвращает сохранённый кастомный prompt пользователя или None."""
    q = select(Users.ai_system_prompt).where(Users.id == user_id)
    res = await session.execute(q)
    return res.scalar_one_or_none()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\ai_provider.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\call_invites.py =====
--- SIZE: 3791 bytes ---

from __future__ import annotations

from typing import Dict, List
import time
from uuid import UUID
from asyncio import Lock

from ...core.ports.services import CallInviteService
"""Сервис приглашений к звонку.

Избегаем циклического импорта с модулем friends_ws (presentation.ws.friends),
который через контейнеры тянет зависимости обратно сюда. Поэтому импорт
делается лениво внутри методов.
"""


class InMemoryCallInviteService(CallInviteService):
    """In-memory реализация хранения приглашений.

    Заменяет _pending_calls из friends.py, при этом friends.py может
    пользоваться этой службой через DI.
    """

    def __init__(self) -> None:
        self._pending: Dict[str, dict] = {}
        self._lock = Lock()

    async def invite(self, from_user_id: UUID, to_user_id: UUID, room_id: str, from_username: str | None, from_email: str | None) -> None:
        ts = int(time.time() * 1000)
        async with self._lock:
            self._pending[room_id] = {
                'fromUserId': str(from_user_id),
                'toUserId': str(to_user_id),
                'fromUsername': from_username,
                'fromEmail': from_email,
                'ts': ts,  # ms timestamp для восстановления после оффлайна
            }
        from ...presentation.ws import friends as friends_ws  # локальный импорт чтобы избежать цикла
        await friends_ws.publish_call_invite(from_user_id, to_user_id, room_id, from_username, from_email)

    async def accept(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:
        async with self._lock:
            self._pending.pop(room_id, None)
        from ...presentation.ws import friends as friends_ws
        await friends_ws.publish_call_accept(from_user_id, to_user_id, room_id)

    async def decline(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:
        async with self._lock:
            self._pending.pop(room_id, None)
        from ...presentation.ws import friends as friends_ws
        await friends_ws.publish_call_decline(from_user_id, to_user_id, room_id)

    async def cancel(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:
        async with self._lock:
            self._pending.pop(room_id, None)
        # publish_call_cancel уже очищает у себя, но для безопасности удаляем здесь тоже
        from ...presentation.ws import friends as friends_ws
        await friends_ws.publish_call_cancel(from_user_id, to_user_id, room_id)

    async def list_pending_for(self, user_id: UUID) -> List[dict]:
        now = int(time.time() * 1000)
        # Жизненный цикл инвайта: 40 секунд (увеличено для сценария захода пользователя позже).
        # Синхронизировать с calls_signaling.js (MAX_AGE_MS в onInvite) и RING_TIMEOUT_MS.
        MAX_AGE_MS = 40000
        async with self._lock:
            # Очистим устаревшие
            stale = [rid for rid, data in self._pending.items() if (now - int(data.get('ts', 0))) > MAX_AGE_MS]
            for rid in stale:
                self._pending.pop(rid, None)
            return [
                {'roomId': rid, **data, 'createdAt': data.get('ts')}
                for rid, data in self._pending.items()
                if str(user_id) in (data.get('fromUserId'), data.get('toUserId'))
            ]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\call_invites.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\call_invites_redis.py =====
--- SIZE: 4321 bytes ---

from __future__ import annotations

import time
from typing import List
from uuid import UUID

from redis.asyncio import Redis

from ...core.ports.services import CallInviteService

INVITE_TTL_SEC = 15 * 60  # 15 минут

class RedisCallInviteService(CallInviteService):
    """Redis реализация CallInviteService.

    Хранилища:
      - Hash call_invite:{room_id} => поля: fromUserId,toUserId,fromUsername,fromEmail,ts
      - ZSET call_invite_user:{user_id} score=ts member=room_id (для быстрого поиска pending)
    """

    def __init__(self, redis: Redis):
        self.redis = redis

    def _hash_key(self, room_id: str) -> str:
        return f"call_invite:{room_id}"

    def _user_index(self, user_id: str) -> str:
        return f"call_invite_user:{user_id}"

    async def invite(self, from_user_id: UUID, to_user_id: UUID, room_id: str, from_username: str | None, from_email: str | None) -> None:  # type: ignore[override]
        ts = int(time.time())
        k = self._hash_key(room_id)
        pipe = self.redis.pipeline()
        pipe.hset(k, mapping={
            'fromUserId': str(from_user_id),
            'toUserId': str(to_user_id),
            'fromUsername': from_username or '',
            'fromEmail': from_email or '',
            'ts': ts,
        })
        pipe.expire(k, INVITE_TTL_SEC)
        pipe.zadd(self._user_index(str(from_user_id)), {room_id: ts})
        pipe.zadd(self._user_index(str(to_user_id)), {room_id: ts})
        pipe.expire(self._user_index(str(from_user_id)), INVITE_TTL_SEC)
        pipe.expire(self._user_index(str(to_user_id)), INVITE_TTL_SEC)
        await pipe.execute()
        from ...presentation.ws import friends as friends_ws  # локальный импорт
        await friends_ws.publish_call_invite(from_user_id, to_user_id, room_id, from_username, from_email)

    async def accept(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:  # type: ignore[override]
        await self._finalize(room_id)
        from ...presentation.ws import friends as friends_ws
        await friends_ws.publish_call_accept(from_user_id, to_user_id, room_id)

    async def decline(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:  # type: ignore[override]
        await self._finalize(room_id)
        from ...presentation.ws import friends as friends_ws
        await friends_ws.publish_call_decline(from_user_id, to_user_id, room_id)

    async def cancel(self, from_user_id: UUID, to_user_id: UUID, room_id: str) -> None:  # type: ignore[override]
        await self._finalize(room_id)
        from ...presentation.ws import friends as friends_ws
        await friends_ws.publish_call_cancel(from_user_id, to_user_id, room_id)

    async def _finalize(self, room_id: str) -> None:
        # Удаляем hash и чистим индексы (без знания участников — ищем из hash)
        k = self._hash_key(room_id)
        data = await self.redis.hgetall(k)
        pipe = self.redis.pipeline()
        pipe.delete(k)
        if data:
            fu = data.get('fromUserId')
            tu = data.get('toUserId')
            if fu:
                pipe.zrem(self._user_index(fu), room_id)
            if tu:
                pipe.zrem(self._user_index(tu), room_id)
        await pipe.execute()

    async def list_pending_for(self, user_id: UUID) -> List[dict]:  # type: ignore[override]
        idx_key = self._user_index(str(user_id))
        now = int(time.time())
        # Получаем все за последние INVITE_TTL_SEC секунд
        min_score = now - INVITE_TTL_SEC - 5
        room_ids = await self.redis.zrangebyscore(idx_key, min_score, now)
        results: List[dict] = []
        for rid in room_ids:
            h = await self.redis.hgetall(self._hash_key(rid))
            if not h:
                continue
            results.append({
                'roomId': rid,
                'fromUserId': h.get('fromUserId'),
                'toUserId': h.get('toUserId'),
                'fromUsername': h.get('fromUsername') or None,
                'fromEmail': h.get('fromEmail') or None,
            })
        return results

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\call_invites_redis.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\direct_crypto.py =====
--- SIZE: 1617 bytes ---

from __future__ import annotations

"""Шифрование личных сообщений.

Используется симметричный ключ, производный от JWT_SECRET и отсортированной пары user ids.
Алгоритм derivation (простая, но достаточная для прикладного уровня):
  base_key = sha256( JWT_SECRET + '::dm::' + min(user_a,user_b) + '::' + max(user_a,user_b) )
  fernet_key = base_key[:32] -> urlsafe_b64encode

Fernet обеспечивает аутентифицированное шифрование (AES128 + HMAC). Размер шифртекста возрастает.
"""

import hashlib
import base64
from uuid import UUID
from cryptography.fernet import Fernet
from ..config import get_settings


def _derive_key(a: UUID, b: UUID) -> bytes:
    s = get_settings().JWT_SECRET
    a_s, b_s = str(a), str(b)
    if a_s <= b_s:
        ua, ub = a_s, b_s
    else:
        ua, ub = b_s, a_s
    raw = hashlib.sha256((s + '::dm::' + ua + '::' + ub).encode('utf-8')).digest()
    # Берём первые 32 байта (весь digest) и кодируем в base64 для Fernet
    return base64.urlsafe_b64encode(raw)


def encrypt_direct(a: UUID, b: UUID, plaintext: str) -> str:
    key = _derive_key(a, b)
    f = Fernet(key)
    return f.encrypt(plaintext.encode('utf-8')).decode('utf-8')


def decrypt_direct(a: UUID, b: UUID, ciphertext: str) -> str:
    key = _derive_key(a, b)
    f = Fernet(key)
    return f.decrypt(ciphertext.encode('utf-8')).decode('utf-8')

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\direct_crypto.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\push_notifier.py =====
--- SIZE: 2470 bytes ---

from __future__ import annotations

from uuid import UUID
from typing import Iterable

from ...core.ports.services import PushNotifier
from ...infrastructure.config import get_settings
from ...infrastructure.services.webpush import WebPushSender, WebPushMessage
from ...core.ports.repositories import PushSubscriptionRepository, UserRepository


class SimplePushNotifier(PushNotifier):
    """Реализация PushNotifier с ретраями, вынесенными из роутера.

    SRP: только отправка уведомлений.
    DIP: роутер зависит от интерфейса.
    """

    def __init__(self, subs_repo: PushSubscriptionRepository, users: UserRepository) -> None:
        self._subs_repo = subs_repo
        self._users = users

    async def notify_incoming_call(self, to_user_id: UUID, from_user_id: UUID, from_username: str | None, room_id: str) -> None:
        target = await self._users.get_by_id(to_user_id)
        if not target:
            return
        subs = await self._subs_repo.list_by_user(target.id)
        if not subs:
            return
        settings = get_settings()
        if not (settings.VAPID_PUBLIC_KEY and settings.VAPID_PRIVATE_KEY and settings.VAPID_SUBJECT):
            return
        sender = WebPushSender(vapid_public=settings.VAPID_PUBLIC_KEY, vapid_private=settings.VAPID_PRIVATE_KEY, subject=settings.VAPID_SUBJECT)
        for s in subs:
            msg = WebPushMessage(
                title="Входящий звонок",
                body=f"{from_username or 'Пользователь'} хочет поговорить",
                icon=None,
                data={"room_id": room_id, "from": str(from_user_id), "from_name": from_username},
            )
            attempts = 0
            while attempts < 3:
                attempts += 1
                try:
                    await sender.send(s.endpoint, s.p256dh, s.auth, msg)
                    break
                except Exception as e:  # pragma: no cover - сеть
                    text = str(e)
                    if any(code in text for code in ("410", "404")):
                        await self._subs_repo.remove(target.id, s.endpoint)
                        break
                    if any(code in text for code in ("429", "500", "502", "503")) and attempts < 3:
                        continue
                    break

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\push_notifier.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary.py =====
--- SIZE: 10832 bytes ---

from __future__ import annotations

"""In-memory сборщик сообщений комнаты для последующей AI выжимки.

Не хранит данные персистентно: предназначено для генерации краткого отчёта
по завершению сессии. Если требуется долговременное хранение истории –
нужно использовать БД сообщений (PgMessageRepository) и расширить логику.

Потокобезопасность обеспечивается asyncio.Lock. Размер каждого списка
сообщений ограничен AI_SUMMARY_MAX_MESSAGES (хвост сохраняется).
"""

from dataclasses import dataclass
from typing import List, Dict
from asyncio import Lock
from uuid import UUID
import time

from ...infrastructure.config import get_settings  # type: ignore  # локальный импорт


@dataclass(slots=True)
class ChatMessage:
    room_id: str
    author_id: str | None
    author_name: str | None
    content: str
    ts: int  # epoch ms


@dataclass(slots=True)
class SummaryResult:
    room_id: str
    message_count: int
    generated_at: int
    summary_text: str


class SummaryCollector:
    def __init__(self) -> None:
        self._messages: Dict[str, List[ChatMessage]] = {}
        self._lock = Lock()

    async def add_message(self, room_id: str, author_id: str | None, author_name: str | None, content: str) -> None:
        if not content:
            return
        msg = ChatMessage(room_id=room_id, author_id=author_id, author_name=author_name, content=content.strip(), ts=int(time.time()*1000))
        settings = get_settings()
        max_msgs = settings.AI_SUMMARY_MAX_MESSAGES
        async with self._lock:
            bucket = self._messages.setdefault(room_id, [])
            bucket.append(msg)
            # обрезаем начало (старые) если превышен лимит
            if len(bucket) > max_msgs:
                overflow = len(bucket) - max_msgs
                if overflow > 0:
                    del bucket[0:overflow]

    async def summarize(self, room_id: str, ai_provider: 'AISummaryProvider | None', *, system_prompt: str | None = None) -> SummaryResult | None:  # type: ignore[name-defined]
        settings = get_settings()
        async with self._lock:
            bucket = self._messages.get(room_id, [])
            if not bucket:
                return None
            # Копируем и удаляем чтобы повторно не суммировать
            msgs = list(bucket)
            self._messages.pop(room_id, None)

        # Формируем простой список строк для AI / fallback
        plain_messages = [
            f"[{m.ts}] {(m.author_name or m.author_id or 'anon')}: {m.content}" for m in msgs
        ]
        summary_text: str
        if settings.AI_SUMMARY_ENABLED and ai_provider is not None:
            # Порог минимального содержимого (суммируем длину контента сообщений без служебной обвязки)
            total_chars = sum(len(m.content) for m in msgs)
            min_chars = getattr(settings, 'AI_SUMMARY_MIN_CHARS', 0) or 0
            if min_chars > 0 and total_chars < min_chars:
                # Слишком короткая сессия — не вызываем внешнего AI, сразу эвристический вывод
                print(f"[summary] Skipping AI: content too short {total_chars} < {min_chars} (room={room_id})")
                summary_text = (
                    f"Сессия слишком короткая ({total_chars} < {min_chars}); содержательное резюме не сформировано.\n"
                    + _fallback_summary(plain_messages)
                )
            else:
                try:
                    try:
                        summary_text = await ai_provider.generate_summary(plain_messages, system_prompt)  # type: ignore[attr-defined]
                    except TypeError:  # старый интерфейс
                        summary_text = await ai_provider.generate_summary(plain_messages)  # type: ignore[attr-defined]
                except Exception as e:  # pragma: no cover - fallback
                    summary_text = _fallback_summary(plain_messages, error=str(e))
        else:
            summary_text = _fallback_summary(plain_messages)

        # Постобработка: если ответ слишком шаблонный/поверхностный при наличии всего 1-2 сообщений — добавим исходное сообщение.
        try:
            norm = summary_text.strip().lower()
            # эвристика: AI дал структуру пунктов без конкретики, и сообщений мало
            if len(msgs) <= 2 and (
                norm.startswith('1) основные темы:') or
                'основные темы:' in norm and 'принятые решения:' in norm
            ):
                tail_src = "\n\nИсточники:\n" + "\n".join(m.content for m in msgs)
                if 'источники:' not in norm:
                    summary_text = summary_text.rstrip() + tail_src
            else:
                # Расширенная эвристика: если всего сообщений <=8 или сам summary слишком короткий (< 500 символов), но нет блока Источники — добавим последние 5.
                if ('источники:' not in norm) and (len(msgs) <= 8 or len(summary_text) < 500):
                    tail_msgs = msgs[-5:]
                    sources_block = "\n\nИсточники (последние):\n" + "\n".join(m.content for m in tail_msgs)
                    summary_text = summary_text.rstrip() + sources_block
        except Exception:
            pass

        return SummaryResult(
            room_id=room_id,
            message_count=len(msgs),
            generated_at=int(time.time()*1000),
            summary_text=summary_text,
        )

    async def message_count(self, room_id: str) -> int:
        """Возвращает текущее число накопленных сообщений (без очистки)."""
        async with self._lock:
            return len(self._messages.get(room_id, []))

    async def get_messages_snapshot(self, room_id: str) -> List[ChatMessage]:
        """Возвращает копию текущих сообщений комнаты без очистки."""
        async with self._lock:
            return list(self._messages.get(room_id, []))


def _fallback_summary(messages: List[str], error: str | None = None) -> str:
    if not messages:
        return "Нет сообщений для суммаризации." + (f" (AI error: {error})" if error else "")
    # Берём последние 10 сообщений для короткого конспекта
    tail = messages[-10:]
    body = "\n".join(tail)
    if error:
        body += f"\n[AI недоступен: {error}]"
    return "Краткая выжимка (эвристика, без AI):\n" + body


# Глобальный singleton (процессовый) — достаточно для текущего сценария.
_collector_singleton: SummaryCollector | None = None


def get_summary_collector() -> SummaryCollector:
    global _collector_singleton
    if _collector_singleton is None:
        _collector_singleton = SummaryCollector()
    return _collector_singleton


class AISummaryProvider:  # интерфейс для адаптера AI
    async def generate_summary(self, plain_messages: list[str]) -> str:  # pragma: no cover - интерфейс
        raise NotImplementedError


async def summarize_messages(messages: List[ChatMessage], ai_provider: 'AISummaryProvider | None', *, system_prompt: str | None = None) -> SummaryResult:
    """Формирует SummaryResult из предоставленного списка сообщений (без модификации коллектора).

    Использует те же правила что и SummaryCollector.summarize, но не очищает исходный state
    (предназначено для персональных snapshot-сводок).
    """
    settings = get_settings()
    plain_messages = [f"[{m.ts}] {(m.author_name or m.author_id or 'anon')}: {m.content}" for m in messages]
    if not messages:
        return SummaryResult(room_id="unknown", message_count=0, generated_at=int(time.time()*1000), summary_text="Нет сообщений для суммаризации.")
    total_chars = sum(len(m.content) for m in messages)
    min_chars = getattr(settings, 'AI_SUMMARY_MIN_CHARS', 0) or 0
    if settings.AI_SUMMARY_ENABLED and ai_provider is not None:
        if min_chars > 0 and total_chars < min_chars:
            summary_text = (
                f"Сессия слишком короткая ({total_chars} < {min_chars}); содержательное резюме не сформировано.\n"
                + _fallback_summary(plain_messages)
            )
        else:
            try:
                try:
                    summary_text = await ai_provider.generate_summary(plain_messages, system_prompt)  # type: ignore[attr-defined]
                except TypeError:
                    summary_text = await ai_provider.generate_summary(plain_messages)  # type: ignore[attr-defined]
            except Exception as e:
                summary_text = _fallback_summary(plain_messages, error=str(e))
    else:
        summary_text = _fallback_summary(plain_messages)

    # Re-use постобработку (упрощённо): добавим источники если мало сообщений или коротко
    try:
        norm = summary_text.strip().lower()
        if ('источники:' not in norm) and (len(messages) <= 8 or len(summary_text) < 500):
            tail_msgs = messages[-5:]
            sources_block = "\n\nИсточники (последние):\n" + "\n".join(m.content for m in tail_msgs)
            summary_text = summary_text.rstrip() + sources_block
    except Exception:
        pass

    return SummaryResult(room_id=messages[0].room_id, message_count=len(messages), generated_at=int(time.time()*1000), summary_text=summary_text)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\message_log.py =====
--- SIZE: 2042 bytes ---

from __future__ import annotations
from collections import defaultdict, deque
from typing import Deque, List, Dict, Iterable
import time
from .models import ChatMessage, is_technical


class MessageLog:
    """Недеструктивный лог сообщений комнаты.

    Хранит хвост до limit_per_room сообщений.
    """
    def __init__(self, limit_per_room: int = 4000) -> None:
        self._storage: Dict[str, Deque[ChatMessage]] = defaultdict(deque)
        self._limit = limit_per_room

    def add(self, room_id: str, author_id: str | None, author_name: str | None, content: str, *, ts: int | None = None) -> ChatMessage:
        if not content:
            # игнор пустые
            return ChatMessage(room_id=room_id, author_id=author_id, author_name=author_name, content="", ts=int(time.time()*1000))
        msg = ChatMessage(room_id=room_id, author_id=author_id, author_name=author_name, content=content.strip(), ts=ts or int(time.time()*1000))
        bucket = self._storage[room_id]
        bucket.append(msg)
        # trim
        while len(bucket) > self._limit:
            bucket.popleft()
        return msg

    def slice_since(self, room_id: str, from_ts: int | None) -> List[ChatMessage]:
        bucket = self._storage.get(room_id)
        if not bucket:
            return []
        if from_ts is None:
            return list(bucket)
        return [m for m in bucket if m.ts >= from_ts]

    def tail(self, room_id: str, n: int) -> List[ChatMessage]:
        bucket = self._storage.get(room_id)
        if not bucket:
            return []
        if n <= 0:
            return []
        return list(bucket)[-n:]

    def all_user_visible(self, room_id: str) -> List[ChatMessage]:
        # Исключаем технические/пустые сообщения
        bucket = self._storage.get(room_id)
        if not bucket:
            return []
        return [m for m in bucket if not is_technical(m)]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\message_log.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\models.py =====
--- SIZE: 1816 bytes ---

from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional
import time


@dataclass(slots=True)
class ChatMessage:
    room_id: str
    author_id: str | None
    author_name: str | None
    content: str
    ts: int  # epoch ms
    def to_plain(self) -> str:
        who = self.author_name or self.author_id or "anon"
        return f"[{self.ts}] {who}: {self.content}".strip()


@dataclass(slots=True)
class ParticipantSummary:
    participant_id: str | None
    participant_name: str | None
    message_count: int
    # Краткая выжимка (эвристика) вклада участника — список последних сообщений участника (до 5)
    sample_messages: List[str]


@dataclass(slots=True)
class SummaryResult:
    room_id: str
    message_count: int
    generated_at: int
    summary_text: str
    sources: List[ChatMessage]
    used_voice: bool = False
    truncated: bool = False
    # Новый блок: разбивка по участникам (может быть пустым если отключено)
    participants: List[ParticipantSummary] | None = None

    @classmethod
    def empty(cls, room_id: str) -> 'SummaryResult':
        return cls(room_id=room_id, message_count=0, generated_at=int(time.time()*1000), summary_text="Нет сообщений для суммаризации.", sources=[], used_voice=False, participants=[])


TECHNICAL_PATTERNS = [
    '(asr failed http 400)',
    '(asr failed',
    'error asr',
]

def is_technical(msg: ChatMessage) -> bool:
    low = msg.content.lower().strip()
    if not low:
        return True
    for p in TECHNICAL_PATTERNS:
        if p in low:
            return True
    return False

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\models.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\orchestrator.py =====
--- SIZE: 25636 bytes ---

from __future__ import annotations
from typing import Dict, Tuple, List
import time, contextlib
from .message_log import MessageLog
from .models import SummaryResult, ChatMessage, TECHNICAL_PATTERNS
from .strategies import ChatStrategy, CombinedVoiceChatStrategy
from .user_agent import UserAgentSession
from ...config import get_settings
from ..ai_provider import get_user_system_prompt
from ..voice_transcript import get_voice_collector
import logging

logger = logging.getLogger(__name__)


class SummaryOrchestrator:
    """Оркестратор новой архитектуры персональных агентов.

    КЛЮЧЕВЫЕ ИЗМЕНЕНИЯ:
    1. Для каждого (room_id, user_id) создаётся независимая `UserAgentSession`.
    2. В сессии хранится собственный список сообщений и голосовая транскрипция.
    3. Добавление сообщений в общий лог продолжается (для будущих сценариев), но построение персонального summary
       опирается только на сообщения внутри конкретной сессии, что предотвращает утечку данных между пользователями.
    4. Завершение одной сессии (stop) не влияет на продолжающиеся сессии других пользователей.
    5. Pending voice wait: при запросе summary, если окно пустое и возможно идёт финализация ASR, выполняется короткое
       ожидание появления транскрипта (poll voice collector) чтобы уменьшить число "пустых" ответов.
    """
    def __init__(self) -> None:
        self._log = MessageLog()
        # активные/завершенные (до очистки) сессии: (room_id,user_id) -> UserAgentSession
        self._sessions: Dict[Tuple[str, str], UserAgentSession] = {}
        # Быстрый индекс по комнате для доставки новых сообщений в активные сессии
        self._room_sessions: Dict[str, List[UserAgentSession]] = {}
        # Стратегии (для fallback путей — вероятно не нужны, но оставим)
        self._chat_strategy = ChatStrategy()
        self._combined_strategy = CombinedVoiceChatStrategy()
        # Unified counters (in-memory) — не критично к перезапуску
        self._counters: Dict[str, int] = {
            'voice_add_total': 0,
            'voice_reject_stale': 0,
            'voice_reject_no_meta': 0,
            'voice_fallback_attached': 0,
            'voice_fallback_stale': 0,
            'voice_lazy_attached': 0,
            'voice_lazy_skipped_placeholder': 0,
            'voice_pending_attached': 0,
            'voice_second_chance_attached': 0,
            'session_auto_created_on_voice': 0,
            'session_recovered_from_voice': 0,
            'session_auto_resumed': 0,
        }

    # Публичное read-only получение счётчиков (для диагностики / последующей экспозиции)
    def get_counters(self) -> Dict[str, int]:
        return dict(self._counters)

    def _bump(self, key: str) -> None:
        try:
            self._counters[key] = self._counters.get(key, 0) + 1
        except Exception:
            pass

    def add_chat(self, room_id: str, author_id: str | None, author_name: str | None, content: str) -> None:
        """Регистрация нового чат сообщения.

        1. Кладём в общий MessageLog (исторический хвост по комнате).
        2. Рассылаем во все активные сессии данной комнаты чтобы они зафиксировали сообщение (если попадает в окно).
        """
        msg = self._log.add(room_id, author_id, author_name, content)
        # Доставка в активные сессии комнаты
        sessions = self._room_sessions.get(room_id)
        if sessions:
            for sess in sessions:
                # активная если не stop или msg.ts <= end
                sess.add_chat(msg)

    def add_voice_transcript(self, room_id: str, transcript: str, user_id: str | None = None) -> None:
        """Сохраняет голосовую транскрипцию в персональную сессию пользователя.

        Если сессия ещё не создана (агент стартовал после транскрипта) — создаём её со start_ts=сейчас
        чтобы пользователь всё равно получил свою расшифровку.
        """
        if not transcript or not user_id:
            return
        transcript = transcript.strip()
        if not transcript:
            return
        key = (room_id, user_id)
        sess = self._sessions.get(key)
        if not sess or (sess and sess.end_ts is not None):
            # Нет активной сессии или предыдущая завершена — создаём новую для новой записи
            if sess and sess.end_ts is not None:
                with contextlib.suppress(ValueError):
                    self._room_sessions.get(room_id, []).remove(sess)
            sess = UserAgentSession(room_id=room_id, user_id=user_id)
            self._sessions[key] = sess
            self._room_sessions.setdefault(room_id, []).append(sess)
            logger.debug("summary_v2: auto-created session on voice transcript room=%s user=%s", room_id, user_id)
            self._bump('session_auto_created_on_voice')
        technical = False
        low = transcript.lower()
        if low.startswith('(no audio') or low.startswith('(asr failed') or low.startswith('(asr exception') or low.startswith('(asr disabled'):
            technical = True
        # Парсинг мета-префикса (если мы его добавили в voice_capture)
        meta_capture_ts = None
        has_meta = False
        try:
            if transcript.startswith('[meta '):
                end = transcript.find(']')
                if end != -1:
                    meta_block = transcript[6:end].strip()
                    body = transcript[end+1:].lstrip()
                    parts = meta_block.split()
                    for p in parts:
                        if p.startswith('captureTs='):
                            try:
                                meta_capture_ts = int(p.split('=',1)[1])
                            except Exception:
                                pass
                    has_meta = True
                    # Проверка на устаревание относительно старта текущей сессии
                    if meta_capture_ts is not None and meta_capture_ts < (sess.start_ts - 150):
                        logger.debug("summary_v2: ignore stale voice transcript by captureTs room=%s user=%s captureTs=%s start_ts=%s", room_id, user_id, meta_capture_ts, sess.start_ts)
                        self._bump('voice_reject_stale')
                        return
                    transcript = body
        except Exception:
            pass
        # Если меты нет – применяем строгий фильтр: окно <=10s от старта и отсутствие предыдущих voice сегментов
        if not has_meta:
            now_ms = int(time.time()*1000)
            voice_already = bool(getattr(sess, '_voice_segments', None))  # type: ignore[attr-defined]
            age = now_ms - sess.start_ts
            if age > 10_000 or voice_already:
                logger.debug("summary_v2: reject voice(no-meta) room=%s user=%s age_ms=%s has_voice=%s", room_id, user_id, age, voice_already)
                self._bump('voice_reject_no_meta')
                return
        sess.add_voice_transcript(transcript)
        self._bump('voice_add_total')
        logger.info(
            "summary_v2: add_voice_transcript room=%s user=%s chars=%s technical=%s meta=%s captureTs=%s head=%r",
            room_id, user_id, len(transcript), technical, has_meta, meta_capture_ts, transcript[:60]
        )

    async def start_user_window(self, room_id: str, user_id: str) -> None:
        """Старт (или перезапуск) персонального окна пользователя."""
        key = (room_id, user_id)
        # перезапуск должен сбросить старую сессию
        old = self._sessions.get(key)
        if old:
            # мягко помечаем остановку старой, но не удаляем мгновенно (на случай параллельного запроса summary)
            old.stop()
            # удалим из индекса комнаты
            with contextlib.suppress(ValueError):
                self._room_sessions.get(room_id, []).remove(old)
        sess = UserAgentSession(room_id=room_id, user_id=user_id)
        self._sessions[key] = sess
        self._room_sessions.setdefault(room_id, []).append(sess)
        # Не удаляем транскрипт из коллектора при рестарте: если запись ещё финализируется, она прикрепится лениво.
        logger.debug("summary_v2: started new user window room=%s user=%s start_ts=%s", room_id, user_id, sess.start_ts)

    def end_user_window(self, room_id: str, user_id: str) -> None:
        key = (room_id, user_id)
        sess = self._sessions.get(key)
        if sess:
            sess.stop()

    async def build_personal_summary(self, *, room_id: str, user_id: str, ai_provider, db_session, cutoff_ms: int | None = None) -> SummaryResult:
        """Формирует персональное summary для пользователя в комнате.

        Если сессия отсутствует — возвращает пустой результат (пользователь ещё не запустил агента).
        cutoff_ms сейчас не используется напрямую (сессия уже ограничена end_ts), но параметр
        оставлен для обратной совместимости вызовов.
        """
        key = (room_id, user_id)
        sess = self._sessions.get(key)
        if not sess:
            # Попытка аварийного восстановления: только если voice свежий (после предполагаемого старта — у нас его нет, поэтому принимаем любой, но фильтруем плейсхолдеры)
            try:
                vc = get_voice_collector()
                voice_key = f"{room_id}:{user_id}"
                with contextlib.suppress(Exception):
                    vt = await vc.get_transcript(voice_key)
                    if vt and getattr(vt, 'text', None):
                        txt = vt.text.strip()
                        low = txt.lower()
                        if txt and not low.startswith('(no audio chunks') and not low.startswith('(asr failed') and not low.startswith('(asr exception') and not low.startswith('(asr disabled'):
                            sess = UserAgentSession(room_id=room_id, user_id=user_id)
                            sess.add_voice_transcript(txt)
                            self._sessions[key] = sess
                            self._room_sessions.setdefault(room_id, []).append(sess)
                            logger.warning("summary_v2: recovered session from voice transcript room=%s user=%s len=%s", room_id, user_id, len(txt))
                            self._bump('session_recovered_from_voice')
            except Exception:
                pass
            if not sess:
                logger.info("summary_v2: build_personal_summary empty (no session) room=%s user=%s", room_id, user_id)
                return SummaryResult.empty(room_id)
        # Диагностика текущего состояния сессии ДО ленивого voice attach
        try:
            voice_segments = getattr(sess, '_voice_segments', [])  # type: ignore[attr-defined]
            logger.debug(
                "summary_v2: pre-build state room=%s user=%s msgs=%s voice_segments=%s ended=%s", room_id, user_id, len(getattr(sess, '_messages', [])), len(voice_segments), getattr(sess, 'end_ts', None)
            )
        except Exception:
            pass

        # ФОЛБЭК: если окно абсолютно пустое (ни сообщений, ни voice), пробуем единожды подтянуть персональный записанный транскрипт из коллектора.
        try:
            msgs_now = getattr(sess, '_messages', [])
            voice_now = getattr(sess, '_voice_segments', [])  # type: ignore[attr-defined]
            if not msgs_now and not voice_now:
                vc_fb = get_voice_collector()
                vt_fb = await vc_fb.get_transcript(f"{room_id}:{user_id}")
                if vt_fb and getattr(vt_fb, 'text', None):
                    raw_fb = vt_fb.text.strip()
                    if raw_fb and not raw_fb.lower().startswith('(no audio'):
                        # Парсим мету чтобы достать captureTs (может отсутствовать — тогда считаем свежим)
                        capture_ts_fb = None
                        if raw_fb.startswith('[meta ') and 'captureTs=' in raw_fb:
                            end_br = raw_fb.find(']')
                            if end_br != -1:
                                meta_block = raw_fb[6:end_br].strip()
                                for part in meta_block.split():
                                    if part.startswith('captureTs='):
                                        with contextlib.suppress(Exception):
                                            capture_ts_fb = int(part.split('=',1)[1])
                        fresh_ok = True
                        if capture_ts_fb is not None and capture_ts_fb < (sess.start_ts - 150):
                            fresh_ok = False
                        if fresh_ok:
                            # Удаляем мета префикс при добавлении во внутренние сегменты, оставляем чистый текст
                            if raw_fb.startswith('[meta ') and ']' in raw_fb:
                                body_pos = raw_fb.find(']')
                                if body_pos != -1:
                                    raw_clean = raw_fb[body_pos+1:].lstrip()
                                else:
                                    raw_clean = raw_fb
                            else:
                                raw_clean = raw_fb
                            sess.add_voice_transcript(raw_clean)
                            logger.info("summary_v2: fallback attached stored transcript room=%s user=%s len=%s captureTs=%s start_ts=%s", room_id, user_id, len(raw_clean), capture_ts_fb, sess.start_ts)
                            self._bump('voice_fallback_attached')
                            # Попробуем удалить чтобы не переиспользовать
                            with contextlib.suppress(Exception):
                                await vc_fb.pop_transcript(f"{room_id}:{user_id}")
                        else:
                            logger.debug("summary_v2: fallback transcript stale room=%s user=%s captureTs=%s start_ts=%s", room_id, user_id, capture_ts_fb, sess.start_ts)
                            self._bump('voice_fallback_stale')
        except Exception:
            pass

        # Авто-восстановление: если сессия завершена, но после end_ts появились новые чат сообщения или свежая voice транскрипция — создаём новую сессию.
        if sess.end_ts is not None:
            try:
                # Проверим новые чат сообщения после end_ts
                new_chat = False
                tail = self._log.slice_since(room_id, sess.end_ts + 1)
                if tail:
                    new_chat = True
                # Проверим новую voice (generated_at > end_ts)
                fresh_voice = False
                with contextlib.suppress(Exception):
                    vc = get_voice_collector()
                    vt2 = await vc.get_transcript(f"{room_id}:{user_id}")
                    if vt2 and vt2.generated_at > sess.end_ts:
                        txt2 = (vt2.text or '').strip()
                        if txt2 and not txt2.lower().startswith('(no audio'):
                            fresh_voice = True
                if new_chat or fresh_voice:
                    # Создаём новую сессию с началом = макс(end_ts+1, first_new_ts)
                    with contextlib.suppress(ValueError):
                        self._room_sessions.get(room_id, []).remove(sess)
                    new_sess = UserAgentSession(room_id=room_id, user_id=user_id)
                    # Если есть новое чат сообщение — подгоним start_ts чтобы исключить старые
                    if tail:
                        first_ts = tail[0].ts
                        new_sess.start_ts = min(first_ts, int(time.time()*1000))
                    self._sessions[key] = new_sess
                    self._room_sessions.setdefault(room_id, []).append(new_sess)
                    sess = new_sess
                    # Доставим новые чат сообщения в новую сессию
                    for m in tail:
                        sess.add_chat(m)
                    if fresh_voice:
                        with contextlib.suppress(Exception):
                            if vt2 and vt2.text:
                                sess.add_voice_transcript(vt2.text.strip())
                            logger.info("summary_v2: auto-resumed session room=%s user=%s new_chat=%s fresh_voice=%s", room_id, user_id, new_chat, fresh_voice)
                            self._bump('session_auto_resumed')
            except Exception:
                pass
        # Если в сессии нет voice, попробуем подтянуть (лениво) готовую транскрипцию, чтобы не было окна, когда агент стартовал чуть позже окончания речи
        # Ленивая подгрузка: если пока нет ни одного voice сегмента, попробуем взять существующий транскрипт.
        if not getattr(sess, '_voice_segments', None):  # type: ignore[attr-defined]
            try:
                vc = get_voice_collector()
                voice_key = f"{room_id}:{user_id}"
                with contextlib.suppress(Exception):
                    vt = await vc.get_transcript(voice_key)
                    if vt and getattr(vt, 'text', None):
                        txt = vt.text.strip()
                        low = txt.lower()
                        # Фильтрация: текст нетехнический и сгенерирован не раньше старта (разрешаем небольшой дрейф -100мс)
                        if txt and not (low.startswith('(no audio chunks') or low.startswith('(asr failed') or low.startswith('(asr exception') or low.startswith('(asr disabled')) and vt.generated_at >= (sess.start_ts - 100):
                            sess.add_voice_transcript(txt)
                            logger.info("summary_v2: lazy attach voice transcript room=%s user=%s len=%s gen_at=%s start_ts=%s", room_id, user_id, len(txt), vt.generated_at, sess.start_ts)
                            self._bump('voice_lazy_attached')
                        else:
                            logger.debug("summary_v2: skip voice transcript placeholder/technical room=%s user=%s raw=%r", room_id, user_id, txt[:80] if txt else txt)
                            self._bump('voice_lazy_skipped_placeholder')
            except Exception:
                pass
        # Получаем персональный system prompt
        system_prompt: str | None = None
        if db_session is not None:
            with contextlib.suppress(Exception):
                system_prompt = await get_user_system_prompt(db_session, user_id)
        result = await sess.build_summary(ai_provider=ai_provider, system_prompt=system_prompt)
        # Pending ожидание голоса: если окно пустое, нет voice сегментов и нет сообщений — подождём немного появление транскрипта
        if result.message_count == 0 and not getattr(result, 'used_voice', False):
            try:
                voice_segments_now = getattr(sess, '_voice_segments', [])  # type: ignore[attr-defined]
                msgs_now = getattr(sess, '_messages', [])
                if not voice_segments_now and not msgs_now:
                    wait_total = 0
                    MAX_WAIT_MS = 2500
                    STEP_MS = 350
                    while wait_total < MAX_WAIT_MS:
                        import asyncio
                        await asyncio.sleep(STEP_MS / 1000)
                        wait_total += STEP_MS
                        # Проверяем появился ли транскрипт
                        with contextlib.suppress(Exception):
                            vc = get_voice_collector()
                            vt_wait = await vc.get_transcript(f"{room_id}:{user_id}")
                            if vt_wait and getattr(vt_wait, 'text', None):
                                txtw = vt_wait.text.strip()
                                loww = txtw.lower()
                                if txtw and not (loww.startswith('(no audio') or loww.startswith('(asr failed') or loww.startswith('(asr exception') or loww.startswith('(asr disabled')):
                                    sess.add_voice_transcript(txtw)
                                    logger.info("summary_v2: pending wait attached voice room=%s user=%s len=%s waited_ms=%s", room_id, user_id, len(txtw), wait_total)
                                    self._bump('voice_pending_attached')
                                    result = await sess.build_summary(ai_provider=ai_provider, system_prompt=system_prompt)
                                    break
                    else:
                        logger.debug("summary_v2: pending wait timeout room=%s user=%s waited_ms=%s", room_id, user_id, wait_total)
            except Exception:
                pass
        # Если пусто, но теперь (во время генерации) появился voice транскрипт — пробуем ещё раз один раз.
        if result.message_count == 0 and not getattr(result, 'used_voice', False):
            try:
                if not getattr(sess, '_voice_segments', None):  # всё ещё нет
                    vc = get_voice_collector()
                    vt_retry = await vc.get_transcript(f"{room_id}:{user_id}")
                    if vt_retry and getattr(vt_retry, 'text', None):
                        txt2 = vt_retry.text.strip()
                        low2 = txt2.lower()
                        if txt2 and not (low2.startswith('(no audio') or low2.startswith('(asr failed') or low2.startswith('(asr exception') or low2.startswith('(asr disabled')) and vt_retry.generated_at >= (sess.start_ts - 100):
                            sess.add_voice_transcript(txt2)
                            logger.info("summary_v2: second-chance attach voice transcript room=%s user=%s len=%s", room_id, user_id, len(txt2))
                            self._bump('voice_second_chance_attached')
                            result = await sess.build_summary(ai_provider=ai_provider, system_prompt=system_prompt)
            except Exception:
                pass
        try:
            logger.debug(
                "summary_v2: post-build result room=%s user=%s msg_count=%s used_voice=%s", room_id, user_id, result.message_count, getattr(result, 'used_voice', False)
            )
        except Exception:
            pass
        return result

# singleton accessor
_orchestrator_singleton: SummaryOrchestrator | None = None

def get_summary_orchestrator() -> SummaryOrchestrator:
    global _orchestrator_singleton
    if _orchestrator_singleton is None:
        _orchestrator_singleton = SummaryOrchestrator()
    return _orchestrator_singleton

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\orchestrator.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\strategies.py =====
--- SIZE: 6490 bytes ---

from __future__ import annotations
from typing import List, Optional
from .models import ChatMessage, SummaryResult, is_technical, ParticipantSummary
from ...config import get_settings
import time


class BaseStrategy:
    async def build(self, msgs: List[ChatMessage], *, ai_provider, system_prompt: str | None) -> SummaryResult:
        raise NotImplementedError

    def _fallback(self, msgs: List[ChatMessage], *, prefix: str = "") -> str:
        if not msgs:
            return "Нет сообщений для суммаризации."
        tail = msgs[-10:]
        lines = [m.to_plain() for m in tail]
        body = "\n".join(lines)
        return (prefix + "\n" if prefix else "") + "Краткая выжимка:\n" + body


def _build_participant_breakdown(msgs: List[ChatMessage]) -> List[ParticipantSummary]:
    """Группирует сообщения по (author_id, author_name) и формирует короткую выборку.

    Правила:
    - Игнорируем технические сообщения.
    - Для каждого участника берём последние до 5 сообщений как sample.
    - Сортировка по убыванию количества сообщений, затем по имени.
    """
    buckets: dict[tuple[str | None, str | None], List[ChatMessage]] = {}
    for m in msgs:
        if is_technical(m):
            continue
        key = (m.author_id, m.author_name)
        buckets.setdefault(key, []).append(m)
    parts: List[ParticipantSummary] = []
    for (pid, pname), group in buckets.items():
        # последние 5 сообщений участника
        tail = group[-5:]
        parts.append(ParticipantSummary(
            participant_id=pid,
            participant_name=pname,
            message_count=len(group),
            sample_messages=[g.content for g in tail]
        ))
    parts.sort(key=lambda p: (-p.message_count, (p.participant_name or p.participant_id or "")))
    return parts


class ChatStrategy(BaseStrategy):
    async def build(self, msgs: List[ChatMessage], *, ai_provider, system_prompt: str | None) -> SummaryResult:
        settings = get_settings()
        user_msgs = [m for m in msgs if not is_technical(m)]
        if not user_msgs:
            return SummaryResult.empty(msgs[0].room_id if msgs else "unknown")
        plain = [m.to_plain() for m in user_msgs]
        total_chars = sum(len(m.content) for m in user_msgs)
        min_chars = getattr(settings, 'AI_SUMMARY_MIN_CHARS', 0) or 0
        summary_text: str
        if ai_provider and settings.AI_SUMMARY_ENABLED and (total_chars >= min_chars):
            try:
                try:
                    summary_text = await ai_provider.generate_summary(plain, system_prompt)  # type: ignore
                except TypeError:
                    summary_text = await ai_provider.generate_summary(plain)  # type: ignore
            except Exception as e:
                summary_text = self._fallback(user_msgs, prefix=f"[AI error: {e}]")
        else:
            if total_chars < min_chars:
                prefix = f"Слишком мало текста ({total_chars} < {min_chars})."
            else:
                prefix = "AI отключён."
            summary_text = self._fallback(user_msgs, prefix=prefix)
        # append sources (последние user сообщения без тех)
        tail_src = user_msgs[-5:]
        if tail_src:
            summary_text = summary_text.rstrip() + "\n\nИсточники (последние):\n" + "\n".join(m.content for m in tail_src)
        # Participant breakdown (если включено через настройки)
        participants = None
        try:
            from ...config import get_settings  # локальный импорт чтобы избежать циклов
            if get_settings().AI_SUMMARY_PARTICIPANT_BREAKDOWN:
                participants = _build_participant_breakdown(user_msgs)
        except Exception:
            participants = None
        return SummaryResult(room_id=user_msgs[0].room_id, message_count=len(user_msgs), generated_at=int(time.time()*1000), summary_text=summary_text, sources=tail_src, participants=participants)


class CombinedVoiceChatStrategy(BaseStrategy):
    async def build(self, msgs: List[ChatMessage], *, ai_provider, system_prompt: str | None) -> SummaryResult:
        # msgs уже включает voice pseudo messages + chat
        chat_part = [m for m in msgs if not is_technical(m)]
        if not chat_part:
            return SummaryResult.empty(msgs[0].room_id if msgs else "unknown")
        settings = get_settings()
        plain = [m.to_plain() for m in chat_part]
        total_chars = sum(len(m.content) for m in chat_part)
        min_chars = getattr(settings, 'AI_SUMMARY_MIN_CHARS', 0) or 0
        summary_text: str
        if ai_provider and settings.AI_SUMMARY_ENABLED and total_chars >= min_chars:
            try:
                try:
                    summary_text = await ai_provider.generate_summary(plain, system_prompt)  # type: ignore
                except TypeError:
                    summary_text = await ai_provider.generate_summary(plain)  # type: ignore
            except Exception as e:
                summary_text = self._fallback(chat_part, prefix=f"[AI error: {e}]")
        else:
            if total_chars < min_chars:
                prefix = f"Слишком мало текста ({total_chars} < {min_chars})."
            else:
                prefix = "AI отключён."
            summary_text = self._fallback(chat_part, prefix=prefix)
        tail_src = chat_part[-5:]
        if tail_src:
            summary_text = summary_text.rstrip() + "\n\nИсточники (последние):\n" + "\n".join(m.content for m in tail_src)
        participants = None
        try:
            from ...config import get_settings
            if get_settings().AI_SUMMARY_PARTICIPANT_BREAKDOWN:
                participants = _build_participant_breakdown(chat_part)
        except Exception:
            participants = None
        return SummaryResult(room_id=chat_part[0].room_id, message_count=len(chat_part), generated_at=int(time.time()*1000), summary_text=summary_text, sources=tail_src, used_voice=True, participants=participants)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\strategies.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\user_agent.py =====
--- SIZE: 8632 bytes ---

from __future__ import annotations
"""Персональная сессия AI агента пользователя.

Каждый пользователь в рамках комнаты получает независимую сессию:
 - фиксируется момент старта (start_ts)
 - опционально фиксируется момент остановки (end_ts)
 - накапливаются только сообщения пришедшие после старта и до остановки
 - голосовая транскрипция хранится отдельно (последняя валидная, не техническая)

Так мы избегаем ситуации когда второй пользователь видит расшифровку/summary
первого: их источники данных отделены.
"""
from dataclasses import dataclass, field
from typing import List, Optional
import time, re
from .models import ChatMessage, SummaryResult, TECHNICAL_PATTERNS, ParticipantSummary
import logging

logger = logging.getLogger(__name__)
from .strategies import ChatStrategy, CombinedVoiceChatStrategy


def _is_technical_text(text: str) -> bool:
    low = text.lower().strip()
    if not low:
        return True
    for p in TECHNICAL_PATTERNS:
        if p in low:
            return True
    return False


@dataclass
class UserAgentSession:
    room_id: str
    user_id: str
    start_ts: int = field(default_factory=lambda: int(time.time()*1000))
    end_ts: Optional[int] = None
    _messages: List[ChatMessage] = field(default_factory=list)  # только пользовательское окно
    # Список голосовых сегментов (в порядке поступления). Поддерживает несколько записей.
    _voice_segments: List[str] = field(default_factory=list)
    _chat_strategy: ChatStrategy = field(default_factory=ChatStrategy, init=False, repr=False)
    _combined_strategy: CombinedVoiceChatStrategy = field(default_factory=CombinedVoiceChatStrategy, init=False, repr=False)

    def add_chat(self, msg: ChatMessage) -> None:
        """Добавляет сообщение если оно попадает в окно сессии."""
        if msg.room_id != self.room_id:
            return
        if msg.ts < self.start_ts:
            return
        if self.end_ts is not None and msg.ts > self.end_ts:
            return
        self._messages.append(msg)

    def add_voice_transcript(self, transcript: str) -> None:
        """Добавить транскрипт.

        Правила:
        - Пустые строки игнорируются.
        - Технические плейсхолдеры добавляются только если ещё нет ни одного нетехнического текста.
        - Если новый нетехнический сегмент является надстройкой предыдущего (содержит его целиком) — заменяем последний.
        - Дубликаты игнорируем.
        """
        if not transcript:
            return
        txt = transcript.strip()
        if not txt:
            return
        is_tech = _is_technical_text(txt)
        if is_tech:
            if any(not _is_technical_text(s) for s in self._voice_segments):
                return
            if self._voice_segments and self._voice_segments[-1] == txt:
                return
            self._voice_segments.append(txt)
            return
        # Нормальный текст
        if self._voice_segments:
            last = self._voice_segments[-1]
            # last subset of new -> replace; new subset of last -> ignore; identical -> ignore
            if txt == last or (len(txt) < len(last) and txt in last):
                return
            if len(txt) > len(last) and last in txt and not _is_technical_text(last):
                self._voice_segments[-1] = txt
                return
        self._voice_segments.append(txt)


    def merged_voice_text(self) -> Optional[str]:
        if not self._voice_segments:
            return None
        non_tech = [s for s in self._voice_segments if not _is_technical_text(s)]
        base = non_tech if non_tech else self._voice_segments
        return " \n".join(base)

    def stop(self) -> None:
        if self.end_ts is None:
            self.end_ts = int(time.time()*1000)

    async def build_summary(self, *, ai_provider, system_prompt: str | None) -> SummaryResult:
        # Отфильтруем по end_ts если окно завершено (теоретически могли добавить позже)
        msgs = [m for m in self._messages if (self.end_ts is None or m.ts <= self.end_ts)]
        voice_text = self.merged_voice_text()
        # Если чат пуст, но есть валидный voice
        if not msgs:
            if voice_text and len(voice_text.strip()) > 10 and not _is_technical_text(voice_text):
                norm = re.sub(r"\s+", " ", voice_text.strip())
                parts = re.split(r'(?<=[.!?])\s+', norm)
                sentences = [p.strip() for p in parts if p.strip()]
                if not sentences:
                    sentences = [voice_text.strip()]
                now_ms = int(time.time()*1000)
                voice_msgs = [ChatMessage(room_id=self.room_id, author_id=None, author_name='voice', content=s, ts=now_ms) for s in sentences]
                logger.info("summary_v2: voice-only summary room=%s user=%s parts=%s", self.room_id, self.user_id, len(voice_msgs))
                # Стратегия уже добавит breakdown (она использует CombinedVoiceChatStrategy -> strategies)
                return await self._combined_strategy.build(voice_msgs, ai_provider=ai_provider, system_prompt=system_prompt)
            # Только технический или слишком короткий voice
            if voice_text and _is_technical_text(voice_text):
                return SummaryResult(room_id=self.room_id, message_count=0, generated_at=int(time.time()*1000), summary_text="Речь не распознана или пуста. Повторите попытку.", sources=[], used_voice=False)
            return SummaryResult.empty(self.room_id)
        # Если все чат сообщения технические, но есть нормальный voice — используем его
        non_tech = [m for m in msgs if not _is_technical_text(m.content)]
        if not non_tech and voice_text and len(voice_text.strip()) > 10 and not _is_technical_text(voice_text):
            norm = re.sub(r"\s+", " ", voice_text.strip())
            parts = re.split(r'(?<=[.!?])\s+', norm)
            sentences = [p.strip() for p in parts if p.strip()]
            if not sentences:
                sentences = [voice_text.strip()]
            now_ms = int(time.time()*1000)
            voice_msgs = [ChatMessage(room_id=self.room_id, author_id=None, author_name='voice', content=s, ts=now_ms) for s in sentences]
            logger.info("summary_v2: voice-only (chat technical) summary room=%s user=%s parts=%s", self.room_id, self.user_id, len(voice_msgs))
            return await self._combined_strategy.build(voice_msgs, ai_provider=ai_provider, system_prompt=system_prompt)
        # Комбинированный путь если voice информативный
        merged = msgs
        strategy = self._chat_strategy
        if voice_text and len(voice_text.strip()) > 10 and not _is_technical_text(voice_text):
            norm = re.sub(r"\s+", " ", voice_text.strip())
            parts = re.split(r'(?<=[.!?])\s+', norm)
            sentences = [p.strip() for p in parts if p.strip()]
            if not sentences:
                sentences = [voice_text.strip()]
            now_ms = int(time.time()*1000)
            voice_msgs = [ChatMessage(room_id=self.room_id, author_id=None, author_name='voice', content=s, ts=now_ms) for s in sentences]
            merged = msgs + voice_msgs
            strategy = self._combined_strategy
            logger.info("summary_v2: combined voice+chat summary room=%s user=%s chat_msgs=%s voice_parts=%s", self.room_id, self.user_id, len(msgs), len(voice_msgs))
        return await strategy.build(merged, ai_provider=ai_provider, system_prompt=system_prompt)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\summary_v2\user_agent.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram.py =====
--- SIZE: 3417 bytes ---

from __future__ import annotations

"""Отправка сообщений в Telegram.

Используем обычный HTTP POST к Bot API. Для простоты и отсутствия
доп зависимости берём httpx (уже в зависимостях). Если токена или chat id
нет — функция молча возвращает False.
"""

import httpx
import asyncio
import logging
import contextlib
from ..config import get_settings
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from ..db.models import TelegramLinks

logger = logging.getLogger(__name__)


async def _post_message(token: str, chat_id: str, text: str) -> bool:
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    payload = {"chat_id": chat_id, "text": text[:4000]}
    timeout = httpx.Timeout(10.0, connect=5.0)
    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            r = await client.post(url, data=payload)
            if r.status_code != 200:
                body = None
                with contextlib.suppress(Exception):  # type: ignore[name-defined]
                    body = r.text[:300]
                logger.warning("telegram: sendMessage failed status=%s chat_id=%s body=%r", r.status_code, chat_id, body)
                return False
            return True
    except Exception as e:  # pragma: no cover
        logger.error("telegram: exception sending chat_id=%s err=%s", chat_id, e)
        return False


async def send_message(text: str, chat_ids: list[str] | None = None, session: AsyncSession | None = None) -> bool:
    """Отправка сообщения.

    Приоритет:
      1. Если передан список chat_ids — отправляем каждому.
      2. Иначе, если есть связанные confirmed chat_id в БД (session обязателен) — отправляем всем уникальным.
      3. Иначе fallback к глобальному TELEGRAM_CHAT_ID.
    Возвращает True если удалось хотя бы в один чат.
    """
    settings = get_settings()
    if not settings.TELEGRAM_BOT_TOKEN:
        logger.debug("telegram: skip send (no token)")
        return False
    token = settings.TELEGRAM_BOT_TOKEN

    targets: list[str] = []
    if chat_ids:
        targets = chat_ids
    elif session is not None:
        q = select(TelegramLinks.chat_id).where(TelegramLinks.status == 'confirmed', TelegramLinks.chat_id.is_not(None))
        res = await session.execute(q)
        targets = [c for (c,) in res.all() if c]
    if not targets and settings.TELEGRAM_CHAT_ID:
        targets = [settings.TELEGRAM_CHAT_ID]
    if not targets:
        logger.debug("telegram: skip send (no targets)")
        return False
    success_any = False
    for cid in set(targets):
        ok = await _post_message(token, cid, text)
        success_any = success_any or ok
        logger.info("telegram: dispatched chat_id=%s ok=%s text_len=%s", cid, ok, len(text))
    return success_any


# Синхронный helper (если где-то нужен) — не используем в async коде.
def send_message_sync(text: str) -> bool:  # pragma: no cover - вспомогательная
    return asyncio.run(send_message(text))

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram_dispatcher.py =====
--- SIZE: 6509 bytes ---

from __future__ import annotations

"""Упрощённый диспетчер отправки сообщений в Telegram с очередью,
ретраями и защитой от дублей.

Использование:
    from .telegram_dispatcher import get_dispatcher
    dispatcher = get_dispatcher()
    await dispatcher.queue_summary(user_id, text, reason="manual")

Дубликаты подавляются по ключу (user_id, summary_hash, reason) в течение TTL.

Не претендует на полноту брокера. В перспективе можно заменить
на Redis Stream / Celery.
"""

import asyncio, hashlib, time, contextlib, logging
from dataclasses import dataclass
from typing import Optional, Dict, Deque, Set
from collections import deque
from sqlalchemy.ext.asyncio import AsyncSession
from .telegram import send_message as low_level_send
from ..config import get_settings
from ..db.session import get_session
from ..db.models import TelegramLinks
from sqlalchemy import select

logger = logging.getLogger(__name__)

@dataclass
class PendingTask:
    user_id: str
    text: str
    reason: str
    attempts: int = 0
    created_at: float = time.time()

class TelegramDispatcher:
    def __init__(self) -> None:
        self._queue: Deque[PendingTask] = deque()
        self._seen: Dict[str, float] = {}  # dedupe key -> ts
        self._seen_ttl = 3600  # 1h
        self._lock = asyncio.Lock()
        self._worker_task: Optional[asyncio.Task] = None
        self._stop = False
        self._started = False

    def start(self) -> None:
        if self._started:
            return
        self._started = True
        self._worker_task = asyncio.create_task(self._worker())
        logger.info("telegram_dispatcher: started")

    async def shutdown(self) -> None:
        self._stop = True
        if self._worker_task:
            self._worker_task.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await self._worker_task
        logger.info("telegram_dispatcher: stopped")

    async def queue_summary(self, user_id: str, text: str, *, reason: str) -> bool:
        if not text or not text.strip():
            logger.debug("dispatcher: skip empty text user=%s", user_id)
            return False
        key, h = self._dedupe_key(user_id, text, reason)
        now = time.time()
        # Очистка старых ключей из _seen (ленивая)
        if len(self._seen) > 5000:
            drop = [k for k,v in self._seen.items() if now - v > self._seen_ttl]
            for k in drop:
                self._seen.pop(k, None)
        if key in self._seen:
            logger.info("dispatcher: duplicate suppressed user=%s reason=%s hash=%s", user_id, reason, h)
            return False
        self._seen[key] = now
        task = PendingTask(user_id=user_id, text=text, reason=reason)
        self._queue.append(task)
        if not self._started:
            self.start()
        logger.info("dispatcher: enqueue user=%s reason=%s hash=%s len=%s qsize=%s", user_id, reason, h, len(text), len(self._queue))
        return True

    def _dedupe_key(self, user_id: str, text: str, reason: str):
        h = hashlib.sha256(text.encode('utf-8')).hexdigest()[:16]
        return f"{user_id}:{reason}:{h}", h

    async def _worker(self) -> None:
        settings = get_settings()
        BACKOFF_BASE = 0.75
        while not self._stop:
            try:
                if not self._queue:
                    await asyncio.sleep(0.2)
                    continue
                task = self._queue.popleft()
                sent = False
                chat_id: Optional[str] = None
                # Получаем chat_id напрямую быстрой выборкой
                try:
                    async with get_session() as session:
                        q = select(TelegramLinks.chat_id).where(TelegramLinks.user_id == task.user_id, TelegramLinks.status == 'confirmed', TelegramLinks.chat_id.is_not(None))
                        res = await session.execute(q)
                        chat_id = res.scalar_one_or_none()
                except Exception as e:
                    logger.warning("dispatcher: chat_id fetch error user=%s err=%s", task.user_id, e)
                if not settings.TELEGRAM_BOT_TOKEN:
                    logger.info("dispatcher: skip no_token user=%s reason=%s", task.user_id, task.reason)
                    continue
                if not chat_id:
                    logger.info("dispatcher: skip no_chat_id user=%s reason=%s", task.user_id, task.reason)
                    continue
                # Попытка отправки с ретраями
                try:
                    sent = await low_level_send(task.text, chat_ids=[chat_id])
                except Exception as e:
                    logger.error("dispatcher: low-level exception user=%s err=%s", task.user_id, e)
                    sent = False
                if sent:
                    logger.info("dispatcher: sent user=%s reason=%s attempts=%s qsize=%s", task.user_id, task.reason, task.attempts+1, len(self._queue))
                    continue
                # Если не отправлено — ретрай при временной ошибке
                task.attempts += 1
                if task.attempts < 3:
                    delay = BACKOFF_BASE * (2 ** (task.attempts - 1))
                    logger.info("dispatcher: retry user=%s reason=%s attempt=%s delay=%.2f", task.user_id, task.reason, task.attempts, delay)
                    await asyncio.sleep(delay)
                    self._queue.append(task)
                else:
                    logger.warning("dispatcher: drop user=%s reason=%s attempts=%s", task.user_id, task.reason, task.attempts)
            except asyncio.CancelledError:  # pragma: no cover
                break
            except Exception as e:  # pragma: no cover
                logger.exception("dispatcher: worker loop error: %s", e)
                await asyncio.sleep(1)

_dispatcher_singleton: TelegramDispatcher | None = None

def get_dispatcher() -> TelegramDispatcher:
    global _dispatcher_singleton
    if _dispatcher_singleton is None:
        _dispatcher_singleton = TelegramDispatcher()
    return _dispatcher_singleton

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram_dispatcher.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram_helpers.py =====
--- SIZE: 889 bytes ---

from __future__ import annotations
"""Вспомогательные функции Telegram интеграции."""
from typing import Sequence, Dict
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from ..db.models import TelegramLinks

async def get_active_chat_ids(session: AsyncSession, user_ids: Sequence[str]) -> Dict[str, str]:
    if not user_ids:
        return {}
    q = (
        select(TelegramLinks.user_id, TelegramLinks.chat_id)
        .where(
            TelegramLinks.user_id.in_(list(user_ids)),  # type: ignore[arg-type]
            TelegramLinks.status == 'confirmed',
            TelegramLinks.chat_id.is_not(None)
        )
    )
    res = await session.execute(q)
    out: Dict[str, str] = {}
    for uid, cid in res.all():  # type: ignore[misc]
        if cid:
            out[str(uid)] = cid
    return out

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram_helpers.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram_link.py =====
--- SIZE: 4540 bytes ---

from __future__ import annotations

import secrets
from datetime import datetime, timedelta, timezone
from typing import Optional

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from ..db.models import TelegramLinks

TOKEN_TTL_MINUTES = 10


async def create_or_refresh_link(session: AsyncSession, user_id) -> TelegramLinks:
    """Создаёт новый pending token (инвалидируя предыдущие pending токены пользователя)."""
    # истекают старые pending
    # Модель использует DateTime(timezone=False): сохраняем naive UTC (без tzinfo)
    now = datetime.utcnow()
    token = secrets.token_urlsafe(24)[:64]
    expires_at = now + timedelta(minutes=TOKEN_TTL_MINUTES)
    # Можно просто вставить новую запись (первичный ключ составной user_id+token)
    link = TelegramLinks(
        user_id=user_id,
        token=token,
        chat_id=None,
        status='pending',
        created_at=now,
        confirmed_at=None,
        expires_at=expires_at,
    )
    session.add(link)
    return link


async def confirm_link(session: AsyncSession, token: str, chat_id: str) -> bool:
    # Текущее naive UTC для сопоставления с хранимыми naive датами
    now = datetime.utcnow()
    q = select(TelegramLinks).where(TelegramLinks.token == token)
    res = await session.execute(q)
    link: Optional[TelegramLinks] = res.scalars().first()
    if not link:
        return False
    if link.status != 'pending':
        return False
    expires_at = link.expires_at  # возможно naive UTC; если вдруг приходит aware — нормализуем
    if expires_at is not None and expires_at.tzinfo is not None:
        # Считаем что значение в UTC и отбрасываем tzinfo (модель хранит timezone=False)
        expires_at = expires_at.astimezone(timezone.utc).replace(tzinfo=None)
    if expires_at and expires_at < now:
        # истёк
        link.status = 'expired'
        return False
    # ВАЖНО: если ранее пользователь делал revoke, старая запись со статусом 'revoked' всё ещё содержит chat_id
    # и блокирует уникальный индекс (user_id, chat_id). Очищаем такие записи перед установкой chat_id на pending.
    try:
        await session.execute(
            update(TelegramLinks)
            .where(
                TelegramLinks.user_id == link.user_id,
                TelegramLinks.chat_id == chat_id,
                TelegramLinks.status == 'revoked'
            )
            .values(chat_id=None)
        )
    except Exception:  # pragma: no cover - защита от любых неожиданных ошибок
        pass
    link.chat_id = chat_id
    link.status = 'confirmed'
    link.confirmed_at = now
    return True


async def get_confirmed_chat_id(session: AsyncSession, user_id) -> Optional[str]:
    q = (
        select(TelegramLinks.chat_id)
        .where(TelegramLinks.user_id == user_id, TelegramLinks.status == 'confirmed')
        .order_by(TelegramLinks.confirmed_at.desc())
        .limit(1)
    )
    res = await session.execute(q)
    return res.scalar_one_or_none()


async def revoke_user_links(session: AsyncSession, user_id) -> int:
    """Помечает все confirmed ссылки пользователя как revoked.

    Возвращает количество обновлённых строк. Pending / expired не трогаем.
    """
    now = datetime.utcnow()
    # Чтобы при последующей повторной привязке не получать конфликт уникального индекса (user_id, chat_id)
    # освобождаем chat_id (ставим NULL). UNIQUE допускает несколько NULL в Postgres.
    stmt = (
        update(TelegramLinks)
        .where(TelegramLinks.user_id == user_id, TelegramLinks.status == 'confirmed')
        .values(status='revoked', chat_id=None)
    )
    res = await session.execute(stmt)
    # Возврат количества обновлённых строк (rowcount может быть None у некоторых драйверов)
    return res.rowcount or 0

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\telegram_link.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\voice_transcript.py =====
--- SIZE: 5210 bytes ---

from __future__ import annotations

"""In-memory хранилище голосовых чанков и транскриптов."""

from dataclasses import dataclass
from typing import List, Dict
import io
import httpx
from .ai_provider import OpenAIAIProvider  # type: ignore
from ..config import get_settings
from asyncio import Lock
import time


@dataclass
class VoiceChunk:
    ts: int
    data: bytes


@dataclass
class VoiceTranscript:
    room_id: str
    text: str
    generated_at: int


class VoiceTranscriptCollector:
    def __init__(self) -> None:
        # Ключ: (room_id,user_id) если user_id известен; иначе room_id как fallback (legacy). Пользовательский скоп обязателен для корректной персональной сегрегации.
        self._chunks: Dict[str, list[VoiceChunk]] = {}
        self._transcripts: Dict[str, VoiceTranscript] = {}
        self._lock = Lock()
        # TTL (мс) для готовых транскриптов и сырых чанков (если вдруг не финализировали) — предотвращает накопление старых данных.
        self._transcript_ttl_ms = 5 * 60 * 1000  # 5 минут
        self._chunk_ttl_ms = 5 * 60 * 1000

    def _purge_expired_unlocked(self, now_ms: int) -> None:
        # Очистка транскриптов
        to_del = [k for k, v in self._transcripts.items() if (now_ms - v.generated_at) > self._transcript_ttl_ms]
        for k in to_del:
            self._transcripts.pop(k, None)
        # Очистка сырых чанков (по таймстемпу первого чанка)
        stale_chunks = []
        for k, lst in self._chunks.items():
            if lst and (now_ms - lst[0].ts) > self._chunk_ttl_ms:
                stale_chunks.append(k)
        for k in stale_chunks:
            self._chunks.pop(k, None)

    async def add_chunk(self, room_key: str, data: bytes) -> None:
        async with self._lock:
            now_ms = int(time.time()*1000)
            self._purge_expired_unlocked(now_ms)
            self._chunks.setdefault(room_key, []).append(VoiceChunk(ts=now_ms, data=data))

    async def get_and_clear_chunks(self, room_key: str) -> list[VoiceChunk]:
        async with self._lock:
            now_ms = int(time.time()*1000)
            self._purge_expired_unlocked(now_ms)
            chunks = self._chunks.pop(room_key, [])
            return chunks

    async def store_transcript(self, room_key: str, text: str) -> VoiceTranscript:
        vt = VoiceTranscript(room_id=room_key, text=text, generated_at=int(time.time()*1000))
        async with self._lock:
            now_ms = vt.generated_at
            self._purge_expired_unlocked(now_ms)
            self._transcripts[room_key] = vt
        return vt

    async def pop_transcript(self, room_key: str) -> VoiceTranscript | None:
        async with self._lock:
            now_ms = int(time.time()*1000)
            self._purge_expired_unlocked(now_ms)
            return self._transcripts.pop(room_key, None)

    async def get_transcript(self, room_key: str) -> VoiceTranscript | None:
        """Вернёт транскрипт без удаления (для повторной проверки готовности)."""
        async with self._lock:
            now_ms = int(time.time()*1000)
            self._purge_expired_unlocked(now_ms)
            return self._transcripts.get(room_key)


_voice_collector_singleton: VoiceTranscriptCollector | None = None


def get_voice_collector() -> VoiceTranscriptCollector:
    global _voice_collector_singleton
    if _voice_collector_singleton is None:
        _voice_collector_singleton = VoiceTranscriptCollector()
    return _voice_collector_singleton


async def transcribe_chunks(room_id: str, chunks: list[VoiceChunk]) -> str:
    """Отправить собранные webm opus чанки в OpenAI Whisper и вернуть текст.

    MVP: склеиваем в один webm. Если нет ключа или выключено — возвращаем placeholder.
    """
    settings = get_settings()
    if not settings.OPENAI_API_KEY:
        return "(asr disabled: no OPENAI_API_KEY)"
    # Склейка
    bio = io.BytesIO()
    for ch in chunks:
        bio.write(ch.data)
    bio.seek(0)
    files = {
        'file': ('audio.webm', bio.read(), 'audio/webm'),
    }
    data = {
        'model': settings.VOICE_ASR_MODEL or 'whisper-1',
        'response_format': 'text'
    }
    headers = { 'Authorization': f'Bearer {settings.OPENAI_API_KEY}' }
    url = 'https://api.openai.com/v1/audio/transcriptions'
    try:
        async with httpx.AsyncClient(timeout=120.0) as client:
            r = await client.post(url, data=data, files=files, headers=headers)
            if r.status_code == 200:
                return r.text.strip()
            return f"(asr failed http {r.status_code})"
    except Exception as e:  # pragma: no cover
        return f"(asr exception {e.__class__.__name__})"

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\voice_transcript.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\webpush.py =====
--- SIZE: 1797 bytes ---

from __future__ import annotations

import json
from dataclasses import dataclass
from typing import Iterable

import anyio
try:
    from pywebpush import webpush, WebPushException  # type: ignore
except Exception:  # pragma: no cover
    webpush = None  # type: ignore
    WebPushException = Exception  # type: ignore


@dataclass
class WebPushMessage:
    title: str
    body: str
    icon: str | None = None
    data: dict | None = None

    def json(self) -> str:
        return json.dumps({
            "title": self.title,
            "body": self.body,
            "icon": self.icon,
            "data": self.data or {},
        })


class WebPushSender:
    """Lightweight placeholder for sending Web Push notifications.

    In a real deployment, you'd use a library like pywebpush to send HTTP requests to endpoints
    with VAPID keys. Here we leave the network IO to the outer layer to keep dependencies minimal.
    """

    def __init__(self, vapid_public: str | None = None, vapid_private: str | None = None, subject: str | None = None) -> None:
        self.vapid_public = vapid_public
        self.vapid_private = vapid_private
        self.subject = subject or "mailto:admin@example.com"

    async def send(self, endpoint: str, p256dh: str, auth: str, message: WebPushMessage) -> None:
        if not webpush or not self.vapid_private:
            return  # silently skip if not configured
        sub = {"endpoint": endpoint, "keys": {"p256dh": p256dh, "auth": auth}}
        payload = message.json()
        claims = {"sub": self.subject}
        def _do():
            return webpush(subscription_info=sub, data=payload, vapid_private_key=self.vapid_private, vapid_claims=claims)
        await anyio.to_thread.run_sync(_do)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\infrastructure\services\webpush.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\auth.py =====
--- SIZE: 1192 bytes ---

from __future__ import annotations

from typing import Annotated
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer

from ....core.errors import NotFoundError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import TokenProvider
from .containers import get_user_repo, get_token_provider


bearer_scheme = HTTPBearer(auto_error=False)


async def get_current_user(
    credentials: Annotated[HTTPAuthorizationCredentials | None, Depends(bearer_scheme)],
    users: UserRepository = Depends(get_user_repo),
    tokens: TokenProvider = Depends(get_token_provider),
):
    if not credentials:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    try:
        payload = tokens.decode_token(credentials.credentials)
        sub = payload.get("sub")
        user = await users.get_by_id(UUID(sub))
        if not user:
            raise NotFoundError()
        return user
    except Exception:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\auth.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\containers.py =====
--- SIZE: 4611 bytes ---

from __future__ import annotations

from fastapi import Depends
from typing import AsyncIterator
from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session
from ....infrastructure.db.session import get_session as _get_session
from ....infrastructure.db.repositories.users import PgUserRepository
from ....infrastructure.db.repositories.rooms import PgRoomRepository
from ....infrastructure.db.repositories.participants import PgParticipantRepository
from ....infrastructure.db.repositories.messages import PgMessageRepository
from ....infrastructure.db.repositories.friends import PgFriendshipRepository
from ....infrastructure.db.repositories.push_subs import PgPushSubscriptionRepository
from ....infrastructure.db.repositories.direct_messages import PgDirectMessageRepository
from ....infrastructure.security.password_hasher import BcryptPasswordHasher
from ....infrastructure.security.jwt_provider import JoseTokenProvider
from ....infrastructure.ice.provider import EnvIceConfigProvider
from ....infrastructure.services.call_invites import InMemoryCallInviteService
from ....infrastructure.services.call_invites_redis import RedisCallInviteService
from ....infrastructure.services.push_notifier import SimplePushNotifier
from ....core.ports.services import CallInviteService, PushNotifier
from ....infrastructure.config import get_settings
from redis.asyncio import from_url as redis_from_url


# DB session provider (request-scoped)
async def get_db_session() -> AsyncIterator[AsyncSession]:
    async with _get_session() as s:  # type: ignore[misc]
        yield s
from ....infrastructure.messaging.redis_bus import RedisSignalBus
from ....infrastructure.messaging.inmemory_bus import InMemorySignalBus
from ....infrastructure.config import get_settings
from functools import lru_cache


# Repositories
async def get_user_repo(session: AsyncSession = Depends(get_db_session)):
    return PgUserRepository(session)


async def get_room_repo(session: AsyncSession = Depends(get_db_session)):
    return PgRoomRepository(session)


async def get_participant_repo(session: AsyncSession = Depends(get_db_session)):
    return PgParticipantRepository(session)


async def get_message_repo(session: AsyncSession = Depends(get_db_session)):
    return PgMessageRepository(session)


async def get_friendship_repo(session: AsyncSession = Depends(get_db_session)):
    return PgFriendshipRepository(session)


async def get_push_subscription_repo(session: AsyncSession = Depends(get_db_session)):
    return PgPushSubscriptionRepository(session)


async def get_direct_message_repo(session: AsyncSession = Depends(get_db_session)):
    return PgDirectMessageRepository(session)


# Services
def get_password_hasher():
    return BcryptPasswordHasher()


def get_token_provider():
    return JoseTokenProvider()


def get_signal_bus():
    # Singleton SignalBus per process to ensure all WS share the same bus
    return _get_signal_bus_singleton()


@lru_cache(maxsize=1)
def _get_signal_bus_singleton():
    s = get_settings()
    # Use in-memory bus by default for local/dev/testing; switch to Redis via env
    if s.APP_ENV in {"dev", "test"}:
        return InMemorySignalBus()
    return RedisSignalBus()


def get_ice_provider():
    return EnvIceConfigProvider()


# Call / Push services (process-wide singletons where appropriate)
_call_invite_service: CallInviteService | None = None
_push_notifier_singleton: PushNotifier | None = None


def get_call_invite_service() -> CallInviteService:
    global _call_invite_service
    if _call_invite_service is None:
        settings = get_settings()
        if settings.CALL_INVITES_BACKEND.lower() == 'redis':
            try:
                redis_client = redis_from_url(settings.REDIS_URL, decode_responses=True)
                _call_invite_service = RedisCallInviteService(redis_client)
            except Exception:  # pragma: no cover - fallback
                _call_invite_service = InMemoryCallInviteService()
        else:
            _call_invite_service = InMemoryCallInviteService()
    return _call_invite_service


async def get_push_notifier(
    subs_repo = Depends(get_push_subscription_repo),  # type: ignore
    user_repo = Depends(get_user_repo),  # type: ignore
):  # -> PushNotifier
    global _push_notifier_singleton
    if _push_notifier_singleton is None:
        _push_notifier_singleton = SimplePushNotifier(subs_repo, user_repo)
    return _push_notifier_singleton

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\containers.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\db.py =====
--- SIZE: 309 bytes ---

from __future__ import annotations

from typing import AsyncIterator

from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.db.session import get_session


async def get_db_session() -> AsyncIterator[AsyncSession]:
    async with get_session() as session:
        yield session

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\db.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\rate_limit.py =====
--- SIZE: 1295 bytes ---

from __future__ import annotations

import time
from collections import deque
from typing import Deque

from fastapi import HTTPException, status


class _SlidingWindowLimiter:
    def __init__(self, max_events: int, window_seconds: float) -> None:
        self.max_events = max_events
        self.window = window_seconds
        self.events: Deque[float] = deque()

    def hit(self) -> None:
        now = time.monotonic()
        # очистка старых
        cutoff = now - self.window
        while self.events and self.events[0] < cutoff:
            self.events.popleft()
        if len(self.events) >= self.max_events:
            # превышено
            raise HTTPException(status_code=status.HTTP_429_TOO_MANY_REQUESTS, detail="Too many requests, slow down")
        self.events.append(now)


_login_limiter = _SlidingWindowLimiter(max_events=8, window_seconds=60.0)
_register_limiter = _SlidingWindowLimiter(max_events=5, window_seconds=300.0)
_room_create_limiter = _SlidingWindowLimiter(max_events=30, window_seconds=300.0)


def limit_login():  # dependency
    _login_limiter.hit()


def limit_register():  # dependency
    _register_limiter.hit()


def limit_room_create():  # dependency
    _room_create_limiter.hit()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\deps\rate_limit.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\__init__.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\__init__.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\ai_prompt.py =====
--- SIZE: 3694 bytes ---

from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel, Field
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from ....infrastructure.db.session import get_db_session
from ....infrastructure.config import get_settings
from ..deps.auth import get_current_user
from ....infrastructure.db.models import Users

settings = get_settings()
api_prefix = settings.API_PREFIX.rstrip('/')
router = APIRouter(prefix=f"{api_prefix}/ai", tags=["ai"])

DEFAULT_PROMPT = (
    "Ты ассистент, делающий краткую структурированную выжимку группового чата:"\
    " 1) Основные темы 2) Принятые решения 3) Открытые вопросы."\
    " Пиши лаконично на русском, без лишних вступлений."
)

class PromptOut(BaseModel):
    prompt: str  # То, что вернём в textarea (если default => сам дефолт)
    is_default: bool
    default_prompt: str
    effective_prompt: str  # Итоговый prompt, который реально пойдёт в AI (равен prompt)

class PromptIn(BaseModel):
    # Разрешаем пустую строку (означает сброс). Минимальную длину убираем, чтобы пользователь мог хранить очень короткий prompt.
    prompt: str = Field(min_length=0, max_length=4000, description="Пользовательский системный prompt. Пустая строка -> сброс к стандартному.")

@router.get('/prompt', response_model=PromptOut)
async def get_prompt(session: AsyncSession = Depends(get_db_session), current_user=Depends(get_current_user)):
    q = select(Users.ai_system_prompt).where(Users.id == current_user.id)
    res = await session.execute(q)
    val = res.scalar_one_or_none()
    if val and val.strip():
        return PromptOut(prompt=val, is_default=False, default_prompt=DEFAULT_PROMPT, effective_prompt=val)
    return PromptOut(prompt=DEFAULT_PROMPT, is_default=True, default_prompt=DEFAULT_PROMPT, effective_prompt=DEFAULT_PROMPT)

@router.put('/prompt', response_model=PromptOut)
async def set_prompt(data: PromptIn, session: AsyncSession = Depends(get_db_session), current_user=Depends(get_current_user)):
    text = (data.prompt or '').strip()
    # Пустая строка или точное совпадение с дефолтом => сброс
    if not text or text == DEFAULT_PROMPT:
        stmt = update(Users).where(Users.id == current_user.id).values(ai_system_prompt=None)
        await session.execute(stmt)
        await session.commit()
        return PromptOut(prompt=DEFAULT_PROMPT, is_default=True, default_prompt=DEFAULT_PROMPT, effective_prompt=DEFAULT_PROMPT)

    # Иначе сохраняем кастом
    stmt = update(Users).where(Users.id == current_user.id).values(ai_system_prompt=text)
    await session.execute(stmt)
    await session.commit()
    return PromptOut(prompt=text, is_default=False, default_prompt=DEFAULT_PROMPT, effective_prompt=text)

@router.delete('/prompt', response_model=PromptOut)
async def reset_prompt(session: AsyncSession = Depends(get_db_session), current_user=Depends(get_current_user)):
    stmt = update(Users).where(Users.id == current_user.id).values(ai_system_prompt=None)
    await session.execute(stmt)
    await session.commit()
    return PromptOut(prompt=DEFAULT_PROMPT, is_default=True, default_prompt=DEFAULT_PROMPT, effective_prompt=DEFAULT_PROMPT)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\ai_prompt.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\auth.py =====
--- SIZE: 5291 bytes ---

from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, status
import hmac

from ....application.dto.auth import LoginInput, RegisterInput, RegisterOutput, TokenOutput, UpdateProfileInput, ChangePasswordInput
from ..deps.rate_limit import limit_login, limit_register
from ....core.domain.models import User
from ....core.errors import ConflictError
from ....core.ports.repositories import UserRepository
from ....core.ports.services import PasswordHasher, TokenProvider
from ..deps.containers import get_password_hasher, get_token_provider, get_user_repo

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])


@router.post("/register", response_model=RegisterOutput, status_code=status.HTTP_201_CREATED)
async def register(
    data: RegisterInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
    _: None = Depends(limit_register),
) -> RegisterOutput:  # type: ignore[override]
    from ....application.use_cases.auth import RegisterUser
    from ....infrastructure.config import get_settings

    settings = get_settings()
    provided = data.secret
    if not hmac.compare_digest(provided.encode(), settings.REGISTRATION_SECRET.encode()):
        # Keep the word 'secret' in the message because tests assert it appears,
        # but make the message clearer for users.
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Неверный секретный код (secret)")

    use = RegisterUser(users, hasher)
    user = await use.execute(email=data.email, username=data.username, password=data.password)
    # user.username является value object (dataclass Username). Преобразуем к str для валидации Pydantic.
    return RegisterOutput(id=str(user.id), email=str(user.email), username=str(user.username))


@router.post("/login", response_model=TokenOutput)
async def login(
    data: LoginInput,
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
    tokens: TokenProvider = Depends(get_token_provider),
    _: None = Depends(limit_login),
) -> TokenOutput:  # type: ignore[override]
    from ....application.use_cases.auth import LoginUser

    use = LoginUser(users, hasher, tokens)
    access = await use.execute(email=data.email, password=data.password)
    return TokenOutput(access_token=access)

    # Дополнительный endpoint: текущий пользователь
from pydantic import BaseModel
from ..deps.auth import get_current_user

class MeOut(BaseModel):
    id: str
    email: str
    username: str

@router.get("/me", response_model=MeOut)
async def get_me(current=Depends(get_current_user)) -> MeOut:  # type: ignore[override]
    return MeOut(id=str(current.id), email=str(current.email), username=str(current.username))


@router.patch("/me", response_model=MeOut)
async def update_me(
    data: UpdateProfileInput,
    current=Depends(get_current_user),
    users: UserRepository = Depends(get_user_repo),
) -> MeOut:  # type: ignore[override]
    if data.email is None and data.username is None:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Нужно указать email и/или username")
    try:
        updated = await users.update_profile(current.id, email=str(data.email) if data.email else None, username=data.username)
    except ConflictError:
        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail="Email или username уже заняты")
    if not updated:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    return MeOut(id=str(updated.id), email=str(updated.email), username=str(updated.username))


@router.post("/me/password", status_code=status.HTTP_200_OK)
async def change_password(
    data: ChangePasswordInput,
    current=Depends(get_current_user),
    users: UserRepository = Depends(get_user_repo),
    hasher: PasswordHasher = Depends(get_password_hasher),
):  # type: ignore[override]
    """Смена пароля текущего пользователя.

    Заменили 204 → 200, потому что текущая версия FastAPI жёстко валидирует
    отсутствие потенциального тела для 204 и выбрасывает AssertionError при
    комбинации декоратора. Возвращаем простой JSON для явного подтверждения.
    Если критично иметь 204, можно убрать status_code в декораторе и возвращать
    Response(status_code=204), но тогда OpenAPI покажет 200.
    """
    if not hasher.verify(data.old_password, str(current.password_hash)):
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Старый пароль неверен")
    new_hash = hasher.hash(data.new_password)
    ok = await users.update_password(current.id, new_hash)
    if not ok:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found")
    return {"status":"ok"}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\auth.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\direct.py =====
--- SIZE: 13927 bytes ---

from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from pydantic import BaseModel

from ....core.domain.models import DirectMessage, FriendStatus
from ....core.ports.repositories import FriendshipRepository, DirectMessageRepository, UserRepository, DirectReadStateRepository, PushSubscriptionRepository
from ..deps.auth import get_current_user
from ..deps.containers import get_db_session
from ....infrastructure.db.repositories.friends import PgFriendshipRepository
from ....infrastructure.db.repositories.direct_messages import PgDirectMessageRepository
from ....infrastructure.db.repositories.direct_reads import PgDirectReadStateRepository
from ....infrastructure.db.repositories.push_subs import PgPushSubscriptionRepository
from ....infrastructure.db.repositories.users import PgUserRepository
from ..deps.containers import get_user_repo
from ....infrastructure.db.session import get_session
from ....infrastructure.services.webpush import WebPushSender, WebPushMessage
from ....infrastructure.config import get_settings
from ...ws.friends import publish_direct_message, publish_direct_cleared
from ....infrastructure.db.repositories.users import PgUserRepository
from ....infrastructure.services.direct_crypto import decrypt_direct, encrypt_direct
from sqlalchemy import select, and_, func
from ....infrastructure.db import models as m

router = APIRouter(prefix='/api/v1/direct', tags=['direct'])


class DirectMessageIn(BaseModel):
    content: str


class DirectMessageOut(BaseModel):
    id: UUID
    from_user_id: UUID
    to_user_id: UUID
    content: str
    sent_at: str


async def get_friend_repo(session=Depends(get_db_session)) -> FriendshipRepository:
    return PgFriendshipRepository(session)


async def get_dm_repo(session=Depends(get_db_session)) -> DirectMessageRepository:
    return PgDirectMessageRepository(session)


async def get_read_repo(session=Depends(get_db_session)) -> DirectReadStateRepository:
    return PgDirectReadStateRepository(session)


class PublicKeyIn(BaseModel):
    public_key: str


@router.post('/me/public_key')
async def set_my_public_key(body: PublicKeyIn, current=Depends(get_current_user), users: PgUserRepository = Depends(get_user_repo)):
    await users.set_public_key(current.id, body.public_key)
    return {"ok": True}


@router.get('/{friend_id}/public_key')
async def get_friend_public_key(friend_id: UUID, users: PgUserRepository = Depends(get_user_repo)):
    u = await users.get_by_id(friend_id)
    if not u:
        raise HTTPException(status_code=404, detail='Not found')
    return {"public_key": u.public_key}


@router.get('/{friend_id}/messages', response_model=List[DirectMessageOut])
async def list_direct_messages(friend_id: UUID, current=Depends(get_current_user), frepo: FriendshipRepository = Depends(get_friend_repo), dms: DirectMessageRepository = Depends(get_dm_repo)):
    f = await frepo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.accepted:
        raise HTTPException(status_code=404, detail='Not friends')
    rows = await dms.list_pair(current.id, friend_id, limit=100)
    # Возвращаем в прямом порядке по времени (старые -> новые)
    rows = list(reversed(rows))
    result: list[DirectMessageOut] = []
    # Возвращаем уже расшифрованный plaintext — клиенту не нужно E2EE для DM (упрощённый подход)
    for dm in rows:
        to_user = friend_id if dm.sender_id == current.id else current.id
        # Попробуем расшифровать на сервере для участника переписки.
        # Расшифровка выполняется только когда текущий пользователь является участником пары (т.е. он здесь),
        # и ключ выводим по паре id — поэтому обе стороны смогут получить plaintext.
        content = dm.ciphertext
        try:
            # decrypt_direct ожидает a, b как UUID (порядок внутри функции нормализуется)
            content = decrypt_direct(dm.user_a_id, dm.user_b_id, dm.ciphertext)
        except Exception:
            # Если расшифровка не удалась (повреждённый ciphertext или ключи не совпадают),
            # возвращаем оригинальный ciphertext — клиент попытается расшифровать локально.
            content = dm.ciphertext
        result.append(DirectMessageOut(id=dm.id, from_user_id=dm.sender_id, to_user_id=to_user, content=content, sent_at=dm.sent_at.isoformat()))
    return result


class ReadAckIn(BaseModel):
    at: str | None = None  # ISO8601; если не задано — использовать текущее время на сервере


@router.post('/{friend_id}/read-ack')
async def mark_direct_read(friend_id: UUID, body: ReadAckIn | None = None, current=Depends(get_current_user), frepo: FriendshipRepository = Depends(get_friend_repo), reads: DirectReadStateRepository = Depends(get_read_repo)):
    f = await frepo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.accepted:
        raise HTTPException(status_code=404, detail='Not friends')
    from datetime import datetime
    when = None
    try:
        if body and body.at:
            when = datetime.fromisoformat(body.at)
    except Exception:
        when = None
    if when is None:
        when = datetime.utcnow()
    await reads.set_last_read(current.id, friend_id, when)
    return {"ok": True}


@router.post('/{friend_id}/messages', response_model=DirectMessageOut, status_code=201)
async def post_direct_message(friend_id: UUID, body: DirectMessageIn, background: BackgroundTasks, current=Depends(get_current_user), frepo: FriendshipRepository = Depends(get_friend_repo), dms: DirectMessageRepository = Depends(get_dm_repo), reads: DirectReadStateRepository = Depends(get_read_repo), push_repo: PushSubscriptionRepository = Depends(lambda session=Depends(get_db_session): PgPushSubscriptionRepository(session)), users: UserRepository = Depends(get_current_user.__wrapped__ if hasattr(get_current_user, '__wrapped__') else get_current_user)):
    f = await frepo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.accepted:
        raise HTTPException(status_code=404, detail='Not friends')
    content = body.content.strip()
    if not content:
        raise HTTPException(status_code=400, detail='Empty content')
    # Новый подход: клиент присылает plaintext, сервер шифрует и хранит ciphertext
    ciphertext = encrypt_direct(current.id, friend_id, content)
    dm = DirectMessage.create(current.id, friend_id, current.id, ciphertext)
    await dms.add(dm)
    # Публикация события обеим сторонам (ciphertext)
    try:
        # Рассылаем plaintext, чтобы клиент сразу показал читаемый текст
        await publish_direct_message(current.id, friend_id, dm.id, content, dm.sent_at)
    except Exception:
        pass
    # Определяем порядковый номер сообщения в паре (после сохранения)
    msg_index: int | None = None
    try:
        # Подсчёт количества сообщений в паре (включая текущее)
        a_s, b_s = str(current.id), str(friend_id)
        if a_s <= b_s:
            ua, ub = current.id, friend_id
        else:
            ua, ub = friend_id, current.id
        stmt_cnt = select(func.count()).select_from(m.DirectMessages).where(and_(m.DirectMessages.user_a_id == ua, m.DirectMessages.user_b_id == ub))
        res_cnt = await dms.session.execute(stmt_cnt)  # type: ignore[attr-defined]
        msg_index = int(res_cnt.scalar_one() or 0)
    except Exception:
        msg_index = None

    # Мгновенное пуш-уведомление получателю только на каждое 10-е сообщение
    async def _instant_push(sender_id: UUID, to_id: UUID, ciphertext: str, ordinal: int | None):
        settings = get_settings()
        if not (settings.VAPID_PUBLIC_KEY and settings.VAPID_PRIVATE_KEY and settings.VAPID_SUBJECT):
            return
        if ordinal is not None and ordinal % 10 != 0:
            return
        async with get_session() as session:
            push_repo_local = PgPushSubscriptionRepository(session)
            user_repo_local = PgUserRepository(session)
            subs = await push_repo_local.list_by_user(to_id)
            if not subs:
                return
            sender_user = await user_repo_local.get_by_id(sender_id)
            sender_name = sender_user.username if sender_user else "пользователь"
            push_sender = WebPushSender(
                vapid_public=settings.VAPID_PUBLIC_KEY,
                vapid_private=settings.VAPID_PRIVATE_KEY,
                subject=settings.VAPID_SUBJECT,
            )
            title = "Новое сообщение"
            body_text = f"Вам новое сообщение"  # avoid including plaintext in push
            for s in subs:
                try:
                    await push_sender.send(
                        s.endpoint,
                        s.p256dh,
                        s.auth,
                        WebPushMessage(title=title, body=body_text, data={"type": "direct", "from": str(sender_id)}),
                    )
                except Exception:
                    pass
    background.add_task(_instant_push, current.id, friend_id, ciphertext, msg_index)
    # Планируем отложенное пуш-уведомление через 10 минут, если получатель не прочитал.
    # Тоже только для кратности 10.
    async def _delayed_push_if_unread(sender_id: UUID, to_id: UUID, sent_at_iso: str, ordinal: int | None):
        # Ждём 10 минут, затем проверяем, прочитано ли сообщение (по last_read)
        import asyncio
        from datetime import datetime
        await asyncio.sleep(600)
        # Настройки push
        settings = get_settings()
        if not (settings.VAPID_PUBLIC_KEY and settings.VAPID_PRIVATE_KEY and settings.VAPID_SUBJECT):
            return
        if ordinal is not None and ordinal % 10 != 0:
            return
        # Парсим время отправки сообщения
        try:
            sent_at = datetime.fromisoformat(sent_at_iso)
        except Exception:
            return
        # Открываем новую БД-сессию и переиспользуем репозитории
        async with get_session() as session:
            reads_repo = PgDirectReadStateRepository(session)
            push_repo_local = PgPushSubscriptionRepository(session)
            user_repo_local = PgUserRepository(session)
            try:
                last_read = await reads_repo.get_last_read(to_id, sender_id)
            except Exception:
                last_read = None
            # Если прочитано (last_read >= sent_at) — пуш не нужен
            if last_read is not None and last_read >= sent_at:
                return
            # Готовим данные уведомления
            sender_user = await user_repo_local.get_by_id(sender_id)
            sender_name = sender_user.username if sender_user else "пользователь"
            subs = await push_repo_local.list_by_user(to_id)
            if not subs:
                return
            push_sender = WebPushSender(
                vapid_public=settings.VAPID_PUBLIC_KEY,
                vapid_private=settings.VAPID_PRIVATE_KEY,
                subject=settings.VAPID_SUBJECT,
            )
            title = "Новое сообщение"
            body_text = f"Вам новое сообщение"  # do not include message body
            for s in subs:
                try:
                    await push_sender.send(
                        s.endpoint,
                        s.p256dh,
                        s.auth,
                        WebPushMessage(title=title, body=body_text, data={"type": "direct", "from": str(sender_id)}),
                    )
                except Exception:
                    # игнорируем ошибки доставки
                    pass

    background.add_task(_delayed_push_if_unread, current.id, friend_id, dm.sent_at.isoformat(), msg_index)
    return DirectMessageOut(id=dm.id, from_user_id=current.id, to_user_id=friend_id, content=content, sent_at=dm.sent_at.isoformat())


class DirectDeleteResult(BaseModel):
    removed: int


@router.delete('/{friend_id}/messages', response_model=DirectDeleteResult)
async def delete_direct_messages(friend_id: UUID, current=Depends(get_current_user), frepo: FriendshipRepository = Depends(get_friend_repo), dms: DirectMessageRepository = Depends(get_dm_repo)):
    f = await frepo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.accepted:
        raise HTTPException(status_code=404, detail='Not friends')
    removed = await dms.delete_pair(current.id, friend_id)
    try:
        await publish_direct_cleared(current.id, friend_id)
    except Exception:
        pass
    return DirectDeleteResult(removed=removed)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\direct.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\friends.py =====
--- SIZE: 7430 bytes ---

from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status

from ....core.domain.models import Friendship, FriendStatus
from ....core.errors import ConflictError
from ....core.ports.repositories import FriendshipRepository, UserRepository, DirectMessageRepository, DirectReadStateRepository
from ..deps.auth import get_current_user
from ..deps.containers import get_user_repo, get_db_session
from ....infrastructure.db.repositories.direct_messages import PgDirectMessageRepository
from ....infrastructure.db.repositories.direct_reads import PgDirectReadStateRepository
from ....infrastructure.db.repositories.friends import PgFriendshipRepository
from pydantic import BaseModel
from ...ws.friends import (
    publish_friend_request,
    publish_friend_accepted,
    publish_friend_cancelled,
    publish_friend_removed,
)


router = APIRouter(prefix="/api/v1/friends", tags=["friends"])


class FriendRequestIn(BaseModel):
    user_id: UUID


class FriendshipOut(BaseModel):
    id: UUID
    user_id: UUID
    status: FriendStatus
    requested_by: UUID
    username: str | None = None
    email: str | None = None
    unread: int = 0


def _other_side(f: Friendship, me: UUID) -> UUID:
    return f.user_b_id if f.user_a_id == me else f.user_a_id


async def get_friend_repo(session=Depends(get_db_session)) -> FriendshipRepository:
    return PgFriendshipRepository(session)


@router.get("/", response_model=List[FriendshipOut])
async def list_friends(
    current=Depends(get_current_user),
    repo: FriendshipRepository = Depends(get_friend_repo),
    users: UserRepository = Depends(get_user_repo),
    dms: DirectMessageRepository = Depends(lambda session=Depends(get_db_session): PgDirectMessageRepository(session)),
    reads: DirectReadStateRepository = Depends(lambda session=Depends(get_db_session): PgDirectReadStateRepository(session)),
):
    items = await repo.list_friends(current.id, status=FriendStatus.accepted)
    result: list[FriendshipOut] = []
    for f in items:
        other_id = _other_side(f, current.id)
        u = await users.get_by_id(other_id)
        last_read = await reads.get_last_read(current.id, other_id)
        unread = await dms.count_unread(current.id, other_id, last_read)
        result.append(
            FriendshipOut(
                id=f.id,
                user_id=other_id,
                status=f.status,
                requested_by=f.requested_by,
                # u.username это value object Username -> явно приводим к str
                username=(str(u.username) if u and u.username is not None else None),
                email=(str(u.email) if u else None),
                unread=unread,
            )
        )
    return result


@router.get("/requests", response_model=List[FriendshipOut])
async def list_requests(
    current=Depends(get_current_user),
    repo: FriendshipRepository = Depends(get_friend_repo),
    users: UserRepository = Depends(get_user_repo),
):
    items = await repo.list_requests(current.id)
    result: list[FriendshipOut] = []
    for f in items:
        other_id = _other_side(f, current.id)
        u = await users.get_by_id(other_id)
        result.append(
            FriendshipOut(
                id=f.id,
                user_id=other_id,
                status=f.status,
                requested_by=f.requested_by,
                # Явное приведение value object Username к str
                username=(str(u.username) if u and u.username is not None else None),
                email=(str(u.email) if u else None),
            )
        )
    return result


@router.post("/request", status_code=201)
async def send_request(body: FriendRequestIn, current=Depends(get_current_user), repo: FriendshipRepository = Depends(get_friend_repo)):
    if body.user_id == current.id:
        raise HTTPException(status_code=400, detail="Cannot add yourself")
    existing = await repo.get_pair(current.id, body.user_id)
    if existing:
        if existing.status == FriendStatus.accepted:
            raise HTTPException(status_code=409, detail="Already friends")
        # If pending and counterpart sent earlier, accept
        if existing.status == FriendStatus.pending and existing.requested_by != current.id:
            existing.status = FriendStatus.accepted
            existing.requested_by = current.id
            existing.updated_at = existing.updated_at
            await repo.update(existing)
            # publish accept for both sides
            try:
                await publish_friend_accepted(existing.user_a_id, existing.user_b_id, None, None)
            except Exception:
                pass
            return {"ok": True, "accepted": True}
        raise HTTPException(status_code=409, detail="Request already exists")
    f = Friendship.pair(current.id, body.user_id, requested_by=current.id)
    await repo.add(f)
    # publish request to target user
    try:
        await publish_friend_request(current.id, body.user_id, None)
    except Exception:
        pass
    return {"ok": True}


@router.post("/{friend_id}/accept")
async def accept_friend(friend_id: UUID, current=Depends(get_current_user), repo: FriendshipRepository = Depends(get_friend_repo)):
    f = await repo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.pending or f.requested_by == current.id:
        raise HTTPException(status_code=404, detail="No incoming request")
    f.status = FriendStatus.accepted
    f.requested_by = current.id
    f.updated_at = f.updated_at
    await repo.update(f)
    try:
        await publish_friend_accepted(f.user_a_id, f.user_b_id, None, None)
    except Exception:
        pass
    return {"ok": True}


@router.post("/{friend_id}/cancel")
async def cancel_request(friend_id: UUID, current=Depends(get_current_user), repo: FriendshipRepository = Depends(get_friend_repo)):
    f = await repo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.pending or f.requested_by != current.id:
        raise HTTPException(status_code=404, detail="No outgoing request")
    # simple delete via update to blocked then ignore — but better to delete; for simplicity we mark blocked
    f.status = FriendStatus.blocked
    f.updated_at = f.updated_at
    await repo.update(f)
    try:
        await publish_friend_cancelled(current.id, friend_id)
    except Exception:
        pass
    return {"ok": True}


@router.delete("/{friend_id}")
async def delete_friend(friend_id: UUID, current=Depends(get_current_user), repo: FriendshipRepository = Depends(get_friend_repo)):
    """Удалить дружбу (обоюдно). Если дружбы нет — 404.

    Возвращает {ok:true}. Паблишит WS событие friend_removed обеим сторонам.
    """
    f = await repo.get_pair(current.id, friend_id)
    if not f or f.status != FriendStatus.accepted:
        raise HTTPException(status_code=404, detail="Friendship not found")
    # Удаляем
    await repo.remove(current.id, friend_id)
    try:
        await publish_friend_removed(current.id, friend_id)
    except Exception:
        pass
    return {"ok": True}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\friends.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\messages.py =====
--- SIZE: 1391 bytes ---

from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.messages import MessageDTO, PostMessageInput
from ....application.use_cases.messages import ListMessages, PostMessage
from ....core.ports.repositories import MessageRepository
from ..deps.containers import get_message_repo

router = APIRouter(prefix="/api/v1/rooms/{room_id}/messages", tags=["messages"])


@router.post("", response_model=MessageDTO)
async def post_message(room_id: str, data: PostMessageInput, messages: MessageRepository = Depends(get_message_repo)) -> MessageDTO:  # type: ignore[override]
    use = PostMessage(messages)
    msg = await use.execute(room_id=UUID(room_id), author_id=UUID(data.author_id), content=data.content)
    return MessageDTO(id=str(msg.id), room_id=str(msg.room_id), author_id=str(msg.author_id), content=msg.content, sent_at=msg.sent_at)


@router.get("", response_model=list[MessageDTO])
async def list_messages(room_id: str, skip: int = 0, limit: int = 50, messages: MessageRepository = Depends(get_message_repo)):  # type: ignore[override]
    use = ListMessages(messages)
    items = await use.execute(room_id=UUID(room_id), skip=skip, limit=limit)
    return [MessageDTO(id=str(m.id), room_id=str(m.room_id), author_id=str(m.author_id), content=m.content, sent_at=m.sent_at) for m in items]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\messages.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\participants.py =====
--- SIZE: 2188 bytes ---

from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException

from ....application.use_cases.participants import JoinRoom, KickParticipant, LeaveRoom, ToggleMute
from ....core.domain.models import Role
from ....core.errors import NotFoundError
from ....core.ports.repositories import ParticipantRepository, RoomRepository
from ..deps.containers import get_participant_repo, get_room_repo
from ....core.services.room_service import RoomService

router = APIRouter(prefix="/api/v1/rooms/{room_id}", tags=["participants"])


@router.post("/join")
async def join_room(
    room_id: str,
    user_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
    rooms: RoomRepository = Depends(get_room_repo),
) -> dict:  # type: ignore[override]
    use = JoinRoom(participants, rooms, RoomService())
    p = await use.execute(room_id=UUID(room_id), user_id=UUID(user_id), role=Role.member)
    return {"status": "ok", "participantId": str(p.id)}


@router.post("/leave")
async def leave_room(room_id: str, user_id: str, participants: ParticipantRepository = Depends(get_participant_repo)) -> dict:  # type: ignore[override]
    use = LeaveRoom(participants)
    await use.execute(room_id=UUID(room_id), user_id=UUID(user_id))
    return {"status": "ok"}


@router.post("/kick/{target_id}")
async def kick(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = KickParticipant(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}


@router.post("/toggle-mute/{target_id}")
async def toggle_mute(
    room_id: str,
    target_id: str,
    actor_id: str,
    participants: ParticipantRepository = Depends(get_participant_repo),
) -> dict:  # type: ignore[override]
    use = ToggleMute(participants, RoomService())
    await use.execute(room_id=UUID(room_id), actor_id=UUID(actor_id), target_id=UUID(target_id))
    return {"status": "ok"}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\participants.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\push.py =====
--- SIZE: 5062 bytes ---

from __future__ import annotations

from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from pydantic import BaseModel

from ....core.domain.models import PushSubscription
from ....core.ports.repositories import PushSubscriptionRepository, UserRepository
from ..deps.auth import get_current_user
from ..deps.containers import get_db_session
from ....infrastructure.db.repositories.push_subs import PgPushSubscriptionRepository
from ....infrastructure.db.repositories.users import PgUserRepository
from ....infrastructure.services.webpush import WebPushMessage  # noqa: F401 (оставлено для совместимости типов)
from ....infrastructure.config import get_settings  # noqa: F401 (может быть использован где-то ещё)
from ...ws.friends import publish_call_accept, publish_call_decline, publish_call_cancel  # noqa: F401 (совместимость старого кода)
from ..deps.containers import get_push_notifier, get_call_invite_service
from ....core.ports.services import PushNotifier, CallInviteService


router = APIRouter(prefix="/api/v1/push", tags=["push"])


class SubscribeIn(BaseModel):
    endpoint: str
    keys: dict


async def get_push_repo(session=Depends(get_db_session)) -> PushSubscriptionRepository:
    return PgPushSubscriptionRepository(session)


async def get_user_repo(session=Depends(get_db_session)) -> UserRepository:
    return PgUserRepository(session)


@router.post("/subscribe")
async def subscribe(body: SubscribeIn, current=Depends(get_current_user), repo: PushSubscriptionRepository = Depends(get_push_repo)):
    p256dh = body.keys.get("p256dh")
    auth = body.keys.get("auth")
    if not (p256dh and auth):
        raise HTTPException(status_code=400, detail="Invalid keys")
    sub = PushSubscription.create(current.id, body.endpoint, p256dh, auth)
    await repo.add(sub)
    return {"ok": True}


@router.post("/unsubscribe")
async def unsubscribe(body: SubscribeIn, current=Depends(get_current_user), repo: PushSubscriptionRepository = Depends(get_push_repo)):
    await repo.remove(current.id, body.endpoint)
    return {"ok": True}


@router.get("/vapid-public")
async def get_vapid_public():
    s = get_settings()
    return {"key": s.VAPID_PUBLIC_KEY}


class CallNotifyIn(BaseModel):
    to_user_id: UUID
    # Принимаем строковый room_id, чтобы поддерживать простые идентификаторы (например, "3")
    room_id: str


class CallActionIn(BaseModel):
    other_user_id: UUID
    room_id: str


"""Refactored: `_send_pushes` заменён PushNotifier сервисом (SimplePushNotifier).
Оставлено место чтобы избежать конфликтов с импортами при горячей перезагрузке.
"""


@router.post("/notify-call")
async def notify_call(
    body: CallNotifyIn,
    background: BackgroundTasks,
    current=Depends(get_current_user),
    call_invites: CallInviteService = Depends(get_call_invite_service),  # type: ignore[arg-type]
    push_notifier: PushNotifier = Depends(get_push_notifier),  # type: ignore[arg-type]
):
    if body.to_user_id == current.id:
        raise HTTPException(status_code=400, detail="Cannot notify yourself")
    # Вызов бизнес-сервиса приглашения (инкапсулирует хранение pending + ws публикацию)
    await call_invites.invite(current.id, body.to_user_id, body.room_id, current.username, str(current.email))
    # Push отправляем асинхронно (не блокируем ответ)
    background.add_task(push_notifier.notify_incoming_call, body.to_user_id, current.id, current.username, body.room_id)
    return {"ok": True, "scheduled": True, "room_id": body.room_id}


@router.post("/call/accept")
async def accept_call(body: CallActionIn, current=Depends(get_current_user), call_invites: CallInviteService = Depends(get_call_invite_service)):
    await call_invites.accept(current.id, body.other_user_id, body.room_id)
    return {"ok": True}


@router.post("/call/decline")
async def decline_call(body: CallActionIn, current=Depends(get_current_user), call_invites: CallInviteService = Depends(get_call_invite_service)):
    await call_invites.decline(current.id, body.other_user_id, body.room_id)
    return {"ok": True}


@router.post("/call/cancel")
async def cancel_call(body: CallActionIn, current=Depends(get_current_user), call_invites: CallInviteService = Depends(get_call_invite_service)):
    """Отмена исходящего звонка инициатором до принятия.

    Семантически отличается от decline (который делает принимающая сторона).
    """
    await call_invites.cancel(current.id, body.other_user_id, body.room_id)
    return {"ok": True}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\push.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\rooms.py =====
--- SIZE: 3983 bytes ---

from __future__ import annotations

from uuid import UUID

from fastapi import APIRouter, Depends

from ....application.dto.rooms import CreateRoomInput, ListRoomsInput, RoomDTO, VisitedRoomDTO
from ....application.use_cases.rooms import CreateRoom, GetRoom, ListRooms, DeleteRoom
from ..deps.rate_limit import limit_room_create
from ....core.ports.repositories import RoomRepository, ParticipantRepository
from ..deps.containers import get_room_repo, get_participant_repo
from ..deps.auth import get_current_user

router = APIRouter(prefix="/api/v1/rooms", tags=["rooms"])


@router.post("", response_model=RoomDTO)
async def create_room(
    data: CreateRoomInput,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
    _: None = Depends(limit_room_create),
) -> RoomDTO:  # type: ignore[override]
    use = CreateRoom(rooms)
    room = await use.execute(name=data.name, owner_id=UUID(str(current_user.id)), is_private=data.is_private)
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.get("", response_model=list[RoomDTO])
async def list_rooms(
    owner_id: str | None = None,
    skip: int = 0,
    limit: int = 50,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    use = ListRooms(rooms)
    rid = UUID(owner_id) if owner_id else None
    items = await use.execute(owner_id=rid, skip=skip, limit=limit)
    return [RoomDTO(id=str(r.id), name=str(r.name), owner_id=str(r.owner_id), is_private=r.is_private, created_at=r.created_at) for r in items]


@router.get("/visited", response_model=list[VisitedRoomDTO])
async def list_visited_rooms(
    skip: int = 0,
    limit: int = 50,
    rooms: RoomRepository = Depends(get_room_repo),
    participants: ParticipantRepository = Depends(get_participant_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    pairs = await participants.list_visited_rooms(UUID(str(current_user.id)), skip=skip, limit=limit)
    room_ids = [rid for rid, _ in pairs]
    metas = await rooms.get_many(room_ids)
    meta_map = { r.id: r for r in metas }
    out: list[VisitedRoomDTO] = []
    for rid, last_seen in pairs:
        r = meta_map.get(rid)
        out.append(
            VisitedRoomDTO(
                room_id=str(rid),
                last_seen=last_seen,
                name=str(r.name) if r else None,
                owner_id=str(r.owner_id) if r else None,
                is_private=r.is_private if r else None,
            )
        )
    return out


@router.delete("/visited/{room_id}")
async def delete_visited_room(
    room_id: UUID,
    participants: ParticipantRepository = Depends(get_participant_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    # Удаляем все записи участника в этой комнате (очистка истории по комнате)
    await participants.remove(room_id, UUID(str(current_user.id)))
    return {"status": "ok"}


@router.get("/{room_id}", response_model=RoomDTO)
async def get_room(
    room_id: UUID,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
) -> RoomDTO:  # type: ignore[override]
    use = GetRoom(rooms)
    room = await use.execute(room_id)
    return RoomDTO(id=str(room.id), name=str(room.name), owner_id=str(room.owner_id), is_private=room.is_private, created_at=room.created_at)


@router.delete("/{room_id}")
async def delete_room(
    room_id: UUID,
    rooms: RoomRepository = Depends(get_room_repo),
    current_user=Depends(get_current_user),
):  # type: ignore[override]
    deleter = DeleteRoom(rooms)
    await deleter.execute(room_id, UUID(str(current_user.id)))
    return {"status": "deleted"}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\rooms.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\telegram_link.py =====
--- SIZE: 11063 bytes ---

from __future__ import annotations

from fastapi import APIRouter, Depends, HTTPException, Request
import contextlib
import logging
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession

from ....infrastructure.services.telegram_link import (
    create_or_refresh_link, confirm_link, get_confirmed_chat_id, revoke_user_links
)
from sqlalchemy.exc import IntegrityError
from ....infrastructure.db.session import get_db_session
from ....infrastructure.config import get_settings
from ..deps.auth import get_current_user

settings = get_settings()
api_prefix = settings.API_PREFIX.rstrip('/')  # ожидаемо /api/v1
router = APIRouter(prefix=f"{api_prefix}/telegram", tags=["telegram"])
log = logging.getLogger("telegram")
_LAST_UPDATE: dict | None = None  # хранение последнего сырого апдейта для отладки


class LinkCreateOut(BaseModel):
    token: str
    deeplink: str
    expires_at: str


@router.post("/link", response_model=LinkCreateOut)
async def create_link(session: AsyncSession = Depends(get_db_session), current_user=Depends(get_current_user)):
    bot_name = (settings.TELEGRAM_BOT_NAME or "").strip()
    if not bot_name:
        raise HTTPException(status_code=500, detail="TELEGRAM_BOT_NAME is not configured on server")
    if bot_name.startswith("@"):
        raise HTTPException(status_code=400, detail="TELEGRAM_BOT_NAME must be provided without '@'")
    link = await create_or_refresh_link(session, current_user.id)
    await session.commit()
    deeplink = f"https://t.me/{bot_name}?start={link.token}"
    return LinkCreateOut(token=link.token, deeplink=deeplink, expires_at=link.expires_at.isoformat())


class LinkStatusOut(BaseModel):
    status: str
    chat_id: str | None = None


@router.get("/status", response_model=LinkStatusOut)
async def status(session: AsyncSession = Depends(get_db_session), current_user=Depends(get_current_user)):
    chat_id = await get_confirmed_chat_id(session, current_user.id)
    if chat_id:
        return LinkStatusOut(status="confirmed", chat_id=chat_id)
    # Если нет confirmed — проверим есть ли вообще какие-либо revoked чтобы различать полностью отсутствующее.
    # (Опционально можно вернуть 'absent'). Пока просто absent.
    return LinkStatusOut(status="absent", chat_id=None)


class LinkRevokeOut(BaseModel):
    revoked: int
    status: str


@router.delete("/link", response_model=LinkRevokeOut)
async def revoke_link(session: AsyncSession = Depends(get_db_session), current_user=Depends(get_current_user)):
    updated = await revoke_user_links(session, current_user.id)
    await session.commit()
    # После revoke confirmed chat_id недоступен
    return LinkRevokeOut(revoked=updated, status="absent")


class WebhookIn(BaseModel):
    update_id: int | None = None
    message: dict | None = None


@router.post("/webhook")
async def webhook(data: WebhookIn, session: AsyncSession = Depends(get_db_session)):
    """Обработка входящего Telegram update.

    Требования к надёжности:
      * Никогда не даём 500 Telegram (иначе ретраи и рост pending_update_count).
      * Логируем сырые данные; при ошибке фиксируем traceback.
      * Устраняем конфликт уникального индекса (user_id, chat_id) как нормальный кейс пере-привязки.
    """
    global _LAST_UPDATE
    try:
        raw = data.model_dump()
        _LAST_UPDATE = raw
        log.info("TG webhook update: %s", raw)
    except Exception:  # pragma: no cover
        log.exception("Failed to log incoming update")
    try:
        if not data.message:
            return {"ok": True}
        msg = data.message
        text = (msg.get("text") or "").strip()
        chat = msg.get("chat") or {}
        chat_id = str(chat.get("id")) if chat.get("id") is not None else None
        # Парсим токен из /start
        token_candidate = None
        if text.startswith("/start "):
            token_candidate = text.split(maxsplit=1)[1]
        elif text.startswith("/start") and len(text) > 6:
            token_candidate = text[6:].strip()
        # Примитивный guard длины токена (ожидаем 10..80 символов)
        if token_candidate and not (10 <= len(token_candidate) <= 80):
            log.warning("Token candidate length out of expected range len=%s", len(token_candidate))
            token_candidate = None
        if token_candidate and chat_id:
            log.info("Attempt confirm token=%s chat_id=%s", token_candidate, chat_id)
            ok = await confirm_link(session, token_candidate, chat_id)
            if ok:
                try:
                    await session.commit()
                except IntegrityError as ie:
                    # Возможный дубликат уникального индекса (user_id, chat_id) при повторной привязке
                    await session.rollback()
                    log.info("IntegrityError on commit (likely duplicate chat). Treat as success: %s", ie.__class__.__name__)
                    from ....infrastructure.services.telegram import send_message  # локальный импорт
                    with contextlib.suppress(Exception):
                        await send_message("Привязка Telegram подтверждена (повтор).", chat_ids=[chat_id])
                    return {"ok": True, "linked": True, "dup": True}
                # Отправляем подтверждающее сообщение (не критично при ошибке)
                from ....infrastructure.services.telegram import send_message  # локальный импорт
                try:
                    await send_message("Привязка Telegram успешна. Теперь вы будете получать AI summary.", chat_ids=[chat_id])
                except Exception as e:  # pragma: no cover
                    log.warning("Failed to send confirmation message chat_id=%s err=%s", chat_id, e.__class__.__name__)
                return {"ok": True, "linked": True}
            else:
                log.info("Confirm failed token=%s chat_id=%s (maybe expired/invalid)", token_candidate, chat_id)
                # Мягко уведомим пользователя (без разглашения деталей)
                from ....infrastructure.services.telegram import send_message  # локальный импорт
                with contextlib.suppress(Exception):
                    await send_message("Токен недействителен или истёк. Сгенерируйте новый в настройках.", chat_ids=[chat_id])
                return {"ok": True, "linked": False}
        if text.startswith('/start') and not token_candidate and chat_id:
            # Пользователь ввёл /start без токена — подскажем что делать
            from ....infrastructure.services.telegram import send_message  # локальный импорт
            with contextlib.suppress(Exception):
                await send_message("Отправьте /start <токен>. Получить новый токен можно в настройках приложения.", chat_ids=[chat_id])
        return {"ok": True}
    except Exception as e:  # pragma: no cover
        # Логируем подробно и возвращаем 200 чтобы Telegram не ретраил до бесконечности
        log.exception("Unhandled error in webhook: %s", e)
        try:
            await session.rollback()
        except Exception:
            pass
        return {"ok": True, "error": "internal", "logged": True}


@router.get("/last_update")
async def last_update():  # pragma: no cover - диагностический
    return {"ok": True, "last_update": _LAST_UPDATE}


@router.post("/poll_debug")
async def poll_debug():  # pragma: no cover - диагностический
    """Одноразовый polling getUpdates (если webhook не работает).

    ВНИМАНИЕ: если webhook установлен, getUpdates обычно возвращает пусто.
    Использовать только для диагностики. offset не задаём.
    """
    import httpx
    bot_token = settings.TELEGRAM_BOT_TOKEN
    if not bot_token:
        raise HTTPException(500, detail="TELEGRAM_BOT_TOKEN not set")
    url = f"https://api.telegram.org/bot{bot_token}/getUpdates"
    try:
        r = httpx.get(url, timeout=10)
        data = r.json()
    except Exception as e:  # pragma: no cover
        raise HTTPException(502, detail=f"poll error: {e.__class__.__name__}") from e
    return data


@router.get("/selftest")
async def telegram_selftest():
    """Проверка Bot API: getMe + getWebhookInfo.

    Возвращает JSON с:
      - api_username / configured_name / match
      - webhook_url / has_custom_certificate / pending_update_count / last_error_* (если есть)
    """
    import httpx
    bot_token = settings.TELEGRAM_BOT_TOKEN
    bot_name = settings.TELEGRAM_BOT_NAME
    if not bot_token:
        raise HTTPException(500, detail="TELEGRAM_BOT_TOKEN not set")

    base = f"https://api.telegram.org/bot{bot_token}"
    timeout = httpx.Timeout(10.0, connect=5.0)
    try:
        r_me = httpx.get(f"{base}/getMe", timeout=timeout)
        r_wh = httpx.get(f"{base}/getWebhookInfo", timeout=timeout)
    except Exception as e:
        raise HTTPException(502, detail=f"Network error: {e.__class__.__name__}") from e
    try:
        data_me = r_me.json()
        data_wh = r_wh.json()
    except Exception:
        raise HTTPException(500, detail="Non-JSON response from Telegram")
    if not data_me.get("ok"):
        return {"ok": False, "stage": "getMe", "error": data_me}
    if not data_wh.get("ok"):
        return {"ok": False, "stage": "getWebhookInfo", "error": data_wh}
    api_username = data_me.get("result", {}).get("username")
    wh = data_wh.get("result", {})
    return {
        "ok": True,
        "api_username": api_username,
        "configured_name": bot_name,
        "match": (api_username or "").lower() == (bot_name or "").lower(),
        "webhook_url": wh.get("url"),
        "pending_update_count": wh.get("pending_update_count"),
        "last_error_date": wh.get("last_error_date"),
        "last_error_message": wh.get("last_error_message"),
        "ip_address": wh.get("ip_address"),
        "has_custom_certificate": wh.get("has_custom_certificate"),
    }

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\telegram_link.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\users.py =====
--- SIZE: 1515 bytes ---

from __future__ import annotations

from typing import List

from fastapi import APIRouter, Depends, Query
from pydantic import BaseModel

from ....core.ports.repositories import UserRepository
from ..deps.auth import get_current_user
from ..deps.containers import get_user_repo
from ....infrastructure.db.repositories.users import PgUserRepository


router = APIRouter(prefix="/api/v1/users", tags=["users"])


class PublicKeyIn(BaseModel):
    public_key: str


@router.post('/me/public_key')
async def set_my_public_key(body: PublicKeyIn, current=Depends(get_current_user), users: PgUserRepository = Depends(get_user_repo)):
    await users.set_public_key(current.id, body.public_key)
    return {"ok": True}


@router.get('/{user_id}/public_key')
async def get_user_public_key(user_id: str, users: PgUserRepository = Depends(get_user_repo)):
    u = await users.get_by_id(user_id)
    if not u:
        return {"public_key": None}
    return {"public_key": u.public_key}


class UserShort(BaseModel):
    id: str
    username: str
    email: str


@router.get("/find", response_model=List[UserShort])
async def find_users(q: str = Query(..., min_length=1), users: UserRepository = Depends(get_user_repo), current=Depends(get_current_user)):
    items = await users.search(q, limit=10)
    # u.username является value object Username -> приводим к str
    return [UserShort(id=str(u.id), username=str(u.username), email=str(u.email)) for u in items]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\users.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\webrtc.py =====
--- SIZE: 436 bytes ---

from __future__ import annotations

from fastapi import APIRouter, Depends

from ....core.ports.services import IceConfigProvider
from ..deps.containers import get_ice_provider

router = APIRouter(prefix="/api/v1/webrtc", tags=["webrtc"])


@router.get("/ice-servers")
async def ice_servers(provider: IceConfigProvider = Depends(get_ice_provider)) -> dict:  # type: ignore[override]
    return await provider.get_servers()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\api\routers\webrtc.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\docs.py =====
--- SIZE: 745 bytes ---

from __future__ import annotations

from typing import List


def get_openapi_tags() -> List[dict]:
    return [
        {"name": "auth", "description": "Аутентификация"},
        {"name": "rooms", "description": "Комнаты"},
        {"name": "participants", "description": "Участники"},
        {"name": "messages", "description": "Сообщения"},
        {"name": "webrtc", "description": "WebRTC вспомогательные"},
    {"name": "friends", "description": "Друзья"},
    {"name": "push", "description": "Web Push уведомления"},
    {"name": "users", "description": "Пользователи"},
        {"name": "health", "description": "Health checks"},
    ]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\docs.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\errors.py =====
--- SIZE: 1183 bytes ---

from __future__ import annotations

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

from ..core.errors import AuthError, ConflictError, DomainError, NotFoundError, PermissionDenied, ValidationError


def setup_error_handlers(app: FastAPI) -> None:
    @app.exception_handler(ValidationError)
    async def _validation(_: Request, exc: ValidationError):
        return JSONResponse(status_code=400, content={"detail": str(exc)})

    @app.exception_handler(AuthError)
    async def _auth(_: Request, exc: AuthError):
        return JSONResponse(status_code=401, content={"detail": str(exc)})

    @app.exception_handler(NotFoundError)
    async def _not_found(_: Request, exc: NotFoundError):
        return JSONResponse(status_code=404, content={"detail": str(exc)})

    @app.exception_handler(ConflictError)
    async def _conflict(_: Request, exc: ConflictError):
        return JSONResponse(status_code=409, content={"detail": str(exc)})

    @app.exception_handler(PermissionDenied)
    async def _forbidden(_: Request, exc: PermissionDenied):
        return JSONResponse(status_code=403, content={"detail": str(exc)})
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\errors.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\schemas\api.py =====
--- SIZE: 953 bytes ---

from __future__ import annotations

from datetime import datetime
from typing import Optional

from pydantic import BaseModel, Field


class ErrorResponse(BaseModel):
    detail: str


class UserOut(BaseModel):
    id: str
    email: str
    username: str


class RoomCreateIn(BaseModel):
    name: str = Field(min_length=1, max_length=100)
    is_private: bool = False


class RoomOut(BaseModel):
    id: str
    name: str
    owner_id: str
    is_private: bool
    created_at: datetime


class MessageIn(BaseModel):
    content: str = Field(min_length=1, max_length=2000)


class MessageOut(BaseModel):
    id: str
    room_id: str
    author_id: str
    content: str
    sent_at: datetime


class SignalIn(BaseModel):
    signalType: str
    sdp: Optional[str] = None
    candidate: Optional[dict] = None
    targetUserId: Optional[str] = None


class PresenceOut(BaseModel):
    users: list[dict]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\schemas\api.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\auth.html =====
--- SIZE: 3086 bytes ---

<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Вход | WebCall 2.0</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .auth-card { max-width: 520px; margin: 10vh auto; }
      .tabs { display:flex; gap:8px; margin-bottom:12px }
      .tab { padding:8px 12px; border-radius:8px; border:1px solid var(--border); cursor:pointer; background:#0b1220 }
      .tab.active { background: var(--primary); border-color: var(--primary) }
      .hint { color: var(--muted); font-size: 13px }
    </style>
  </head>
  <body>
    <main class="container">
      <div class="card auth-card">
        <h2>Добро пожаловать</h2>
        <div class="tabs">
          <button class="tab active" id="tabLogin">Вход</button>
          <button class="tab" id="tabRegister">Регистрация</button>
        </div>
        <div id="formLogin" class="form-grid">
          <label>
            <span>Email</span>
            <input id="loginEmail" type="email" placeholder="you@example.com" />
          </label>
          <label>
            <span>Пароль</span>
            <input id="loginPassword" type="password" placeholder="••••••••" />
          </label>
          <button id="btnDoLogin" class="btn primary">Войти</button>
          <div class="hint">Если у вас нет аккаунта — перейдите на вкладку «Регистрация».</div>
        </div>
        <div id="formRegister" class="form-grid" style="display:none">
          <label>
            <span>Email</span>
            <input id="regEmail" type="email" placeholder="you@example.com" />
          </label>
          <label>
            <span>Имя пользователя</span>
            <input id="regUsername" type="text" placeholder="Ваше имя" />
          </label>
          <label>
            <span>Пароль</span>
            <input id="regPassword" type="password" placeholder="••••••••" />
          </label>
          <label>
            <span>Секретный код</span>
            <input id="regSecret" type="password" placeholder="Введите секретный код" required />
          </label>
          <button id="btnDoRegister" class="btn success">Зарегистрироваться</button>
          <div class="hint">Для регистрации требуется секретный код. После успеха вы будете перенаправлены в звонок.</div>
        </div>
        <div id="authLog" class="logs" style="margin-top:12px;min-height:60px"></div>
      </div>
    </main>
    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>
  <script src="/static/js/fx_web.js" defer></script>
  <script type="module" src="/static/js/auth.js"></script>
  </body>
</html>

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\auth.html =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\debug_websocket.js =====
--- SIZE: 2862 bytes ---

// Диагностический скрипт для проверки WebSocket соединения
// Вставьте в консоль браузера для диагностики проблем со звонками

console.log('=== Диагностика WebSocket соединения ===');

// Проверяем основные компоненты
const checks = {
  token: localStorage.getItem('wc_token'),
  appState: typeof window.appState !== 'undefined',
  friendsWs: window.appState?.friendsWs,
  wsState: window.appState?.friendsWs?.readyState,
  showToast: typeof window.showToast === 'function',
  startFriendsWs: typeof window.startFriendsWs === 'function'
};

console.log('Проверки:', checks);

// Показываем состояние WebSocket
if (checks.friendsWs) {
  const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
  const stateName = states[checks.wsState] || 'UNKNOWN';
  console.log(`WebSocket состояние: ${checks.wsState} (${stateName})`);
} else {
  console.log('WebSocket не создан');
}

// Проверяем токен
if (!checks.token) {
  console.warn('❌ Токен авторизации не найден!');
  console.log('Войдите в систему для использования звонков');
} else {
  console.log('✅ Токен найден');
  try {
    const payload = JSON.parse(atob(checks.token.split('.')[1]));
    console.log('Токен содержит:', { sub: payload.sub, exp: new Date(payload.exp * 1000) });
  } catch (e) {
    console.warn('Не удалось разобрать токен:', e);
  }
}

// Попытка переподключения
if (!checks.friendsWs || checks.wsState !== 1) {
  console.log('Попытка переподключения...');
  if (checks.startFriendsWs) {
    try {
      window.appState.friendsWs = null; // Сбрасываем существующее соединение
      window.startFriendsWs();
      console.log('Инициировано переподключение');
    } catch (e) {
      console.error('Ошибка переподключения:', e);
    }
  }
}

// Проверяем серверную часть
console.log('Проверяем серверные endpoints...');
fetch('/ws/friends', { method: 'HEAD' })
  .then(r => console.log('WebSocket endpoint доступен:', r.status))
  .catch(e => console.error('WebSocket endpoint недоступен:', e));

fetch('/api/v1/auth/me', { 
  headers: { 'Authorization': `Bearer ${checks.token}` }
})
  .then(r => r.json())
  .then(data => console.log('Пользователь:', data))
  .catch(e => console.error('Ошибка проверки пользователя:', e));

console.log('=== Конец диагностики ===');
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\debug_websocket.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\favicon.ico =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\favicon.ico =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\index.html =====
--- SIZE: 13338 bytes ---

<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>WebCall 2.0</title>
    <link rel="stylesheet" href="/static/styles.css" />
  </head>
  <body>
    <header class="app-header">
      <div class="container header-inner">
        <div class="brand">
          <span class="logo" aria-hidden>●</span>
          <span class="title">WebCall 2.0</span>
        </div>
        <nav class="actions">
          <div id="currentUserBadge" class="user-badge" style="display:none;">
            <span class="user-badge__icon">👤</span>
            <span class="user-badge__name" id="currentUsername"></span>
          </div>
            <button class="btn ghost theme-dot" id="btnToggleTheme" title="Тема" data-mode="auto">●</button>
          <button class="btn ghost" id="btnLogout" title="Выход">Выйти</button>
        </nav>
      </div>
    </header>

    <main class="container app-main">
      <!-- Верхняя панель: Комната + История -->
      <section class="panel grid-2">
  <div class="card span-2" id="roomCard">
          <h2>Комната</h2>
          <div class="form-grid">
            <div class="row" style="grid-column:1/-1; align-items:stretch; gap:8px;">
              <input type="text" id="roomId" placeholder="ID комнаты" style="flex:1;" />
              <button id="btnConnect" class="btn primary">Войти</button>
            </div>
            <!-- Во время звонка -->
            <div id="inCallControls" class="controls-grid" style="grid-column:1/-1; display:none;">
              <button id="btnLeave" class="btn danger">Выйти</button>
              <button id="btnCopyLink" class="btn">Копия ссылки</button>
              <button id="btnToggleMic" class="btn" title="Микрофон">🎤 Микро</button>
              <button id="btnToggleCam" class="btn" title="Камера">🎥 Камера</button>
              <button id="btnScreenShare" class="btn" title="Демонстрация экрана">🖥 Экран</button>
              <button id="btnAiAgent" class="btn ghost" title="Подключить AI агента">AI Agent</button>
            </div>
          </div>
        </div>
        <!-- Правый столбец: до входа — История -->
        <div class="card" id="visitedCard">
          <h2>Ваши комнаты</h2>
          <div id="visitedRooms" class="list"></div>
        </div>
      </section>

      <!-- Блок, который виден только в звонке -->
      <section id="inCallSection" style="display:none;" class="app-in-call">
        <section class="panel grid-2">
          <div class="card video-card" id="localCard" style="display:none">
            <h2 style="display:flex; justify-content:space-between; align-items:center; gap:.5rem;">
              <span>Вы</span>
              <button class="btn btn-xs btn-fullscreen" type="button" data-action="fullscreen-local" title="На полный экран">⛶</button>
            </h2>
            <div class="video-wrap">
              <video id="localVideo" muted playsinline></video>
              <div id="localVideoMetrics" style="position:absolute; left:8px; bottom:8px; background:rgba(0,0,0,.55); color:#e0e6ef; font:12px/1.2 monospace; padding:4px 6px; border-radius:4px; z-index:8; display:none; pointer-events:none; min-width:90px; text-shadow:0 0 2px #000;">
                —
              </div>
              <div id="screenShareBadge" class="share-badge" style="display:none;" aria-live="polite">🖥 <span>Экран шарится</span></div>
              <div id="localPip" class="pip" style="display:none;">
                <video id="localPipVideo" muted playsinline></video>
              </div>
              <div id="multiBadge" class="share-badge" style="display:none; right:8px; left:auto; background:linear-gradient(140deg, rgba(124,58,237,.25), rgba(6,182,212,.18));">🎥+🖥 <span>Камера+Экран</span></div>
              <div class="local-video-controls" style="position:absolute; top:8px; right:8px; display:flex; gap:6px; z-index:7;">
                <button id="btnStopCam" class="btn xs ghost" title="Выключить камеру" style="display:none;">✖︎ Кам</button>
                <button id="btnStopScreen" class="btn xs ghost" title="Остановить экран" style="display:none;">✖︎ Экран</button>
                <button id="btnCompositeToggle" class="btn xs ghost" title="Комбинированное превью (экран+камера)" style="display:none;">🧩 Mix</button>
              </div>
              <!-- Canvas для локальной композиции (экран + мини-камера). По умолчанию скрыт -->
              <canvas id="localCompositeCanvas" width="1280" height="720" style="display:none; position:absolute; inset:0; width:100%; height:100%; object-fit:contain; background:#000; z-index:1;"></canvas>
            </div>
          </div>
          <div class="card" id="remoteContainer">
            <h2 style="display:flex; justify-content:space-between; align-items:center; gap:.5rem;">
              <span>Собеседники</span>
            </h2>
            <div id="peersGrid" class="peers-grid">
              <!-- Сюда добавляются плитки участников -->
            </div>
          </div>
        </section>

        <section class="card panel">
          <h2>Общий Чат</h2>
          <div id="chat" class="chat-box"></div>
          <div class="chat-input">
            <input type="text" id="chatInput" placeholder="Сообщение..." />
            <button id="btnSend" class="btn">»</button>
          </div>
        </section>

        <!-- Статус перенесён ниже общего чата и сделан полноширинным как Логи -->
        <section class="card panel" id="statusCard" style="display:none;">
          <h2>Статус</h2>
          <div id="connStatus"></div>
          <div class="form-grid" style="margin-top: .5rem; gap: .5rem 1rem;">
            <label class="row">
              <span>Микрофон</span>
              <select id="micSel" class="sel" title="Микрофон"></select>
            </label>
            <label class="row">
              <span>Динамики</span>
              <select id="spkSel" class="sel" title="Динамики"></select>
            </label>
          </div>
          <div id="stats" class="logs"></div>
        </section>

        <section class="card panel">
          <h2>Логи</h2>
          <div id="logs" class="logs"></div>
        </section>

        <!-- Debug Panel для Friends WebSocket и звонков -->
        <section class="card panel" id="debugPanel" style="display:none;">
          <h2>🔧 Debug Panel</h2>
          <div class="form-grid" style="margin-bottom:1rem; gap:.5rem 1rem;">
            <button id="btnToggleDebug" class="btn">Показать Debug</button>
            <button id="btnClearDebugLogs" class="btn ghost">Очистить логи</button>
            <button id="btnTestFriendsWS" class="btn ghost">Тест Friends WS</button>
            <button id="btnGetCallState" class="btn ghost">Состояние звонка</button>
          </div>
          
          <div id="debugContent" style="display:none;">
            <div class="grid-2" style="gap:12px; margin-bottom:1rem;">
              <div>
                <div class="muted small" style="margin-bottom:6px;">Friends WebSocket Status</div>
                <div id="friendsWsStatus" class="debug-status">
                  <div>Статус: <span id="friendsWsState">-</span></div>
                  <div>Сообщений получено: <span id="friendsWsMessageCount">0</span></div>
                  <div>Последнее сообщение: <span id="friendsWsLastMessage">-</span></div>
                  <div>Реконнектов: <span id="friendsWsReconnects">0</span></div>
                </div>
              </div>
              <div>
                <div class="muted small" style="margin-bottom:6px;">Call State</div>
                <div id="callStateStatus" class="debug-status">
                  <div>Фаза: <span id="callPhase">-</span></div>
                  <div>Тип: <span id="callType">-</span></div>
                  <div>Друг: <span id="callFriendId">-</span></div>
                  <div>Room ID: <span id="callRoomId">-</span></div>
                </div>
              </div>
            </div>
            
            <div class="muted small" style="margin-bottom:6px;">Friends WebSocket Messages (последние 20)</div>
            <div id="debugFriendsMessages" class="logs" style="height:150px; margin-bottom:1rem;"></div>
            
            <div class="muted small" style="margin-bottom:6px;">Call Debug Log</div>
            <div id="debugCallLog" class="logs" style="height:150px;"></div>
          </div>
        </section>
      </section>

      <!-- Нижняя панель: Друзья + Личный чат (перенесены ниже плиток участников) -->
      <section class="panel grid-2">
        <div class="card" id="friendsCard">
          <h2>Друзья</h2>
          <div class="form-grid" style="margin-bottom:.5rem; gap:.5rem 1rem;">
            <label class="row" style="grid-column:1/-1;">
              <input type="text" id="friendSearch" placeholder="Поиск по username или email" />
              <button class="btn" id="btnFriendSearch">Искать</button>
            </label>
          </div>
          <div class="grid-2" style="gap:12px;">
            <div>
              <div class="muted small" style="margin-bottom:6px;">Друзья</div>
              <div id="friendsList" class="list"></div>
            </div>
            <div>
              <div class="muted small" style="margin-bottom:6px;">Заявки</div>
              <div id="friendRequests" class="list"></div>
            </div>
          </div>
          <div>
            <div class="muted small" style="margin-top:10px; margin-bottom:6px;">Результаты поиска</div>
            <div id="friendSearchResults" class="list"></div>
          </div>
        </div>
        <div class="card" id="directChatCard" style="display:none;">
          <h2>Личный чат</h2>
          <div class="muted small" id="directChatTitle" style="margin-bottom:6px;">Не выбран</div>
          <div id="directMessages" class="chat-box" style="height:180px;"></div>
          <div class="chat-input" style="margin-top:6px;">
            <input type="text" id="directInput" placeholder="Сообщение другу..." />
            <button class="btn" id="btnDirectSend">»</button>
          </div>
          <div class="muted small" style="margin-top:4px; display:flex; gap:4px; flex-wrap:wrap;" id="directActions"></div>
        </div>
      </section>
    </main>

    <template id="tpl-log-line">
      <div class="log-line"><span class="time"></span><span class="msg"></span></div>
    </template>

    <template id="tpl-peer-tile">
      <div class="tile" data-peer="">
        <div class="media">
          <div class="video-stack">
            <video class="peer-main" autoplay playsinline></video>
            <div class="pip" style="display:none;">
              <video class="peer-pip" autoplay playsinline muted></video>
            </div>
          </div>
          <audio autoplay></audio>
        </div>
        <div class="hud">
          <span class="name"></span>
          <div class="level"><div class="level-bar"></div></div>
          <label class="vol">
            🔊 <input type="range" name="volume" min="0" max="100" step="1" value="100" />
          </label>
          <button class="btn btn-xs btn-fullscreen" type="button" title="На полный экран" data-action="fullscreen">⛶</button>
        </div>
      </div>
    </template>

  <script src="/static/js/fx_web.js" defer></script>
  <script src="/static/js/debug_panel.js" defer></script>
  <script type="module" src="/static/js/boot.js"></script>
  
  <!-- Incoming Call Modal -->
  <div id="incomingCallModal" class="wc-modal" style="display:none;">
    <div class="wc-modal-backdrop"></div>
    <div class="wc-modal-dialog">
      <div class="wc-modal-body">
        <div class="wc-modal-icon">📞</div>
        <div class="wc-modal-text">
          <div class="wc-modal-title">Входящий звонок</div>
          <div class="wc-modal-sub" id="incomingCallFrom">Пользователь</div>
        </div>
      </div>
      <div class="wc-modal-actions">
        <button id="btnCallDecline" class="btn danger">Отклонить</button>
        <button id="btnCallAccept" class="btn success">Принять</button>
      </div>
    </div>
  </div>
  </body>
</html>

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\index.html =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\call_end.test.mjs =====
--- SIZE: 4040 bytes ---

import { describe, it, expect } from 'vitest';

/**
 * Тестирует обработку события call_end: сброс состояния activeCall и показ toast.
 * Мы подменяем глобальные объекты, импортируем модуль app_init (который регистрирует обработчик),
 * и вручную вызываем onmessage аналогично приходу WS сообщения.
 */

describe('call_end handling', () => {
  it('resets active call and shows toast', async () => {
    // Создаём минимальные DOM элементы, которые ожидает код
    document.body.innerHTML = `
      <input id="roomId" value="call-abc-room" />
      <div id="callContext"></div>
    `;
    // Загружаем state / calls
    const stateMod = await import('../modules/core/state.js');
    const callsMod = await import('../modules/calls.js');
    const { appState } = stateMod;
    const { setActiveOutgoingCall, markCallAccepted } = callsMod;

    // Подготовим активный звонок (accepted)
    setActiveOutgoingCall({ user_id: '00000000-0000-0000-0000-000000000222', username: 'Friend' }, 'call-abc-room');
    markCallAccepted('call-abc-room');
    expect(appState.activeCall?.status).toBe('accepted');

    // Импортируем dom utilities чтобы отследить toast
    const dom = await import('../modules/core/dom.js');

    // Импортируем app_init чтобы получить обработчик, но friends WS мы подменим вручную
    const appInitMod = await import('../modules/core/app_init.js');
    // Подменяем friendsWs имитацией
    appState.friendsWs = { readyState: 1 };

    // Находим зарегистрированный onmessage обработчик (он устанавливается в startFriendsWs, которое вызывается в appInit)
    // Здесь проще непосредственно смоделировать часть логики: воспроизводим switch-case call_end.
    // Создаём фейковое событие как если бы пришло из WS
    const handler = (await import('../modules/core/app_init.js')); // повторный импорт — модуль уже загружен
    // Нам нужен прямой доступ к внутреннему onmessage нельзя — поэтому в тесте просто вручную исполняем ту же логику:
    const { resetActiveCall, getActiveCall } = await import('../modules/calls.js');

    // Сымитируем приход сообщения call_end
    const msg = { type: 'call_end', roomId: 'call-abc-room', reason: 'hangup' };
    // Выполняем тот же блок switch (ниже — извлечённый кусок)
    const ac = getActiveCall();
    if (ac && ac.roomId === msg.roomId && ac.status === 'accepted'){
      const reason = (msg.reason||'hangup');
      const reasonMap = {
        hangup: 'Собеседник завершил звонок',
        leave: 'Собеседник покинул комнату',
        disconnect: 'Соединение прервано',
        timeout: 'Звонок завершён по таймауту',
        failed: 'Звонок завершён (ошибка)',
        'remote-end': 'Звонок завершён'
      };
      const text = reasonMap[reason] || 'Звонок завершён';
      dom.showToast(text, { type: reason==='failed' ? 'error' : 'info' });
      resetActiveCall('remote-end');
    }

    expect(appState.activeCall).toBeNull();
    // Проверяем что toast появился
    const toast = document.querySelector('.wc-toast');
    expect(toast).toBeTruthy();
    expect(toast.textContent).toContain('Собеседник завершил звонок');
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\call_end.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\call_signaling_fixes.test.mjs =====
--- SIZE: 4415 bytes ---

// Тестовый файл для проверки исправлений звонков
import { describe, it, expect, beforeEach } from 'vitest';

// Mock зависимостей
global.window = {
  appState: {
    friendsWs: { readyState: WebSocket.OPEN },
  },
  showToast: () => {},
  WebSocket: { OPEN: 1 },
  crypto: { randomUUID: () => '12345678-1234-1234-1234-123456789abc' },
};

global.WebSocket = { OPEN: 1 };

// Моки API
const mockNotifyCall = (toUserId, roomId) => Promise.resolve({ room_id: roomId });

describe('Call Signaling Fixes', () => {
  let callsSignaling;
  let state;

  beforeEach(async () => {
    // Динамический импорт после установки мокав
    callsSignaling = await import('../modules/calls_signaling.js');

    // Инициализируем модуль
    callsSignaling.initCallSignaling({
      getAccountId: () => 'user123',
      connectRoom: () => {},
      unlockAudio: () => {},
    });

    // Ждем установки зависимостей
    await new Promise(resolve => setTimeout(resolve, 10));
    callsSignaling.forceResetCall();
  });

  it('should handle call_invite for outgoing caller correctly', async () => {
    const friend = { user_id: 'friend456', username: 'TestFriend' };
    
    // Подменяем notifyCall
    const originalFetch = global.fetch;
    global.fetch = () => Promise.resolve({
      ok: true,
      json: () => mockNotifyCall(friend.user_id, 'call-12345678-testfr')
    });

    // Инициируем звонок
    const result = callsSignaling.startOutgoingCall(friend);
    expect(result).toBe(true);

    // Симулируем получение call_invite от сервера для звонящего
    const { roomId } = callsSignaling.getCallState();
    const callInviteMsg = {
      type: 'call_invite',
      fromUserId: 'user123',
      toUserId: 'friend456',
      roomId,
      fromUsername: 'Me',
      toUsername: 'TestFriend'
    };

    callsSignaling.handleWsMessage(callInviteMsg);

    // Проверяем что состояние правильно обновилось
    const currentState = callsSignaling.getCallState();
    expect(currentState.phase).toBe('outgoing_ringing');
    expect(currentState.roomId).toBe(roomId);
    expect(currentState.otherUserId).toBe('friend456');

    global.fetch = originalFetch;
  });

  it('should handle call_invite for receiver correctly', async () => {
    // Симулируем получение call_invite от другого пользователя
    const callInviteMsg = {
      type: 'call_invite',
      fromUserId: 'caller789',
      toUserId: 'user123',
      roomId: 'call-87654321-caller',
      fromUsername: 'Caller',
      toUsername: 'Me'
    };

    callsSignaling.handleWsMessage(callInviteMsg);

    // Проверяем что состояние правильно обновилось для входящего звонка
    const currentState = callsSignaling.getCallState();
    expect(currentState.phase).toBe('incoming_ringing');
    expect(currentState.roomId).toBe('call-87654321-caller');
    expect(currentState.otherUserId).toBe('caller789');
    expect(currentState.otherUsername).toBe('Caller');
  });

  it('should handle call_accept correctly', async () => {
    const friend = { user_id: 'friend456', username: 'Friend' };
    const originalFetch = global.fetch;
    global.fetch = () => Promise.resolve({
      ok: true,
      json: () => mockNotifyCall(friend.user_id, 'call-test-room')
    });

    callsSignaling.startOutgoingCall(friend);

    const { roomId: outgoingRoom } = callsSignaling.getCallState();

    callsSignaling.handleWsMessage({
      type: 'call_invite',
      fromUserId: 'user123',
      toUserId: 'friend456',
      roomId: outgoingRoom,
      fromUsername: 'Me',
      toUsername: 'Friend'
    });

    const callAcceptMsg = {
      type: 'call_accept',
      fromUserId: 'friend456',
      toUserId: 'user123',
      roomId: outgoingRoom
    };

    callsSignaling.handleWsMessage(callAcceptMsg);

    const currentState = callsSignaling.getCallState();
    expect(currentState.phase).toBe('active');
    expect(currentState.roomId).toBe(outgoingRoom);

    global.fetch = originalFetch;
  });
});
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\call_signaling_fixes.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\calls.test.mjs =====
--- SIZE: 255 bytes ---

import { describe, it, expect } from 'vitest';

describe('calls module', () => {
  it('imports without throwing', async () => {
    const mod = await import('../modules/calls.js');
    expect(Object.keys(mod).length).toBeGreaterThan(0);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\calls.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\calls_extended.test.mjs =====
--- SIZE: 1224 bytes ---

import { describe, it, expect } from 'vitest';
import { setActiveOutgoingCall, setActiveIncomingCall, markCallAccepted, markCallDeclined, resetActiveCall } from '../modules/calls.js';
import { appState } from '../modules/core/state.js';

function friend(){ return { user_id:'u1', username:'User 1' }; }

describe('calls extended', () => {
  it('setActiveOutgoingCall sets activeCall', () => {
    setActiveOutgoingCall(friend(), 'room1');
    expect(appState.activeCall?.roomId).toBe('room1');
  });
  it('incoming/accept flow', () => {
    setActiveIncomingCall('u2','User 2','room2');
    expect(appState.activeCall?.withUserId).toBe('u2');
    markCallAccepted('room2');
    expect(appState.activeCall?.status).toBe('accepted');
  });
  it('decline flow', () => {
    setActiveIncomingCall('u3','User 3','room3');
    markCallDeclined('room3');
    // status becomes declined, then reset later; we just assert transitional state possibly
    expect(['declined', null]).toContain(appState.activeCall?.status || null);
  });
  it('resetActiveCall clears', () => {
    setActiveOutgoingCall(friend(),'room4');
    resetActiveCall('manual');
    expect(appState.activeCall).toBeNull();
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\calls_extended.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\direct_chat.test.mjs =====
--- SIZE: 1643 bytes ---

import { describe, it, expect, beforeEach } from 'vitest';
import { initDirectChatModule, selectDirectFriend, handleIncomingDirect, handleDirectCleared, bindSendDirect } from '../modules/direct_chat.js';
import { appState } from '../modules/core/state.js';

// Provide fake crypto functions (encrypt/decrypt) via dynamic module patch if needed.

beforeEach(() => {
  initDirectChatModule({ getAccountId: () => 'me', log: ()=>{} });
  const dm = document.getElementById('directMessages');
  if (dm) dm.innerHTML='';
  appState.currentDirectFriend = null;
  appState.directUnread.clear();
  appState.directSeenByFriend.clear();
});

describe('direct_chat', () => {
  it('selectDirectFriend sets friend and populates placeholder', async () => {
    await selectDirectFriend('friend1', 'Друг 1', { force:true });
    expect(appState.currentDirectFriend).toBe('friend1');
  });

  it('handleIncomingDirect increments unread when not selected', () => {
    handleIncomingDirect({ fromUserId: 'friend2', toUserId: 'me', content:'hello', id:'m1' });
    expect(appState.directUnread.get('friend2')).toBe(1);
  });

  it('handleDirectCleared resets chat', () => {
    appState.currentDirectFriend = 'friend3';
    handleDirectCleared({ userIds: ['friend3','me'] });
    expect(appState.directSeenByFriend.get('friend3')).toBeInstanceOf(Set);
  });

  it('bindSendDirect attaches listeners safely', () => {
    const btn = document.getElementById('btnDirectSend');
    bindSendDirect();
    // simulate click without current friend - should be no throw
    btn.click();
    expect(true).toBe(true);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\direct_chat.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\e2ee.test.mjs =====
--- SIZE: 1785 bytes ---

import { describe, it, expect, beforeAll, vi } from 'vitest';

// Mock api functions used by e2ee (корректный относительный путь: из __tests__ к api.js на уровне static/js)
vi.mock('../modules/../api.js', () => ({
  setMyPublicKey: async ()=>{},
  getUserPublicKey: async (id)=>({ public_key: globalThis.__peerPub || null }),
}));

import { ensureE2EEKeys, encryptForFriend, decryptFromFriend } from '../modules/e2ee.js';

// Generate a second keypair to simulate peer for decrypt tests
let peerKeypair;

async function generatePeer(){
  peerKeypair = await crypto.subtle.generateKey({ name:'ECDH', namedCurve:'P-256' }, true, ['deriveKey']);
  const raw = await crypto.subtle.exportKey('raw', peerKeypair.publicKey);
  const b64 = btoa(String.fromCharCode(...new Uint8Array(raw)));
  globalThis.__peerPub = b64;
}

describe('e2ee', () => {
  beforeAll(async () => { await generatePeer(); await ensureE2EEKeys(); });

  it('ensureE2EEKeys produces keypair', async () => {
    const kp = await ensureE2EEKeys();
    expect(kp).toHaveProperty('publicKey');
  });

  it('encryptForFriend returns null without peer key', async () => {
    globalThis.__peerPub = null;
    const ct = await encryptForFriend('friendX','hello');
    expect(ct).toBeNull();
  });

  it('encrypt/decrypt roundtrip when peer key present', async () => {
    await generatePeer();
    const ct = await encryptForFriend('friend1','secret');
    if (ct){
      const dec = await decryptFromFriend('friend1', ct);
      // May still be null if derive fails in mock; accept string equality when defined
      if (dec) expect(dec).toBe('secret'); else expect(true).toBe(true);
    } else {
      expect(ct).toBeNull();
    }
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\e2ee.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\event_bus.test.mjs =====
--- SIZE: 969 bytes ---

import { describe, it, expect } from 'vitest';
import { emit, on, once, waitFor } from '../modules/core/event_bus.js';

describe('event_bus', () => {
  it('on/emit delivers detail', async () => {
    await new Promise(resolve => {
      const off = on('sample-evt', (d) => {
        expect(d.value).toBe(42);
        off();
        resolve();
      });
      emit('sample-evt', { value: 42 });
    });
  });

  it('once unsubscribes after first emit', async () => {
    let count = 0;
    const off = once('only-once', () => { count++; });
    emit('only-once');
    emit('only-once');
    expect(count).toBe(1);
    off(); // no-op
  });

  it('waitFor resolves', async () => {
    setTimeout(() => emit('later', { ok: true }), 10);
    const data = await waitFor('later', 500);
    expect(data.ok).toBe(true);
  });

  it('waitFor timeout', async () => {
    await expect(waitFor('never', 20)).rejects.toThrow(/timeout/i);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\event_bus.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\friends_ui.test.mjs =====
--- SIZE: 1080 bytes ---

import { describe, it, expect, vi } from 'vitest';
import { initFriendsModule, loadFriends, scheduleFriendsReload } from '../modules/friends_ui.js';
import { appState } from '../modules/core/state.js';

// Mock api module functions used inside friends_ui
vi.mock('../api.js', () => ({
  notifyCall: vi.fn(async ()=>{}),
  acceptCall: vi.fn(async ()=>{}),
  declineCall: vi.fn(async ()=>{}),
  cancelCall: vi.fn(async ()=>{}),
  findUsers: vi.fn(async ()=>[]),
  listFriends: vi.fn(async ()=>[]),
  listFriendRequests: vi.fn(async ()=>[]),
  sendFriendRequest: vi.fn(async ()=>{}),
  acceptFriend: vi.fn(async ()=>{}),
}));

describe('friends_ui', () => {
  it('loadFriends populates fallback when empty', async () => {
    initFriendsModule({});
    await loadFriends();
    const fl = document.getElementById('friendsList');
    expect(fl.textContent).toMatch(/Нет друзей|Загрузка|Ошибка/i);
  });
  it('scheduleFriendsReload schedules reload', async () => {
    scheduleFriendsReload();
    expect(true).toBe(true);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\friends_ui.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\permissions.test.mjs =====
--- SIZE: 907 bytes ---

import { describe, it, expect, vi, beforeEach } from 'vitest';
import * as perms from '../modules/permissions.js';

beforeEach(()=>{
  // reset banner content
  const banner = document.getElementById('permBanner');
  if (banner){ banner.innerHTML=''; banner.style.display='none'; }
});

describe('permissions', () => {
  it('requestMicIfNeeded returns true when granted', async () => {
    const ok = await perms.requestMicIfNeeded();
    expect(ok).toBe(true);
  });
  it('ensurePushPermission returns true (granted)', async () => {
    const ok = await perms.ensurePushPermission();
    expect(ok).toBe(true);
  });
  it('updatePermBanner does not throw and manipulates DOM', async () => {
    await perms.updatePermBanner();
    const banner = document.getElementById('permBanner');
    expect(banner.style.display === '' || banner.style.display === 'none').toBe(true);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\permissions.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\push_subscribe.test.mjs =====
--- SIZE: 463 bytes ---

import { describe, it, expect } from 'vitest';

// We stub subscribePush earlier; dynamic import triggers logic.
// Because environment lacks real Push API we rely on setup mocks.

describe('push_subscribe', () => {
  it('initPush does not throw', async () => {
    const mod = await import('../modules/push_subscribe.js');
    // simulate presence of permission granted state already
    await mod.initPush();
    expect(true).toBe(true);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\push_subscribe.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\setup.mjs =====
--- SIZE: 3984 bytes ---

// Global test setup for Vitest
// Provide minimal DOM elements & stubs that modules expect.

function ensure(id){
  if (!document.getElementById(id)){
    const el = document.createElement(id === 'directMessages' ? 'div':'div');
    el.id = id;
    document.body.appendChild(el);
  }
}

[
  'permBanner','visitedRooms','directMessages','directChatTitle','directChatCard','directInput','btnDirectSend',
  'friendsList','friendRequests','friendSearchResults','friendSearch','btnFriendSearch','callContext','roomId','logs','peersGrid','stats'
].forEach(ensure);

// Basic stubs for browser APIs not present in jsdom or needing control
if (!globalThis.Notification){
  class FakeNotification { static permission = 'granted'; }
  // @ts-ignore
  globalThis.Notification = FakeNotification;
}

if (!navigator.mediaDevices){
  // @ts-ignore
  navigator.mediaDevices = { getUserMedia: async ()=>({}) };
}

if (!navigator.permissions){
  // @ts-ignore
  navigator.permissions = { query: async ()=>({ state:'granted' }) };
}

// Переопределяем fetch всегда, чтобы обрабатывать относительные URL без ошибки URL parsing в Node
// @ts-ignore
globalThis.fetch = async (url, opts)=>{
  // эмулируем минимальный Response
  return {
    ok: true,
    status: 200,
    url: typeof url === 'string' ? url : String(url),
    json: async ()=> ({ key: null }),
    text: async ()=> '',
  };
};

if (!globalThis.indexedDB){
  // Provide minimal fake indexedDB so e2ee module does not crash.
  const store = new Map();
  // @ts-ignore
  globalThis.indexedDB = {
    open(name){
      const req = { result: null, onsuccess:null, onerror:null, onupgradeneeded:null };
      setTimeout(()=>{
        const db = {
          createObjectStore(){ return {}; },
          transaction(){ return { objectStore(){ return { get(key){ const r={}; setTimeout(()=>{ r.result = store.get(key); r.onsuccess && r.onsuccess(); },0); return r; }, put(val,key){ store.set(key,val); }, }; }, oncomplete:null, onerror:null }; }, close(){} };
        req.result = db;
        if (req.onupgradeneeded) req.onupgradeneeded();
        req.onsuccess && req.onsuccess();
      },0);
      return req;
    }
  };
}

// Crypto subtle already exists in Node 18+, ensure getRandomValues
if (!globalThis.crypto?.getRandomValues){
  // @ts-ignore
  globalThis.crypto.getRandomValues = (arr)=>{
    for (let i=0;i<arr.length;i++) arr[i] = Math.floor(Math.random()*256);
    return arr;
  };
}

// localStorage polyfill for tests
if (!globalThis.localStorage){
  const mem = new Map();
  // @ts-ignore
  globalThis.localStorage = {
    getItem:k=> mem.has(k)? mem.get(k):null,
    setItem:(k,v)=>{ mem.set(k,String(v)); },
    removeItem:k=>{ mem.delete(k); },
    clear:()=> mem.clear(),
  };
}

// Stub for serviceWorker & Push related API
if (!navigator.serviceWorker){
  // @ts-ignore
  navigator.serviceWorker = {
    async getRegistration(){ return null; },
    async register(){ return { pushManager: { getSubscription: async ()=>null, subscribe: async ()=>({ endpoint:'https://x', toJSON:()=>({ keys:{ p256dh:'k', auth:'a'} }) }) } }; }
  };
}

if (!('PushManager' in globalThis)){
  // @ts-ignore
  globalThis.PushManager = function(){};
}

// Minimal stub for Audio for ringtone logic (prevent real playback attempts)
if (!globalThis.Audio){
  // @ts-ignore
  globalThis.Audio = class FakeAudio {
    constructor(src){ this.src=src; this.loop=false; this.readyState=1; this.currentTime=0; }
    load(){}
    play(){ return Promise.resolve(); }
    pause(){}
    addEventListener(ev, fn, opts){ if (ev==='loadedmetadata') setTimeout(fn,0); }
    removeEventListener(){}
    setAttribute(){}
    removeAttribute(){}
  };
}

// Expose helper to flush pending microtasks if needed
export async function tick(){ return Promise.resolve(); }

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\setup.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\state.test.mjs =====
--- SIZE: 643 bytes ---

import { describe, it, expect } from 'vitest';
import { appState, resetTransient } from '../modules/core/state.js';

describe('state', () => {
  it('appState has expected basic props', () => {
    expect(appState).toHaveProperty('special');
    expect(appState.special).toMatchObject({ active: false, playing: false, session: 0 });
  });

  it('resetTransient clears transient maps', () => {
    appState.recentOffer.set('x', 1);
    appState.pendingIncomingInvites.set('r1', Date.now());
    resetTransient();
    expect(appState.recentOffer.size).toBe(0);
    expect(appState.pendingIncomingInvites.size).toBe(0);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\state.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\stats.test.mjs =====
--- SIZE: 1200 bytes ---

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { startStatsLoop, stopStatsLoop } from '../modules/stats.js';
import { appState } from '../modules/core/state.js';

function makeFakePeer(id){
  return {
    pc: {
      async getStats(){
        return new Map([
          ['out1',{ type:'outbound-rtp', kind:'audio', bytesSent: 4000, packetsSent: 50 }],
          ['in1',{ type:'inbound-rtp', kind:'audio', bytesReceived: 8000, packetsReceived: 100, packetsLost: 2 }],
          ['rtt',{ type:'remote-inbound-rtp', kind:'audio', packetsLost: 3, roundTripTime: 0.05 }],
        ]);
      }
    }
  };
}

describe('stats', () => {
  beforeEach(() => {
    appState.rtc = { peers: new Map([['peer1', makeFakePeer('peer1')]]) };
  });
  afterEach(() => { stopStatsLoop(); appState.rtc = null; });

  it('emits samples via onSample callback', async () => {
    const got = [];
    await new Promise(resolve => {
      startStatsLoop({ intervalMs: 10, onSample: (s)=>{ got.push(s); if (got.length>=1){ resolve(); } } });
    });
    expect(got.length).toBeGreaterThan(0);
    expect(got[0].peers[0]).toHaveProperty('outAudioBitrate');
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\stats.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\visited_rooms.test.mjs =====
--- SIZE: 481 bytes ---

import { describe, it, expect } from 'vitest';
import { loadVisitedRooms } from '../modules/visited_rooms.js';

// fetch is stubbed in setup. Provide minimal element.

describe('visited_rooms', () => {
  it('loadVisitedRooms handles missing token', async () => {
    localStorage.removeItem('wc_token');
    await loadVisitedRooms();
    const el = document.getElementById('visitedRooms');
    expect(el.innerHTML).toMatch(/Войдите|историю/i);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\visited_rooms.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\voice_capture_mixer.test.mjs =====
--- SIZE: 5589 bytes ---

import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';

const savedGlobals = {};

function setupFakeAudioEnvironment(){
  savedGlobals.windowExisted = typeof global.window !== 'undefined';
  savedGlobals.window = global.window;
  if (!savedGlobals.windowExisted){
    global.window = {};
  }
  savedGlobals.windowAudioContext = global.window?.AudioContext;
  savedGlobals.windowWebkitAudioContext = global.window?.webkitAudioContext;
  savedGlobals.windowMediaStream = global.window?.MediaStream;
  savedGlobals.MediaStream = global.MediaStream;
  savedGlobals.MediaRecorder = global.MediaRecorder;
  savedGlobals.AudioContext = global.AudioContext;
  savedGlobals.webkitAudioContext = global.webkitAudioContext;

  class FakeMediaStream {
    constructor(tracks = []){
      this._tracks = tracks;
    }
    getAudioTracks(){
      return this._tracks;
    }
  }

  class FakeSource {
    constructor(stream){
      this.stream = stream;
      this._connected = false;
    }
    connect(){ this._connected = true; }
    disconnect(){ this._connected = false; }
  }

  class FakeDestination {
    constructor(){
      this.stream = new FakeMediaStream();
    }
  }

  class FakeAudioContext {
    constructor(){
      this.state = 'running';
    }
    createMediaStreamDestination(){
      return new FakeDestination();
    }
    createMediaStreamSource(stream){
      return new FakeSource(stream);
    }
    close(){
      this.state = 'closed';
      return Promise.resolve();
    }
  }

  class FakeMediaRecorder {
    constructor(stream){
      this.stream = stream;
      this.state = 'inactive';
      this._timer = null;
    }
    start(){
      this.state = 'recording';
      this._timer = setTimeout(() => {
        if (!this.ondataavailable) return;
        const data = {
          size: 3,
          arrayBuffer: () => Promise.resolve(Uint8Array.from([1, 2, 3]).buffer),
        };
        this.ondataavailable({ data });
      }, 5);
    }
    requestData(){
      if (!this.ondataavailable) return;
      const data = {
        size: 3,
        arrayBuffer: () => Promise.resolve(Uint8Array.from([4, 5, 6]).buffer),
      };
      this.ondataavailable({ data });
    }
    stop(){
      if (this._timer){
        clearTimeout(this._timer);
        this._timer = null;
      }
      this.state = 'inactive';
    }
  }

  global.MediaStream = FakeMediaStream;
  global.MediaRecorder = FakeMediaRecorder;
  global.AudioContext = FakeAudioContext;
  global.webkitAudioContext = FakeAudioContext;
  if (global.window){
    global.window.MediaStream = FakeMediaStream;
    global.window.AudioContext = FakeAudioContext;
    global.window.webkitAudioContext = FakeAudioContext;
  }
}

function restoreAudioEnvironment(){
  if (savedGlobals.MediaStream === undefined){
    delete global.MediaStream;
    if (global.window) delete global.window.MediaStream;
  } else {
    global.MediaStream = savedGlobals.MediaStream;
    if (global.window) global.window.MediaStream = savedGlobals.windowMediaStream;
  }
  if (savedGlobals.MediaRecorder === undefined){
    delete global.MediaRecorder;
  } else {
    global.MediaRecorder = savedGlobals.MediaRecorder;
  }
  if (savedGlobals.AudioContext === undefined){
    delete global.AudioContext;
  } else {
    global.AudioContext = savedGlobals.AudioContext;
  }
  if (savedGlobals.webkitAudioContext === undefined){
    delete global.webkitAudioContext;
  } else {
    global.webkitAudioContext = savedGlobals.webkitAudioContext;
  }
  if (global.window){
    if (savedGlobals.windowAudioContext === undefined){
      delete global.window.AudioContext;
    } else {
      global.window.AudioContext = savedGlobals.windowAudioContext;
    }
    if (savedGlobals.windowWebkitAudioContext === undefined){
      delete global.window.webkitAudioContext;
    } else {
      global.window.webkitAudioContext = savedGlobals.windowWebkitAudioContext;
    }
    if (savedGlobals.windowMediaStream === undefined){
      delete global.window.MediaStream;
    } else {
      global.window.MediaStream = savedGlobals.windowMediaStream;
    }
  }
  if (!savedGlobals.windowExisted){
    delete global.window;
  } else {
    global.window = savedGlobals.window;
  }
}

describe('VoiceCaptureMixer', () => {
  let VoiceCaptureMixer;
  let mixer;
  let chunks;
  let track;
  let localStream;

  beforeEach(async () => {
    vi.useFakeTimers();
    setupFakeAudioEnvironment();
    chunks = [];
    track = { id: 'track-1', readyState: 'live', enabled: true };
    localStream = {
      getAudioTracks: () => [track],
    };
    ({ VoiceCaptureMixer } = await import('../modules/voice/capture_mixer.js'));
    mixer = new VoiceCaptureMixer({
      getLocalStream: () => localStream,
      getPeers: () => new Map(),
      chunkMs: 10,
      onChunk: (bytes) => chunks.push(bytes),
      onLog: () => {},
    });
  });

  afterEach(() => {
    try { mixer?.stop(); } catch {}
    restoreAudioEnvironment();
    vi.useRealTimers();
  });

  it('emits chunks after restart with the same tracks', async () => {
    mixer.start();
    await vi.advanceTimersByTimeAsync(6);
    await Promise.resolve();
    expect(chunks.length).toBeGreaterThan(0);

    mixer.stop();
    await Promise.resolve();

    mixer.start();
    await vi.advanceTimersByTimeAsync(6);
    await Promise.resolve();

    expect(chunks.length).toBeGreaterThan(1);
  });
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\__tests__\voice_capture_mixer.test.mjs =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\api.js =====
--- SIZE: 9699 bytes ---

// api.js — API glue (исправлено: верный путь ICE, верный путь WS)
const base = "";

/** Получаем ICE (STUN/TURN) с вашего API */
export async function getIceServers(){
  // ваш сервер, судя по логам, обслуживает ICE тут:
  // GET /api/v1/webrtc/ice-servers  -> { iceServers:[...] }
  const r = await fetch(`${base}/api/v1/webrtc/ice-servers`, { credentials: 'include' });
  if (!r.ok) throw new Error(`ICE ${r.status}`);
  const json = await r.json();
  // Небольшой sanity-check
  if (!json || !Array.isArray(json.iceServers)) {
    throw new Error("Invalid ICE response");
  }
  return json;
}

/**
 * Открываем WS на корректный серверный путь
 * Сервер логировал: "WebSocket /ws/rooms/{room}?token=..."
 */
export function buildWs(roomId, token){
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  // Основной путь — /ws/rooms/{room}
  const url1 = new URL(`${proto}://${location.host}/ws/rooms/${encodeURIComponent(roomId)}`);
  if (token) url1.searchParams.set('token', token);

  const ws = new WebSocket(url1.toString());
  // Для удобной диагностики
  try { ws.__debug_url = url1.toString(); } catch {}
  return ws;
}

// (опционально) login/register, если используются страницы аутентификации
export async function login(email, password){
  const r = await fetch(`${base}/api/v1/auth/login`, {
    method: 'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ email, password })
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}
export async function register(email, username, password, secret){
  const payload = { email, username, password, secret };
  const r = await fetch(`${base}/api/v1/auth/register`, {
    method: 'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify(payload)
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

function authHeaders(){
  const t = localStorage.getItem('wc_token');
  return t ? { Authorization: `Bearer ${t}` } : {};
}

// Friends
export async function listFriends(){
  const r = await fetch(`${base}/api/v1/friends/`, { headers: { ...authHeaders() } });
  if (!r.ok){
    let msg = `Friends ${r.status}`;
    try { msg += ' ' + (await r.text()); } catch{}
    if (r.status === 401) msg = 'Не авторизован (401) — войдите заново';
    throw new Error(msg);
  }
  return await r.json();
}

export async function listFriendRequests(){
  const r = await fetch(`${base}/api/v1/friends/requests`, { headers: { ...authHeaders() } });
  if (!r.ok){
    let msg = `FriendRequests ${r.status}`;
    try { msg += ' ' + (await r.text()); } catch{}
    if (r.status === 401) msg = 'Не авторизован (401) — войдите заново';
    throw new Error(msg);
  }
  return await r.json();
}

export async function sendFriendRequest(userId){
  const r = await fetch(`${base}/api/v1/friends/request`, {
    method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify({ user_id: userId })
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function acceptFriend(userId){
  const r = await fetch(`${base}/api/v1/friends/${encodeURIComponent(userId)}/accept`, {
    method: 'POST', headers: { ...authHeaders() }
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

// Push
export async function subscribePush(subscription){
  const r = await fetch(`${base}/api/v1/push/subscribe`, {
    method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify(subscription)
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function notifyCall(toUserId, roomId){
  const r = await fetch(`${base}/api/v1/push/notify-call`, {
    method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify({ to_user_id: toUserId, room_id: roomId })
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function acceptCall(otherUserId, roomId){
  const r = await fetch(`${base}/api/v1/push/call/accept`, {
    method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify({ other_user_id: otherUserId, room_id: roomId })
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function declineCall(otherUserId, roomId){
  const r = await fetch(`${base}/api/v1/push/call/decline`, {
    method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify({ other_user_id: otherUserId, room_id: roomId })
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function cancelCall(otherUserId, roomId){
  const r = await fetch(`${base}/api/v1/push/call/cancel`, {
    method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify({ other_user_id: otherUserId, room_id: roomId })
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function findUsers(q){
  const url = `${base}/api/v1/users/find?` + new URLSearchParams({ q });
  const r = await fetch(url, { headers: { ...authHeaders() } });
  if (!r.ok){
    let bodyTxt = '';
    try { bodyTxt = await r.text(); } catch {}
    let msg;
    if (r.status === 401) msg = 'Поиск: не авторизован (401) — выполните вход.';
    else if (r.status === 422) msg = 'Поиск: некорректный запрос (422) — проверьте длину запроса.';
    else msg = `Поиск: ошибка ${r.status}${bodyTxt?(' '+bodyTxt):''}`;
    const err = new Error(msg);
    try { err.status = r.status; err.url = url; } catch {}
    throw err;
  }
  return await r.json();
}

// Auth: текущий пользователь
export async function getMe(){
  const r = await fetch(`${base}/api/v1/auth/me`, { headers: { ...authHeaders() } });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function updateProfile({ email, username }){
  const payload = {};
  if (email) payload.email = email;
  if (username) payload.username = username;
  const r = await fetch(`${base}/api/v1/auth/me`, {
    method: 'PATCH',
    headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify(payload)
  });
  if (!r.ok) throw new Error(await r.text());
  return await r.json();
}

export async function changePassword(old_password, new_password){
  const r = await fetch(`${base}/api/v1/auth/me/password`, {
    method: 'POST',
    headers: { 'content-type': 'application/json', ...authHeaders() },
    body: JSON.stringify({ old_password, new_password })
  });
  if (!r.ok) throw new Error(await r.text());
  return true;
}

// E2EE public key endpoints
export async function setMyPublicKey(publicKeyStr){
  try {
    // Избегаем лишних POST, если ключ тот же в течение 12h
    const prev = localStorage.getItem('wc_my_pubkey');
    const prevTs = Number(localStorage.getItem('wc_my_pubkey_ts')||'0');
    const same = prev && prev === publicKeyStr && (Date.now() - prevTs) < 1000*60*60*12;
    if (same) return { ok:true, cached:true };
  } catch {}
  const r = await fetch(`${base}/api/v1/direct/me/public_key`, { method: 'POST', headers: { 'content-type': 'application/json', ...authHeaders() }, body: JSON.stringify({ public_key: publicKeyStr }) });
  if (!r.ok) throw new Error(await r.text());
  const json = await r.json();
  try { localStorage.setItem('wc_my_pubkey', publicKeyStr); localStorage.setItem('wc_my_pubkey_ts', String(Date.now())); } catch {}
  return json;
}

export async function getUserPublicKey(userId){
  // Кэширование на 10 минут + дедупликация параллельных запросов
  if (!getUserPublicKey._cache) { getUserPublicKey._cache = new Map(); }
  if (!getUserPublicKey._inflight) { getUserPublicKey._inflight = new Map(); }
  const key = String(userId);
  const cached = getUserPublicKey._cache.get(key);
  if (cached && (Date.now() - cached.ts) < 1000*60*10) {
    return cached.value;
  }
  if (getUserPublicKey._inflight.has(key)) {
    return await getUserPublicKey._inflight.get(key);
  }
  const p = (async ()=>{
    const r = await fetch(`${base}/api/v1/users/${encodeURIComponent(userId)}/public_key`, { headers: { ...authHeaders() } });
    if (!r.ok) throw new Error(await r.text());
    const json = await r.json();
    getUserPublicKey._cache.set(key, { ts: Date.now(), value: json });
    return json;
  })();
  getUserPublicKey._inflight.set(key, p);
  try { return await p; } finally { getUserPublicKey._inflight.delete(key); }
}

// Backwards-compatibility: expose functions on window for clients that for some reason
// load a cached or transformed module without named exports. This is a safe short-term
// workaround to restore functionality while debugging deployment/caching issues.
try {
  if (typeof window !== 'undefined') {
    window.getUserPublicKey = getUserPublicKey;
    window.setMyPublicKey = setMyPublicKey;
  }
} catch (e) { /* ignore */ }

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\api.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\auth.js =====
--- SIZE: 7058 bytes ---

// auth.js — регистрация/вход
import { login, register } from './api.js';

const els = {
  tabLogin: document.getElementById('tabLogin'),
  tabRegister: document.getElementById('tabRegister'),
  formLogin: document.getElementById('formLogin'),
  formRegister: document.getElementById('formRegister'),
  loginEmail: document.getElementById('loginEmail'),
  loginPassword: document.getElementById('loginPassword'),
  regEmail: document.getElementById('regEmail'),
  regUsername: document.getElementById('regUsername'),
  regPassword: document.getElementById('regPassword'),
  regSecret: document.getElementById('regSecret'),
  btnDoLogin: document.getElementById('btnDoLogin'),
  btnDoRegister: document.getElementById('btnDoRegister'),
  log: document.getElementById('authLog'),
};

function clearFieldErrors(){
  [els.regEmail, els.regUsername, els.regPassword, els.regSecret, els.loginEmail, els.loginPassword].forEach(i=>{
    if (!i) return;
    i.classList.remove('input-error');
  });
}

function fieldError(el, msg){
  if (el) el.classList.add('input-error');
  log(msg);
}

function log(msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  els.log.appendChild(node);
  els.log.scrollTop = els.log.scrollHeight;
}

function setTab(isLogin){
  els.tabLogin.classList.toggle('active', isLogin);
  els.tabRegister.classList.toggle('active', !isLogin);
  els.formLogin.style.display = isLogin ? '' : 'none';
  els.formRegister.style.display = isLogin ? 'none' : '';
}

function getRedirect(){
  const url = new URL(location.href);
  return url.searchParams.get('redirect') || '/call';
}

function applyPostLogin(token){
  localStorage.setItem('wc_token', token);
  localStorage.setItem('wc_seen', '1');
  try{ const payload = JSON.parse(atob(token.split('.')[1])); localStorage.setItem('wc_user', payload.sub || ''); }catch{}
  // Email может понадобиться для спец-логики в UI
  try { const email = (document.getElementById('loginEmail')?.value || '').trim(); if (email) localStorage.setItem('wc_email', email); } catch {}
  const url = new URL(location.href);
  const redirect = getRedirect();
  const room = url.searchParams.get('room');
  if (room) {
    // поддержим /call/{room}
    if (redirect.startsWith('/call')) {
      location.href = `/call/${encodeURIComponent(room)}`;
      return;
    }
  }
  location.href = redirect;
}

async function doLogin(){
  clearFieldErrors();
  const email = (els.loginEmail.value || '').trim();
  const password = els.loginPassword.value || '';
  if (!email) return fieldError(els.loginEmail, 'Укажите email.');
  if (!password) return fieldError(els.loginPassword, 'Введите пароль.');

  // Disable buttons while request is running
  els.btnDoLogin.disabled = true;
  try{
    const data = await login(email, password);
    applyPostLogin(data.access_token);
  }catch(e){
    // e may be an Error with message body or a thrown object; normalize to string
    let raw = '';
    try { raw = typeof e === 'string' ? e : (e?.message || JSON.stringify(e)); } catch { raw = String(e); }
    // Try parse JSON body
    try{
      if (raw && raw.trim().startsWith('{')){
        const j = JSON.parse(raw);
        if (j.detail && typeof j.detail === 'string') raw = j.detail;
      }
    }catch{}

    // Map known server messages to field-level errors
    if (/Неверный email или пароль/i.test(raw) || /invalid credentials/i.test(raw)){
      fieldError(els.loginEmail, 'Неверный email или пароль.');
      fieldError(els.loginPassword, 'Неверный email или пароль.');
    } else {
      // Fallback: show raw message in log for debugging
      log(raw || 'Ошибка при входе');
    }
  }finally{
    els.btnDoLogin.disabled = false;
  }
}

async function doRegister(){
  clearFieldErrors();
  const email = els.regEmail.value.trim();
  const username = els.regUsername.value.trim();
  const password = els.regPassword.value;
  const secret = (els.regSecret?.value || '').trim();

  // Клиентская валидация
  if (!email) return fieldError(els.regEmail, 'Укажите email.');
  // Простая email-проверка
  if (!/^[^@\s]+@[^@\s]+\.[^@\s]+$/.test(email)) return fieldError(els.regEmail, 'Некорректный email.');
  if (!username) return fieldError(els.regUsername, 'Укажите имя пользователя.');
  if (username.length < 3) return fieldError(els.regUsername, 'Имя пользователя слишком короткое (мин 3).');
  if (!password) return fieldError(els.regPassword, 'Введите пароль.');
  if (password.length < 6) return fieldError(els.regPassword, 'Пароль слишком короткий (мин 6).');
  if (!secret) return fieldError(els.regSecret, 'Введите секретный код.');

  log('Отправка запроса регистрации...');
  try{
    await register(email, username, password, secret);
  try { localStorage.setItem('wc_username', username); } catch {}
  try { localStorage.setItem('wc_email', email); } catch {}
    log('Регистрация успешна. Выполняем вход...');
    const data = await login(email, password);
    applyPostLogin(data.access_token);
  }catch(e){
    // Парсим возможный JSON от сервера
    let raw = String(e);
    try {
      if (raw.startsWith('{')) {
        const j = JSON.parse(raw);
        if (j.detail) {
          if (Array.isArray(j.detail)) {
            j.detail.forEach(d => log(`Ошибка: ${d.loc?.slice(-1)[0]||''} - ${d.msg}`));
            return;
          } else if (typeof j.detail === 'string') {
            raw = j.detail;
          }
        }
      }
    } catch {}
    if (/invalid registration secret/i.test(raw)) {
      fieldError(els.regSecret, 'Неверный секретный код.');
    } else if (/username/i.test(raw) && /exists|already/i.test(raw)) {
      fieldError(els.regUsername, 'Имя уже занято.');
    } else if (/email/i.test(raw) && /exists|already/i.test(raw)) {
      fieldError(els.regEmail, 'Email уже зарегистрирован.');
    } else {
      log(raw);
    }
  }
}

// Инициализация
(function init(){
  const seen = localStorage.getItem('wc_seen') === '1';
  setTab(seen); // если уже были — показываем логин

  els.tabLogin.addEventListener('click', ()=> setTab(true));
  els.tabRegister.addEventListener('click', ()=> setTab(false));
  els.btnDoLogin.addEventListener('click', doLogin);
  els.btnDoRegister.addEventListener('click', doRegister);
})();

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\auth.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\boot.js =====
--- SIZE: 907 bytes ---

// boot.js — загрузчик бандла и регистрации SW (замена inline скриптов для CSP)
(async () => {
  try {
    const resp = await fetch('/static/js/bundle.js', { method: 'HEAD' });
    if (resp.ok) {
      const s = document.createElement('script');
      s.type = 'module';
      s.src = '/static/js/bundle.js';
      document.body.appendChild(s);
    } else {
      const s2 = document.createElement('script');
      s2.type = 'module';
      s2.src = '/static/js/main.js?v=2';
      document.body.appendChild(s2);
    }
  } catch (e) {
    const s2 = document.createElement('script');
    s2.type = 'module';
    s2.src = '/static/js/main.js?v=2';
    document.body.appendChild(s2);
  }

  try {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/static/sw.js').catch(() => {});
    }
  } catch {}
})();

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\boot.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\debug_panel.js =====
--- SIZE: 205 bytes ---

/**
 * Debug Panel для мониторинга Friends WebSocket и звонков
 */

// Debug panel отключён в продакшен-сборке.
try { window.debugPanel = null; } catch {}
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\debug_panel.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\fx_web.js =====
--- SIZE: 5326 bytes ---

// fx_web.js - Futuristic spiderweb / particle connection cursor effect
// Lightweight, no external deps. Uses off-main scheduling via requestAnimationFrame.
// Can be disabled by adding data-no-webfx to <body>.

(function(){
  if (typeof window === 'undefined') return;
  const body = document.body;
  if (!body || body.hasAttribute('data-no-webfx')) return;

  const canvas = document.createElement('canvas');
  canvas.id = 'fx-web-canvas';
  canvas.style.cssText = 'position:fixed;inset:0;pointer-events:none;z-index:0;mix-blend-mode:screen;';
  document.body.appendChild(canvas);
  const ctx = canvas.getContext('2d');

  let w = canvas.width = window.innerWidth;
  let h = canvas.height = window.innerHeight;
  window.addEventListener('resize', ()=>{ w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; });

  // Config
  const MAX_POINTS = 160;              // base particle count
  const MOUSE_PULL = 0.12;             // attraction toward cursor
  const SPRING = 0.025;                // inter-particle soft spring when close
  const FRICTION = 0.96;               // velocity damping
  const LINK_DIST = 170;               // base distance for connecting lines
  const CURSOR_FIELD = 260;            // radius of strong cursor influence
  const GLOW_COLOR_1 = 'rgba(124,58,237,'; // violet base
  const GLOW_COLOR_2 = 'rgba(6,182,212,';  // cyan base

  const mouse = { x: w/2, y: h/2, moving:false };
  let lastMove = performance.now();
  window.addEventListener('pointermove', e=>{ mouse.x = e.clientX; mouse.y = e.clientY; mouse.moving = true; lastMove = performance.now(); });
  window.addEventListener('pointerdown', e=>{ mouse.x = e.clientX; mouse.y = e.clientY; burst(mouse.x, mouse.y); });

  // Particle model
  class P{ constructor(){ this.reset(); } reset(){ this.x=Math.random()*w; this.y=Math.random()*h; this.vx=(Math.random()*2-1)*0.2; this.vy=(Math.random()*2-1)*0.2; this.fx=0; this.fy=0; this.sz=1+Math.random()*2; this.life= 4000 + Math.random()*6000; this.birth=performance.now(); } step(dt){ // mild wander
      const age = performance.now() - this.birth; if (age>this.life){ this.reset(); return; }
      // Attraction to cursor
      const dx = mouse.x - this.x; const dy = mouse.y - this.y; const dist = Math.hypot(dx,dy)||1;
      if (dist < CURSOR_FIELD){ const m = (1 - dist/CURSOR_FIELD); this.vx += dx/dist * MOUSE_PULL * m; this.vy += dy/dist * MOUSE_PULL * m; }
      // Soft confinement
      if (this.x<0||this.x>w) this.vx*=-1, this.x=Math.max(0,Math.min(w,this.x));
      if (this.y<0||this.y>h) this.vy*=-1, this.y=Math.max(0,Math.min(h,this.y));
      // Velocity & position
      this.vx*=FRICTION; this.vy*=FRICTION; this.x+=this.vx; this.y+=this.vy; }
  }

  const pts = Array.from({length:MAX_POINTS}, ()=> new P());

  function burst(x,y){
    for(let i=0;i<14;i++){
      const p = pts[(Math.random()*pts.length)|0];
      const a = Math.random()*Math.PI*2; const s = 3+Math.random()*4;
      p.vx += Math.cos(a)*s; p.vy += Math.sin(a)*s;
    }
  }

  // Connection pass
  function draw(){
    ctx.clearRect(0,0,w,h);
    // subtle background haze gradient
    const g = ctx.createRadialGradient(mouse.x, mouse.y, 40, mouse.x, mouse.y, Math.min(w,h)*0.8);
    g.addColorStop(0, 'rgba(124,58,237,0.05)');
    g.addColorStop(1, 'rgba(6,182,212,0.02)');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

    // Update + draw particles
    for (const p of pts){ p.step(); }

    // Connections (optimized by only checking next few)
    for (let i=0;i<pts.length;i++){
      const a = pts[i];
      for (let j=i+1;j<pts.length;j++){
        const b = pts[j];
        const dx = a.x-b.x; const dy = a.y-b.y; const d2 = dx*dx+dy*dy;
        if (d2 < LINK_DIST*LINK_DIST){
          const d = Math.sqrt(d2);
          // spring force
          const f = (1 - d/LINK_DIST) * SPRING;
          const nx = dx/d || 0; const ny = dy/d || 0;
          a.vx += nx * f; a.vy += ny * f; b.vx -= nx * f; b.vy -= ny * f;
          const alpha = 0.12 * (1 - d/LINK_DIST);
          const mix = ( (a.x+b.x)*0.5 / w );
          ctx.strokeStyle = (mix<0.5?GLOW_COLOR_1:GLOW_COLOR_2) + alpha + ')';
          ctx.lineWidth = 1.1;
          ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke();
          if (alpha>0.05){
            // luminous midpoint node
            const mx = (a.x+b.x)/2, my=(a.y+b.y)/2;
            const r = 2 + 8*alpha;
            const rg = ctx.createRadialGradient(mx,my,0,mx,my,r);
            rg.addColorStop(0,(mix<0.5?GLOW_COLOR_1:GLOW_COLOR_2)+ (0.8*alpha)+')');
            rg.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle = rg; ctx.beginPath(); ctx.arc(mx,my,r,0,Math.PI*2); ctx.fill();
          }
        }
      }
    }

    // Foreground particles
    for (const p of pts){
      const ageRatio = (performance.now()-p.birth)/p.life;
      const a = 0.25 * (1 - ageRatio);
      ctx.fillStyle = (p.x/w <0.5?GLOW_COLOR_1:GLOW_COLOR_2) + a + ')';
      ctx.beginPath(); ctx.arc(p.x,p.y,p.sz,0,Math.PI*2); ctx.fill();
    }

    // fade mouse.moving flag
    if (performance.now()-lastMove > 1400) mouse.moving=false;
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\fx_web.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\main.js =====
--- SIZE: 2058 bytes ---

// main.js (фасад)
// Вся прежняя логика перенесена в modules/*. Здесь только:
// 1. Быстрый auth guard (редирект если нет токена)
// 2. Запуск appInit()
// 3. Обработка кастомного события wc:join-room (из истории посещённых комнат)

// ===== RUNTIME AUTH GUARD (минимальный) =====
try {
  const rawToken = localStorage.getItem('wc_token');
  let needAuth = !rawToken;
  if (rawToken) {
    try {
      const payload = JSON.parse(atob(rawToken.split('.')[1]));
      const now = Math.floor(Date.now()/1000);
      if (payload.exp && now >= payload.exp) needAuth = true;
    } catch { needAuth = true; }
  }
  if (needAuth) {
    const url = new URL(location.href);
    const params = new URLSearchParams({ redirect: '/call' });
    const room = url.searchParams.get('room');
    if (room) params.set('room', room);
    location.replace(`/auth?${params.toString()}`);
    throw new Error('__halt_main_init');
  }
} catch (e) {
  if (e?.message === '__halt_main_init') {
    // Прерываем дальнейшую инициализацию — пользователь отправлен на /auth
  } else {
    // Не блокируем работу при непредвиденной ошибке
  }
}

import { appInit, connectRoom, unlockAudioPlayback } from './modules/core/app_init.js';
import { bus } from './modules/core/event_bus.js';

// Запуск приложения (инициализация модулей, подписки и т.д.)
appInit();

// Подключение к комнате по событию из visited_rooms.js (через шину)
bus.on('join-room', () => {
  try { unlockAudioPlayback(); connectRoom(); } catch {}
});

// Ничего не экспортируем в window — если потребуется совместимость с legacy-кодом,
// можно добавить адаптеры здесь.

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\main.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\call_audio.js =====
--- SIZE: 2644 bytes ---

// call_audio.js — генерация простых рингтонов через Web Audio API
// incoming: две короткие посылки 440 Гц; outgoing: одиночный треугольный импульс 620 Гц

let audioCtx = null;
function getCtx(){
  if (!audioCtx){
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {}
  }
  return audioCtx;
}

let incomingOsc = [];
let outgoingOsc = [];
let incomingTimer = null;
let outgoingTimer = null;

function stopGroup(arr, kind){
  for (const o of arr){ try { o.stop(); } catch {} }
  arr.length = 0;
  if (kind==='in' && incomingTimer){ clearInterval(incomingTimer); incomingTimer=null; }
  if (kind==='out' && outgoingTimer){ clearInterval(outgoingTimer); outgoingTimer=null; }
}

export function stopAllRings(){
  stopGroup(incomingOsc,'in');
  stopGroup(outgoingOsc,'out');
}

export function startIncomingRing(){
  if (incomingTimer || incomingOsc.length) return;
  const ctx = getCtx(); if (!ctx) return;
  const pattern = ()=>{
    for (let i=0;i<2;i++){
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type='sine';
      osc.frequency.value = 440;
      const t0 = ctx.currentTime + i*0.55;
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(0.25, t0+0.05);
      gain.gain.linearRampToValueAtTime(0, t0+0.5);
      osc.connect(gain).connect(ctx.destination);
      osc.start(t0);
      osc.stop(t0+0.55);
      incomingOsc.push(osc);
    }
  };
  pattern();
  incomingTimer = setInterval(()=>{ cleanup(incomingOsc); pattern(); }, 2000);
}

export function startOutgoingRing(){
  if (outgoingTimer || outgoingOsc.length) return;
  const ctx = getCtx(); if (!ctx) return;
  const pattern = ()=>{
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    osc.type='triangle';
    osc.frequency.value = 620;
    const t0 = ctx.currentTime;
    gain.gain.setValueAtTime(0, t0);
    gain.gain.linearRampToValueAtTime(0.22, t0+0.05);
    gain.gain.linearRampToValueAtTime(0, t0+0.55);
    osc.connect(gain).connect(ctx.destination);
    osc.start(t0);
    osc.stop(t0+0.6);
    outgoingOsc.push(osc);
  };
  pattern();
  outgoingTimer = setInterval(()=>{ cleanup(outgoingOsc); pattern(); }, 1500);
}

function cleanup(arr){
  if (arr.length > 50) arr.splice(0); // периодическая очистка для безопасности
}

export function resumeAudio(){
  const c = getCtx();
  if (c && c.state === 'suspended'){ c.resume().catch(()=>{}); }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\call_audio.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\call_ui.js =====
--- SIZE: 9020 bytes ---

import { els, showToast } from './core/dom.js';

// Новый UI слой для звонков. Отвечает за модалки, баннер статуса и уведомления.
/** @typedef {import('./calls_signaling.js').UICallState} UICallState */

const PHASE_ICONS = Object.freeze({
  idle: '📞',
  dialing: '⏳',
  outgoing_ringing: '📤',
  incoming_ringing: '📥',
  connecting: '🔄',
  active: '✅',
  ended: '⚠️',
});

let _handlers = { accept: null, decline: null, cancel: null, hangup: null };
let _lastClick = 0;
let _lastPhase = 'idle';
let _shellPrepared = false;

function actionGuard(fn) {
  const now = Date.now();
  if (now - _lastClick < 250) return; // простая защита от двойных кликов
  _lastClick = now;
  try { fn(); } catch (e) { console.warn('[call-ui] action error', e); }
}

function prepareShell() {
  if (_shellPrepared) return;
  _shellPrepared = true;
  if (els.callContext) {
    els.callContext.classList.add('call-banner');
    els.callContext.setAttribute('aria-live', 'polite');
    els.callContext.textContent = '';
    els.callContext.style.display = 'none';
  }
}

function ensureModal(id, variant) {
  let modal = document.getElementById(id);
  if (modal && !modal.classList.contains('call-modal')) {
    try { modal.remove(); } catch {}
    modal = null;
  }
  if (modal) return modal;
  modal = document.createElement('div');
  modal.id = id;
  modal.className = `call-modal call-modal--${variant} is-hidden`;
  modal.setAttribute('role', 'dialog');
  modal.setAttribute('aria-modal', 'true');

  if (variant === 'incoming') {
    modal.innerHTML = `
      <div class="call-modal__body">
        <div class="call-modal__avatar call-modal__avatar--incoming"><span class="call-modal__avatar-icon">📞</span></div>
        <h3 class="call-modal__title">Входящий звонок</h3>
        <p class="call-modal__name" id="incomingCallFrom"></p>
        <p class="call-modal__status" id="incomingCallStatus"></p>
        <div class="call-modal__actions">
          <button id="btnCallAccept" class="btn btn-success">Принять</button>
          <button id="btnCallDecline" class="btn btn-ghost">Отклонить</button>
        </div>
      </div>`;
  } else {
    modal.innerHTML = `
      <div class="call-modal__body">
        <div class="call-modal__avatar call-modal__avatar--outgoing"><span class="call-modal__avatar-icon">📤</span></div>
        <h3 class="call-modal__title">Соединяем…</h3>
        <p class="call-modal__name" id="outgoingCallTo"></p>
        <p class="call-modal__status" id="outgoingCallStatus"></p>
        <div class="call-modal__actions call-modal__actions--single">
          <button id="btnOutgoingCancel" class="btn btn-secondary">Отменить</button>
        </div>
      </div>`;
  }

  document.body.appendChild(modal);
  bindModalButtons();
  return modal;
}

function showIncoming(name, statusText) {
  const modal = ensureModal('incomingCallModal', 'incoming');
  const from = modal.querySelector('#incomingCallFrom');
  const status = modal.querySelector('#incomingCallStatus');
  if (from) from.textContent = name || 'Пользователь';
  if (status) status.textContent = statusText || 'Звонит…';
  modal.classList.remove('is-hidden');
  modal.setAttribute('aria-hidden', 'false');
}

function hideIncoming() {
  const modal = document.getElementById('incomingCallModal');
  if (!modal) return;
  modal.classList.add('is-hidden');
  modal.setAttribute('aria-hidden', 'true');
}

function showOutgoing(peer, statusText) {
  const modal = ensureModal('outgoingCallModal', 'outgoing');
  const toEl = modal.querySelector('#outgoingCallTo');
  const status = modal.querySelector('#outgoingCallStatus');
  if (toEl) toEl.textContent = peer || '';
  if (status) status.textContent = statusText || 'Соединение…';
  modal.classList.remove('is-hidden');
  modal.setAttribute('aria-hidden', 'false');
}

function hideOutgoing() {
  const modal = document.getElementById('outgoingCallModal');
  if (!modal) return;
  modal.classList.add('is-hidden');
  modal.setAttribute('aria-hidden', 'true');
}

function bindModalButtons() {
  const accept = document.getElementById('btnCallAccept');
  const decline = document.getElementById('btnCallDecline');
  const cancel = document.getElementById('btnOutgoingCancel');
  if (accept && !accept.__bound) {
    accept.__bound = true;
    accept.addEventListener('click', () => actionGuard(() => _handlers.accept && _handlers.accept()));
  }
  if (decline && !decline.__bound) {
    decline.__bound = true;
    decline.addEventListener('click', () => actionGuard(() => _handlers.decline && _handlers.decline()));
  }
  if (cancel && !cancel.__bound) {
    cancel.__bound = true;
    cancel.addEventListener('click', () => actionGuard(() => _handlers.cancel && _handlers.cancel()));
  }
}

function updateBanner(phase, text) {
  if (!els.callContext) return;
  if (!text) {
    els.callContext.textContent = '';
    els.callContext.style.display = 'none';
    els.callContext.removeAttribute('data-phase');
    return;
  }
  const icon = PHASE_ICONS[phase] || PHASE_ICONS.idle;
  els.callContext.innerHTML = `<span class="call-banner__icon">${icon}</span><span class="call-banner__text">${text}</span>`;
  els.callContext.dataset.phase = phase;
  els.callContext.style.display = '';
}

function render(state) {
  prepareShell();
  /** @type {UICallState} */
  const s = state || { phase: 'idle' };
  const peer = s.otherUsername || s.otherUserId || '';
  let text = '';
  switch (s.phase) {
    case 'idle':
      text = '';
      break;
    case 'dialing':
      text = peer ? `Соединяемся с ${peer}…` : 'Подготавливаем соединение…';
      break;
    case 'outgoing_ringing':
      text = peer ? `Звоним ${peer}…` : 'Звоним…';
      break;
    case 'incoming_ringing':
      text = peer ? `Входящий звонок от ${peer}` : 'Входящий звонок';
      break;
    case 'connecting':
      text = peer ? `Подключение к ${peer}…` : 'Подключение…';
      break;
    case 'active':
      text = peer ? `В разговоре с ${peer}` : 'Звонок активен';
      break;
    case 'ended':
      text = formatEndedReason(s);
      break;
    default:
      text = s.phase;
  }
  updateBanner(s.phase, text);

  if (s.phase === 'incoming_ringing') {
    hideOutgoing();
    showIncoming(peer, 'Звонит…');
  } else if (s.phase === 'dialing') {
    hideIncoming();
    showOutgoing(peer, 'Соединяем…');
  } else if (s.phase === 'outgoing_ringing') {
    hideIncoming();
    showOutgoing(peer, 'Ожидаем ответ…');
  } else if (s.phase === 'connecting') {
    if (s.incoming) {
      hideOutgoing();
      showIncoming(peer, 'Подключаем…');
    } else {
      hideIncoming();
      showOutgoing(peer, 'Подключаем…');
    }
  } else {
    hideIncoming();
    hideOutgoing();
  }

  if (s.phase === 'ended' && _lastPhase !== 'ended') {
    const reasonText = formatEndedReason(s);
    showToast(reasonText, { type: 'info', timeoutMs: 3200 });
  } else if (s.phase === 'active' && _lastPhase !== 'active') {
    const successText = peer ? `Соединение с ${peer} установлено` : 'Соединение установлено';
    showToast(successText, { type: 'success', timeoutMs: 2400 });
  }
  _lastPhase = s.phase;
}

function formatEndedReason(s) {
  const r = s.reason || s.finalReason || '';
  switch (r) {
    case 'declined':
      return 'Звонок отклонён';
    case 'cancel':
      return 'Звонок отменён';
    case 'timeout':
      return 'Не удалось дозвониться (таймаут)';
    case 'unavailable':
      return 'Пользователь недоступен';
    case 'hangup':
      return 'Вы завершили звонок';
    case 'leave':
      return 'Собеседник покинул звонок';
    case 'disconnect':
      return 'Связь потеряна';
    case 'failed':
      return 'Не удалось установить соединение';
    default:
      return 'Звонок завершён';
  }
}

export function updateCallUI(state) {
  try { render(state); } catch (e) { console.warn('[call-ui] render error', e); }
}

export function bindActions(onAccept, onDecline, onCancel, onHangup) {
  _handlers.accept = onAccept;
  _handlers.decline = onDecline;
  _handlers.cancel = onCancel;
  _handlers.hangup = onHangup;
  bindModalButtons();
}

export function clearCallUI() {
  updateCallUI({ phase: 'idle' });
}

export { hideIncoming, hideOutgoing };

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\call_ui.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\calls.js =====
--- SIZE: 21761 bytes ---

// @ts-check
// modules/calls.js
// Управление состоянием эфемерных звонков + (позже) спец-рингтон.
// Минимальная изоляция: не тянем напрямую огромный main.js.

import { appState } from './core/state.js';

// Декларация кастомного флага чтобы TS не ругался (jsdoc):
/** @typedef {Window & { __NEW_CALL_SIGNALING__?: boolean }} WindowWithCallFlag */
/** @type {WindowWithCallFlag} */
// @ts-ignore
const _w = window;

/**
 * @typedef {import('./core/state.js').ActiveCallState} ActiveCallState
 */
import { els } from './core/dom.js';
import { acceptCall, declineCall } from '../api.js';

// Коллбэки, которые инициализируются из точки входа (main/app_init)
// чтобы избежать жёсткой зависимости (например, от unlockAudioPlayback или loadFriends)
/** @type {{ reloadFriends: (null|(()=>void)); unlockAudioPlayback: (null|(()=>void)); connectRoom?: (null|(()=>void)); }} */
let hooks = {
  reloadFriends: null,          // () => void
  unlockAudioPlayback: null,     // () => void
};

export function initCallModule(options = {}){
  hooks = { ...hooks, ...options };
}

/** Ререндер текста о текущем звонке */
function renderCallContext(){
  if (typeof window !== 'undefined' && _w.__NEW_CALL_SIGNALING__) return; // отключаем legacy UI при новой системе
  if (!els.callContext) return;
  /** @type {ActiveCallState|null} */
  const c = appState.activeCall;
  if (!c){ els.callContext.textContent = ''; return; }
  // Очищаем контейнер перед рендером
  els.callContext.innerHTML = '';
  const wrap = document.createElement('div');
  const title = document.createElement('span');
  title.className = 'muted';
  if (c.direction === 'outgoing' && c.status === 'invited'){
    title.textContent = `Исходящий звонок: ${c.username || c.withUserId}`;
  } else if (c.direction === 'incoming' && c.status === 'invited') {
    title.textContent = `Входящий звонок от: ${c.username || c.withUserId}`;
  } else if (c.status === 'accepted') {
    title.textContent = `Звонок с: ${c.username || c.withUserId}`;
  } else if (c.status === 'declined') {
    title.textContent = 'Отклонён';
  } else {
    title.textContent = '';
  }
  wrap.appendChild(title);
  // Кнопки действий в состояниях invited
  if (c.status === 'invited'){
    const btns = document.createElement('span'); btns.style.marginLeft='8px'; btns.style.display='inline-flex'; btns.style.gap='6px';
    if (c.direction === 'outgoing'){
      const btnCancel = document.createElement('button'); btnCancel.className='btn danger ghost'; btnCancel.textContent='Отменить';
      btnCancel.addEventListener('click', async ()=>{
        try { if (c.withUserId && c.roomId){ await (await import('../api.js')).cancelCall(c.withUserId, c.roomId); } } catch {}
        try { resetActiveCall('cancel'); } catch {}
      });
      btns.appendChild(btnCancel);
    } else if (c.direction === 'incoming') {
      const btnAccept = document.createElement('button'); btnAccept.className='btn success'; btnAccept.textContent='Принять';
      btnAccept.addEventListener('click', async ()=>{
        try { markCallAccepted(c.roomId); await (await import('../api.js')).acceptCall(c.withUserId, c.roomId); if (els.roomId && 'value' in els.roomId) els.roomId.value = c.roomId; if (typeof hooks?.unlockAudioPlayback==='function') hooks.unlockAudioPlayback(); if (typeof hooks?.connectRoom==='function') hooks.connectRoom(); } catch {}
      });
      const btnDecline = document.createElement('button'); btnDecline.className='btn ghost'; btnDecline.textContent='Отклонить';
      btnDecline.addEventListener('click', async ()=>{ try { await (await import('../api.js')).declineCall(c.withUserId, c.roomId); } catch {}; try { markCallDeclined(c.roomId); } catch {}; });
      btns.appendChild(btnAccept); btns.appendChild(btnDecline);
    }
    wrap.appendChild(btns);
  }
  els.callContext.appendChild(wrap);
}

function touchFriends(){
  try { hooks.reloadFriends && hooks.reloadFriends(); } catch {}
}

/** @param {{user_id:string, username?:string}} friend @param {string} roomId */
export function setActiveOutgoingCall(friend, roomId){
  if (typeof window !== 'undefined' && _w.__NEW_CALL_SIGNALING__) return; // новая система сама обновит UI
  appState.activeCall = { roomId, withUserId: friend.user_id, username: friend.username, direction: 'outgoing', status: 'invited' };
  renderCallContext();
  touchFriends();
  try { startOutgoingTone(); } catch {}
}

/** @param {string} fromUserId @param {string} username @param {string} roomId */
export function setActiveIncomingCall(fromUserId, username, roomId){
  if (typeof window !== 'undefined' && _w.__NEW_CALL_SIGNALING__) return;
  appState.activeCall = { roomId, withUserId: fromUserId, username, direction: 'incoming', status: 'invited' };
  appState.pendingIncomingInvites.set(fromUserId, { roomId, username });
  renderCallContext();
  touchFriends();
  // Универсальный входящий тон (incall) — одинаковый для всех пользователей
  try { startIncomingTone(); } catch {}
  showIncomingCallModal(username || fromUserId, roomId, fromUserId);
}

/** @param {string} roomId */
export function markCallAccepted(roomId){
  if (appState.activeCall && appState.activeCall.roomId === roomId){
    appState.activeCall.status = 'accepted';
    renderCallContext();
  }
  stopCallTones();
  hideIncomingCallModal();
  try { const k = appState.activeCall?.withUserId; if (k) appState.pendingIncomingInvites.delete(k); } catch {}
  touchFriends();
}

/** @param {string} roomId */
export function markCallDeclined(roomId){
  if (appState.activeCall && appState.activeCall.roomId === roomId){
    appState.activeCall.status = 'declined';
    renderCallContext();
    setTimeout(()=> resetActiveCall('declined'), 1500);
  }
  stopCallTones();
  hideIncomingCallModal();
  try { const k = appState.activeCall?.withUserId; if (k) appState.pendingIncomingInvites.delete(k); } catch {}
  touchFriends();
}

/** @param {string} reason */
export function resetActiveCall(reason){
  appState.activeCall = null;
  renderCallContext();
  stopCallTones();
  hideIncomingCallModal();
  touchFriends();
}

export function getActiveCall(){ return appState.activeCall; }
export function getPendingIncomingInvites(){ return appState.pendingIncomingInvites; }

// ===== Спец-рингтон (мигрирует сюда по частям) =====
// Используем секцию appState.special
const SPECIAL_RING_EMAILS = new Set([
  'roman74mamin@gmail.com',
  'gerasimenkoooo37@gmail.com',
  'myphone@gmail.com',
]);

const isMobileBrowser = typeof navigator !== 'undefined' && /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');

// Стандартизированные причины завершения (используются в WS call_end)
export const CALL_END_REASONS = Object.freeze({
  HANGUP: 'hangup',
  LEAVE: 'leave',
  DISCONNECT: 'disconnect',
  TIMEOUT: 'timeout',
  FAILED: 'failed',
});

function getStoredEmail(){ try { return localStorage.getItem('wc_email') || ''; } catch { return ''; } }

async function ensureSpecialRingtone(){
  const s = appState.special;
  if (s.ringtone) return s.ringtone;
  if (s.readyPromise) return s.readyPromise;
  s.readyPromise = (async () => {
    // Новый упорядоченный список кандидатов: сначала каноническое имя в новой папке media.
    const candidates = [
      '/static/media/special_ringtone.mp3',
      // Fallback: старый путь (до миграции), оставляем временно для совместимости c кэшем.
      '/static/js/Sil-a%20%26%20YUNG%20TRAPPA%20-%20%D0%94%D0%B0%D0%B2%D0%B0%D0%B9%20%D0%BA%D0%B8%D0%BD%D0%B5%D0%BC%20%D0%B1%D0%B0%D1%80%D1%8B%D0%B3%D1%83.mp3',
    ];
    for (const src of candidates){
      try {
        const audio = new Audio(src); audio.preload='auto'; audio.loop=true; audio.volume=1.0;
        const ok = await new Promise(res=>{
          let done=false; const cleanup=()=>{ if(done) return; done=true; audio.removeEventListener('loadedmetadata', onMeta); audio.removeEventListener('canplay', onCan); audio.removeEventListener('error', onErr); };
          const onMeta=()=>{ cleanup(); res(true); }; const onCan=()=>{ cleanup(); res(true); }; const onErr=()=>{ cleanup(); res(false); };
          audio.addEventListener('loadedmetadata', onMeta, { once:true });
          audio.addEventListener('canplay', onCan, { once:true });
          audio.addEventListener('error', onErr, { once:true });
          try { audio.load?.(); } catch {}
          setTimeout(()=>{ if (audio.readyState>=1){ cleanup(); res(true); } }, 60);
        });
        if (ok){ s.ringtone = audio; return audio; }
      } catch {}
    }
    return null;
  })();
  const r = await s.readyPromise; s.readyPromise = null; return r;
}

// === Новая система тонов ===
// outcall.mp3 — слышит звонящий во время исходящего дозвона
// incall.mp3  — слышит тот, кому звонят (входящий)
// special_ringtone.mp3 — ТОЛЬКО для исходящих спец-пользователей (ранее было для входящего) по требованию

/** @type {HTMLAudioElement|null} */
let genericOutcallAudio = null;
/** @type {HTMLAudioElement|null} */
let genericIncallAudio = null;

/**
 * @param {('outcall'|'incall')} kind
 * @returns {HTMLAudioElement|null}
 */
function ensureGenericAudio(kind){
  if (kind === 'outcall'){
    if (!genericOutcallAudio){ try { genericOutcallAudio = new Audio('/static/media/outcall.mp3'); genericOutcallAudio.loop = true; genericOutcallAudio.preload='auto'; } catch {} }
    return genericOutcallAudio;
  } else {
    if (!genericIncallAudio){ try { genericIncallAudio = new Audio('/static/media/incall.mp3'); genericIncallAudio.loop = true; genericIncallAudio.preload='auto'; } catch {} }
    return genericIncallAudio;
  }
}

// === Fade утилиты ===
/**
 * Плавное изменение громкости
 * @param {HTMLAudioElement} audio
 * @param {number} target 0..1
 * @param {number} ms
 * @param {()=>void} [onDone]
 */
function fadeVolume(audio, target, ms, onDone){
  try {
    target = clamp01(target);
    const startVol = clamp01(audio.volume ?? 0);
    const delta = target - startVol;
    if (Math.abs(delta) < 0.005){ audio.volume = target; onDone && onDone(); return; }
    const start = performance.now();
    /** @param {number} now */
    function step(now){
      const t = Math.min(1, (now - start)/ms);
      const v = clamp01(startVol + delta * t);
      try { audio.volume = v; } catch {}
      if (t < 1){ requestAnimationFrame(step); } else { onDone && onDone(); }
    }
    requestAnimationFrame(step);
  } catch { onDone && onDone(); }
}

/** @param {number} v @returns {number} */
function clamp01(v){ return v < 0 ? 0 : v > 1 ? 1 : v; }

/**
 * Запуск c fade-in
 * @param {HTMLAudioElement} a
 */
function playWithFadeIn(a){
  try { a.pause(); } catch {}
  try { a.currentTime = 0; } catch {}
  const originalTarget = 1.0;
  a.volume = 0.0;
  a.play().catch(()=>{});
  fadeVolume(a, originalTarget, 350);
}

/**
 * Остановка c fade-out
 * @param {HTMLAudioElement} a
 */
function stopWithFadeOut(a){
  fadeVolume(a, 0, 280, ()=>{ try { a.pause(); } catch {}; try { a.currentTime=0; } catch {}; });
}

function startOutgoingTone(){
  const email = (getStoredEmail() || '').toLowerCase();
  if (SPECIAL_RING_EMAILS.has(email)){
    // Спец-пользователь — используем специальный рингтон (переназначение смысла: теперь для исходящего)
    startSpecialRingtone();
    return;
  }
  const a = ensureGenericAudio('outcall');
  if (!a) return;
  try { if (hooks.unlockAudioPlayback) hooks.unlockAudioPlayback(); } catch {}
  try { playWithFadeIn(a); } catch {}
}

function startIncomingTone(){
  const a = ensureGenericAudio('incall');
  if (!a) return;
  try { if (hooks.unlockAudioPlayback) hooks.unlockAudioPlayback(); } catch {}
  try { playWithFadeIn(a); } catch {}
}

function stopGenericAudio(){
  for (const a of [genericOutcallAudio, genericIncallAudio]){
    if (!a) continue;
    try { stopWithFadeOut(a); } catch {}
  }
}

function stopCallTones(){
  stopSpecialRingtone();
  stopGenericAudio();
}

// Экспорт для тестов
export function __getCurrentOutcallAudio(){ return genericOutcallAudio; }
export function __getCurrentIncallAudio(){ return genericIncallAudio; }

// ===== Incoming Call Modal =====
/** @param {string} id */
function qs(id){ return /** @type {HTMLElement|null} */(document.getElementById(id)); }
let modalBound = false;
/** @type {any} */
let incomingAutoTimeout = null; // таймер авто-скрытия/отклонения входящего звонка
let swipeActive = false;
let swipeStartX = 0;
/** @type {HTMLElement|null} */
let swipeTarget = null; // текущая кнопка в жесте
const SWIPE_THRESHOLD = 110; // px
const SWIPE_CANCEL = 25; // если меньше этого при отпускании — откат

function ensureModalBindings(){
  if (modalBound) return;
  const acceptBtn = qs('btnCallAccept');
  const declineBtn = qs('btnCallDecline');
  // Унифицированный хелпер запуска действия по кнопке
  async function triggerAccept(){
    const c = appState.activeCall; if (!c) return;
    try {
      markCallAccepted(c.roomId);
      await acceptCall(c.withUserId, c.roomId).catch(()=>{});
      if (els.roomId && 'value' in els.roomId){ /** @type {any} */(els.roomId).value = c.roomId; }
      if (typeof hooks.unlockAudioPlayback === 'function') hooks.unlockAudioPlayback();
      if (typeof hooks.connectRoom === 'function') hooks.connectRoom();
    } catch {}
  }
  async function triggerDecline(){
    const c = appState.activeCall; if (!c) return;
    try { await declineCall(c.withUserId, c.roomId).catch(()=>{}); } catch {}
    markCallDeclined(c.roomId);
  }
  if (acceptBtn){
    acceptBtn.addEventListener('click', triggerAccept);
  }
  if (declineBtn){
    declineBtn.addEventListener('click', triggerDecline);
  }
  // Swipe (pointer) жесты
  const container = qs('incomingCallModal');
  if (container){
    container.addEventListener('pointerdown', (e)=>{
      const t = /** @type {HTMLElement} */(e.target);
      if (!t) return;
      if (t.id === 'btnCallAccept' || t.id === 'btnCallDecline'){
        swipeActive = true; swipeStartX = e.clientX; swipeTarget = t; t.setPointerCapture?.(e.pointerId);
        t.style.transition = 'none';
      }
    });
    container.addEventListener('pointermove', (e)=>{
      if (!swipeActive || !swipeTarget) return;
      const dx = e.clientX - swipeStartX;
      // Принимаем направление: accept — свайп вправо, decline — свайп влево
      if (swipeTarget.id === 'btnCallAccept' && dx > 0){
        swipeTarget.style.transform = `translateX(${dx}px)`;
      } else if (swipeTarget.id === 'btnCallDecline' && dx < 0){
        swipeTarget.style.transform = `translateX(${dx}px)`;
      }
      // Подсветка и прозрачность
      const abs = Math.abs(dx);
      const frac = Math.min(1, abs / SWIPE_THRESHOLD);
      swipeTarget.style.opacity = String(0.55 + 0.45 * frac);
      if (frac >= 1){ swipeTarget.classList.add('swipe-armed'); }
      else { swipeTarget.classList.remove('swipe-armed'); }
    });
  /**
   * Завершение жеста
   * @param {boolean} commit
   */
  const finishSwipe = (commit)=>{
      if (!swipeTarget) { swipeActive=false; return; }
      const t = swipeTarget;
      const dx = (parseFloat(t.style.transform.replace(/[^-0-9.]/g,'')||'0')) || 0;
      const isAccept = t.id === 'btnCallAccept';
      const passed = isAccept ? dx > SWIPE_THRESHOLD : dx < -SWIPE_THRESHOLD;
      t.style.transition = 'transform 160ms ease';
      if (commit && passed){
        t.style.transform = `translateX(${isAccept?SWIPE_THRESHOLD:-SWIPE_THRESHOLD}px)`;
        setTimeout(()=>{ isAccept ? triggerAccept() : triggerDecline(); }, 150);
      } else {
        // если малый dx — откат
        if (Math.abs(dx) < SWIPE_CANCEL){ t.style.transform = 'translateX(0px)'; }
        else { t.style.transform = 'translateX(0px)'; }
      }
      // Сброс визуальных атрибутов
      if (t){
        setTimeout(()=>{ try { t.classList.remove('swipe-armed'); t.style.opacity=''; t.style.transform=''; t.style.transition=''; } catch {} }, 170);
      }
      swipeActive = false; swipeTarget = null; swipeStartX = 0;
    };
    container.addEventListener('pointerup', ()=> finishSwipe(true));
    container.addEventListener('pointercancel', ()=> finishSwipe(false));
    container.addEventListener('pointerleave', ()=> finishSwipe(false));
  }
  modalBound = true;
}

/** @param {string} label @param {string} roomId @param {string} fromUserId */
function showIncomingCallModal(label, roomId, fromUserId){
  ensureModalBindings();
  const m = qs('incomingCallModal'); if (!m) return;
  const sub = qs('incomingCallFrom'); if (sub) sub.textContent = label;
  m.style.display = '';
  // Авто-таймаут: если за 45с не ответили — отклоняем локально.
  if (incomingAutoTimeout){ try { clearTimeout(incomingAutoTimeout); } catch {} }
  incomingAutoTimeout = setTimeout(()=>{
    try {
      const c = appState.activeCall;
      if (c && c.direction==='incoming' && c.status==='invited' && c.roomId===roomId){
        markCallDeclined(roomId);
      }
    } catch {}
  }, 45000);
}
function hideIncomingCallModal(){
  const m = qs('incomingCallModal'); if (m) m.style.display='none';
  if (incomingAutoTimeout){ try { clearTimeout(incomingAutoTimeout); } catch {}; incomingAutoTimeout=null; }
}

export function startSpecialRingtone(){
  const s = appState.special;
  s.active = true;
  // Цикличное (бесконечное) воспроизведение: убрали авто-остановку через 60с.
  if (s.timer) { try { clearTimeout(s.timer); } catch {}; s.timer=null; }
  if (!appState.userGestureHappened){
    // Откладываем до user gesture
    if (!appState.pendingAutoplayTasks.some(fn => /** @type {any} */(fn)?.__ring)){
      const runner = ()=>{ try{ const c=appState.activeCall; if (c && c.direction==='incoming' && c.status==='invited'){ startSpecialRingtone(); } }catch{} };
      /** @type {any} */(runner).__ring = true;
      appState.pendingAutoplayTasks.push(runner);
    }
    return;
  }
  if (hooks.unlockAudioPlayback) { try { hooks.unlockAudioPlayback(); } catch {} }
  s.session += 1; const mySession = s.session;
  ensureSpecialRingtone().then(audio => {
    if (mySession !== s.session) return;
    if (!audio) return;
    const START_AT = 1;
    const startPlayback = ()=>{
      if (!s.active || s.playing) return;
      s.playing = true;
      try { audio.volume = 0.0; } catch {}
      audio.play().catch(()=>{
        setTimeout(()=>{ if (s.active && !s.playing) audio.play().catch(()=>{}); }, 300);
      });
      // Плавное нарастание
      fadeVolume(audio, 1.0, 400);
    };
    const seekAndStart = ()=>{
      const onSeeked = ()=>{ try{ audio.removeEventListener('seeked', onSeeked);}catch{}; if (mySession===s.session) startPlayback(); };
      audio.addEventListener('seeked', onSeeked, { once:true });
      try { audio.currentTime = START_AT; } catch {}
      try { if (Math.abs((audio.currentTime||0)-START_AT) < 0.5){ audio.removeEventListener('seeked', onSeeked); if (mySession===s.session) startPlayback(); } } catch {}
    };
    if (audio.readyState >= 1) seekAndStart(); else { audio.addEventListener('loadedmetadata', seekAndStart, { once:true }); try { audio.load?.(); } catch {} }
  });
}

export function stopSpecialRingtone(){
  const s = appState.special;
  s.active = false; s.playing = false; s.session += 1;
  if (s.ringtone){
    const r = s.ringtone;
    // Плавное затухание
    try {
      fadeVolume(r, 0, 320, ()=>{ try { r.pause(); } catch {}; try { r.currentTime=0; } catch {}; });
    } catch {
      try { r.pause(); } catch {}
      try { r.currentTime = 0; } catch {}
    }
    // Не изменяем loop, пусть остаётся true — при следующем старте повтор сразу продолжится.
    if (isMobileBrowser){
      try { s.ringtone.removeAttribute && s.ringtone.removeAttribute('src'); } catch {}
      try { s.ringtone.src=''; } catch {}
      try { s.ringtone.load?.(); } catch {}
      s.ringtone = null; s.readyPromise = null;
    }
  }
  if (s.timer){ try { clearTimeout(s.timer); } catch {}; s.timer = null; }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\calls.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\calls_signaling.js =====
--- SIZE: 24487 bytes ---

// Полностью переписанный модуль сигналинга звонков.
// Основные цели:
//  1. Явная машина состояний с промежуточными фазами (dialing, outgoing_ringing, incoming_ringing, connecting, active, ended)
//  2. Таймауты набора / ожидания ответа, авто-отмена
//  3. Чёткая фильтрация дублирующих событий
//  4. Унифицированный UI слой (call_ui.js) через updateCallUI
//  5. Расширенное диагностическое логирование

import { notifyCall, acceptCall, declineCall, cancelCall } from '../api.js';
import { updateCallUI, bindActions, clearCallUI, hideIncoming } from './call_ui.js';
import { startIncomingRing, startOutgoingRing, stopAllRings, resumeAudio } from './call_audio.js';

// ============ Диагностика ============
const LOG = '[call-engine]';
function log(...a){ try { console.debug(LOG, ...a); } catch {} }
function warn(...a){ try { console.warn(LOG, ...a); } catch {} }

// ============ Типы ============
/**
 * @typedef {(
 *  'idle'|
 *  'dialing'|
 *  'outgoing_ringing'|
 *  'incoming_ringing'|
 *  'connecting'|
 *  'active'|
 *  'ended'
 * )} Phase
 */

/**
 * @typedef {Object} EngineState
 * @property {Phase} phase
 * @property {string=} roomId
 * @property {string=} otherUserId
 * @property {string=} otherUsername
 * @property {number} sinceTs
 * @property {string=} reason
 * @property {boolean=} incoming  // признак входящего сценария
 */

/**
 * @typedef {EngineState & { finalReason?:string, meta?:any }} UICallState
 */

/** @type {EngineState} */
let state = { phase:'idle', sinceTs: Date.now() };
const listeners = new Set();
let _dialTimer = null;  // таймер ожидания подтверждения вызова (получатель offline)
let _ringTimer = null;  // таймер ожидания ответа
let _graceTimer = null; // таймер авто-очистки после ended
const DIAL_TIMEOUT_MS = 15000;       // ожидание подтверждения (call_invite broadcast) УВЕЛИЧЕН
const RING_TIMEOUT_MS = 25000;       // ожидание ответа (accept/decline)
const OPTIMISTIC_RING_DELAY_MS = 800; // через сколько после notifyCall OK переходим в временное outgoing_ringing если echo ещё не пришёл
let _optimisticTimer = null; // таймер перехода в оптимистический ringing
  if (_optimisticTimer){ clearTimeout(_optimisticTimer); _optimisticTimer=null; }
  if (_optimisticTimer){ clearTimeout(_optimisticTimer); _optimisticTimer=null; }
const ENDED_CLEAR_DELAY_MS_DEFAULT = 2000;   // задержка очистки баннера (дефолт)
let ENDED_CLEAR_DELAY_MS = ENDED_CLEAR_DELAY_MS_DEFAULT;

// Внешние зависимости (DI)
let deps = {
  getAccountId: ()=> null,
  unlockAudio: ()=>{},
  navigateToRoom: (roomId)=>{ try {
    if (!roomId) return;
    const input = document.getElementById('roomId');
    if (input && 'value' in input) { input.value = roomId; }
    // Помечаем желаемую комнату для отложенного подключения
    try { if (window.appState) window.appState.currentRoomId = roomId; } catch {}
    // Если уже есть ws именно этой комнаты – выходим
    try { if (window.appState && window.appState.ws && window.appState.currentRoomId === roomId){ log('navigateToRoom: already connected (same room)'); return; } } catch {}
    if (window.connectRoom){ log('navigateToRoom: invoking connectRoom()'); window.connectRoom(); }
    else if (window.appState && window.appState.connectRoom){ log('navigateToRoom: using appState.connectRoom()'); window.appState.connectRoom(); }
    else {
      // Redirect fallback (в редких случаях если нет JS API)
      log('navigateToRoom: fallback redirect');
      const url = new URL(location.origin + '/call'); url.searchParams.set('room', roomId); location.href = url.toString();
    }
  } catch(e){ warn('navigateToRoom error', e); } },
};

// ============ Утилиты таймеров ============
function clearTimers(){
  if (_dialTimer){ clearTimeout(_dialTimer); _dialTimer=null; }
  if (_ringTimer){ clearTimeout(_ringTimer); _ringTimer=null; }
  if (_graceTimer){ clearTimeout(_graceTimer); _graceTimer=null; }
}

function scheduleDialTimeout(){
  if (_dialTimer) clearTimeout(_dialTimer);
  _dialTimer = setTimeout(()=>{
    if (state.phase === 'dialing'){
      warn('dial timeout, auto cancel');
      transition('ended', { reason:'unavailable' });
    }
  }, DIAL_TIMEOUT_MS);
}

function scheduleRingTimeout(){
  if (_ringTimer) clearTimeout(_ringTimer);
  _ringTimer = setTimeout(()=>{
    if (['outgoing_ringing','incoming_ringing'].includes(state.phase)){
      warn('ring timeout, auto end');
      if (state.phase==='outgoing_ringing') attemptCancel('timeout');
      else transition('ended', { reason:'timeout' });
    }
  }, RING_TIMEOUT_MS);
}

function scheduleEndedCleanup(){
  if (_graceTimer) clearTimeout(_graceTimer);
  _graceTimer = setTimeout(()=>{ if (state.phase==='ended') transition('idle', { reason:undefined, roomId:undefined, otherUserId:undefined, otherUsername:undefined }); }, ENDED_CLEAR_DELAY_MS);
}

// ============ Слушатели / события ============
function emit(){
  try { updateCallUI(/** @type {UICallState} */({...state})); } catch(e){ warn('UI update failed', e); }
  for (const fn of [...listeners]){ try { fn({...state}); } catch{} }
  try {
    window.appState && (window.appState.callPhase = state.phase);
  } catch{}
}

/**
 * @param {Phase} phase
 * @param {Partial<EngineState>} patch
 */
function transition(phase, patch){
  patch = patch || {};
  const prev = state;
  const shouldResetContext = phase === 'idle';
  if (shouldResetContext){
    patch = {
      ...patch,
      roomId: patch.roomId,
      otherUserId: patch.otherUserId,
      otherUsername: patch.otherUsername,
      incoming: patch.incoming,
    };
  }
  state = {
    ...state,
    ...(shouldResetContext ? { roomId: undefined, otherUserId: undefined, otherUsername: undefined, incoming: undefined, meta: undefined } : {}),
    ...patch,
    phase,
    sinceTs: Date.now(),
  };
  if (phase !== 'ended'){
    if (!('reason' in patch)) state.reason = undefined;
    state.finalReason = undefined;
  } else {
    if (!state.reason && patch.reason === undefined) state.reason = 'end';
    state.finalReason = state.reason;
  }
  if (phase === 'idle'){ state.reason = undefined; state.finalReason = undefined; }
  if (!['incoming_ringing','outgoing_ringing'].includes(phase)){ state.meta = patch.meta; if (!('meta' in patch)) state.meta = undefined; }
  log('transition', prev.phase, '->', phase, { room: state.roomId, peer: state.otherUserId, reason: state.reason });
  // Аудио сигналы
  try {
    if (phase==='incoming_ringing'){ resumeAudio(); startIncomingRing(); }
    else if (phase==='outgoing_ringing'){ resumeAudio(); startOutgoingRing(); }
    if (!['incoming_ringing','outgoing_ringing'].includes(phase)) stopAllRings();
  } catch{}
  // Таймеры
  if (phase==='dialing') scheduleDialTimeout(); else if (prev.phase==='dialing') { if (_dialTimer) { clearTimeout(_dialTimer); _dialTimer=null; } }
  if (['outgoing_ringing','incoming_ringing'].includes(phase)) scheduleRingTimeout(); else if (['outgoing_ringing','incoming_ringing'].includes(prev.phase)) { if (_ringTimer){ clearTimeout(_ringTimer); _ringTimer=null; } }
  if (phase==='ended') scheduleEndedCleanup(); else if (phase!=='ended' && _graceTimer){ clearTimeout(_graceTimer); _graceTimer=null; }
  // Адаптивная задержка очистки: для call-* ускоряем
  try {
    if (phase==='ended'){
      if (state.roomId && /^call-/.test(state.roomId)){ ENDED_CLEAR_DELAY_MS = 250; } else { ENDED_CLEAR_DELAY_MS = ENDED_CLEAR_DELAY_MS_DEFAULT; }
    }
  } catch {}
  // (убрано) Ранее здесь был автодисконнект WS для эфемерных комнат, отключено во избежание преждевременного выхода
  emit();
}

export function getCallState(){ return {...state}; }
export function onCallState(fn){ listeners.add(fn); return ()=>listeners.delete(fn); }

// ============ Public init ============
export function initCallSignaling(options){
  deps = { ...deps, ...(options||{}) };
  bindActions(
    ()=> acceptIncoming(),
    ()=> declineIncoming(),
    ()=> cancelOutgoing(),
    ()=> hangup()
  );
  log('initialized');
  try { window.__CALL_ENGINE__ = true; } catch{}
}

// ============ Actions ============
/** @param {{user_id:string, username?:string}} friend */
export function startOutgoingCall(friend){
  if (!friend || !friend.user_id){ warn('invalid friend'); return false; }
  if (state.phase === 'ended'){
    warn('auto-clearing ended state before new call');
    clearTimers();
    transition('idle', { roomId: undefined, otherUserId: undefined, otherUsername: undefined, incoming: undefined });
  }
  // Автовосстановление: если состояние не idle, но оно "устарело" или зависло – делаем мягкий сброс
  if (state.phase !== 'idle'){
    const age = Date.now() - state.sinceTs;
    const recoverable = ['ended','active','connecting'].includes(state.phase) && age > 1500;
    if (recoverable){
      warn('recovering stale call state', state.phase, age);
      clearTimers();
      transition('idle', { roomId: undefined, otherUserId: undefined, otherUsername: undefined, incoming: undefined });
    }
  }
  if (state.phase !== 'idle'){
    warn('call already in progress');
    return false;
  }
  if (deps.getAccountId && String(deps.getAccountId()) === String(friend.user_id)){ warn('self-call blocked'); return false; }

  if (!isFriendsWsOpen()){
    toast('Нет соединения (WebSocket). Подождите...', 'warning');
    attemptWsReconnect();
    return false;
  }

  const roomId = buildRoomId(friend);
  try { log('startOutgoingCall', { accountId: deps.getAccountId && deps.getAccountId(), target: friend.user_id, roomId }); } catch {}
  transition('dialing', { roomId, otherUserId: friend.user_id, otherUsername: friend.username, incoming: false });
  try { deps.unlockAudio(); } catch{}

  notifyCall(friend.user_id, roomId).then(()=>{
    log('notifyCall OK');
    // Планируем оптимистический переход, чтобы пользователь услышал звонок даже если echo задерживается
    if (_optimisticTimer) clearTimeout(_optimisticTimer);
    _optimisticTimer = setTimeout(()=>{
      _optimisticTimer=null;
      if (state.phase==='dialing'){
        log('optimistic transition -> outgoing_ringing (echo not yet received)');
        transition('outgoing_ringing', { incoming: false, meta:{ optimistic:true, confirmed:false } });
      }
    }, OPTIMISTIC_RING_DELAY_MS);
  }).catch(err=>{
    warn('notifyCall failed', err);
    transition('ended', { reason:'unavailable' });
  });
  return true;
}

export function cancelOutgoing(){
  if (['dialing','outgoing_ringing'].includes(state.phase)){
    attemptCancel('cancel');
  }
}

export function declineIncoming(){
  if (state.phase==='incoming_ringing'){
    attemptDecline('declined');
  }
}

export function acceptIncoming(){
  if (state.phase!=='incoming_ringing') return;
  if (!state.roomId || !state.otherUserId) return;
  transition('connecting', {});
  acceptCall(state.otherUserId, state.roomId).catch(err=>{
    warn('acceptCall failed', err);
    transition('ended', { reason:'unavailable' });
  });
  try { deps.unlockAudio(); resumeAudio(); stopAllRings(); } catch{}
  if (state.roomId) deps.navigateToRoom(state.roomId);
}

export function hangup(){
  if (state.phase==='active'){
    // Отправка call_end в app_init или другом месте (там уже реализовано). Здесь просто локально завершаем
    transition('ended', { reason:'hangup' });
  } else if (['connecting','incoming_ringing'].includes(state.phase)){
    attemptDecline('declined');
  } else if (['dialing','outgoing_ringing'].includes(state.phase)){
    attemptCancel('cancel');
  } else if (state.phase==='ended'){
    transition('idle', { roomId: undefined, otherUserId: undefined, otherUsername: undefined, incoming: undefined });
  }
}

function attemptCancel(reason){
  if (!state.roomId || !state.otherUserId){ transition('ended', { reason:'cancel' }); return; }
  cancelCall(state.otherUserId, state.roomId).catch(()=>{});
  transition('ended', { reason: reason||'cancel' });
  hideIncoming();
}
function attemptDecline(reason){
  if (!state.roomId || !state.otherUserId){ transition('ended', { reason:'declined' }); return; }
  declineCall(state.otherUserId, state.roomId).catch(()=>{});
  transition('ended', { reason: reason||'declined' });
  hideIncoming();
}

// ============ Helpers ============
function buildRoomId(friend){
  const rnd = crypto.randomUUID().slice(0,8);
  const tag = (friend.username || friend.user_id || 'user').replace(/[^a-zA-Z0-9]+/g,'').slice(0,6) || 'user';
  return `call-${rnd}-${tag}`;
}

function isFriendsWsOpen(){
  try {
    const ws = window?.appState?.friendsWs;
    return !!ws && ws.readyState === WebSocket.OPEN;
  } catch { return false; }
}
function attemptWsReconnect(){
  try { if (window.startFriendsWs && !window.appState.friendsWsConnecting) window.startFriendsWs(); } catch{}
}
function toast(msg, level){ try { window.showToast && window.showToast(msg, level||'info'); } catch{ try { console.info('[toast]', msg); } catch{} } }

// ============ WS входящие сообщения ============
// Буфер до появления accountId
const _pending = []; let _pendingTimer=null;
function scheduleReplay(){ if (_pendingTimer) return; _pendingTimer = setTimeout(()=>{ _pendingTimer=null; const acc = deps.getAccountId(); if (!acc){ scheduleReplay(); return;} for (const m of _pending.splice(0)){ internalHandle(m, acc); } }, 350); }

export function handleWsMessage(msg){
  if (!msg || typeof msg !== 'object') return;
  const acc = deps.getAccountId();
  if (!acc){ _pending.push(msg); scheduleReplay(); return; }
  internalHandle(msg, acc);
}

function internalHandle(msg, acc){
  try {
    if (!window.__CALL_DEBUG) window.__CALL_DEBUG=[];
    window.__CALL_DEBUG.push({ ts:Date.now(), phase:state.phase, msg });
    if (window.__CALL_DEBUG.length>300) window.__CALL_DEBUG.splice(0, window.__CALL_DEBUG.length-300);
  } catch{}
  // debugPanel отключён
  const t = msg.type;
  switch(t){
    case 'call_invite': return onInvite(msg, acc);
    case 'call_accept': return onAccept(msg, acc);
    case 'call_decline': return onDecline(msg, acc);
    case 'call_cancel': return onCancel(msg, acc);
    case 'call_end': return onEnd(msg, acc);
    default: break;
  }
}

// Унифицированное сравнение userId с игнорированием регистра и дефисов (на случай разных форматов sub)
function _normId(v){ return (v||'').toString().toLowerCase().replace(/[^a-f0-9]/g,''); }
function _eqId(a,b){ if (!a||!b) return false; return _normId(a) === _normId(b); }

function onInvite(m, acc){
  const nowMs = Date.now();
  const createdAt = typeof m.createdAt === 'number' ? m.createdAt : nowMs;
  const age = nowMs - createdAt;
  const MAX_AGE_MS = 40000; // синхронизировано с backend (call_invites.py) увеличено до 40s
  if (age > MAX_AGE_MS){
    log('ignore stale call_invite (age ms)', age, m.roomId);
    return;
  }
  // Дополнительная гибкость: поддержим альтернативные поля (snake_case) если когда-то появятся
  if (!m.fromUserId && m.from_user_id) m.fromUserId = m.from_user_id;
  if (!m.toUserId && m.to_user_id) m.toUserId = m.to_user_id;
  if (!m.roomId && m.room_id) m.roomId = m.room_id;
  const isForMe = _eqId(m.toUserId, acc);
  const isMine = _eqId(m.fromUserId, acc);
  if (!isForMe && !isMine){
    log('ignore call_invite (not for me)', { acc, from:m.fromUserId, to:m.toUserId, room:m.roomId });
    return;
  }
  if (isMine){
    // Echo подтверждение: если мы в dialing -> переходим в outgoing_ringing
    if (state.phase==='dialing' && state.roomId === m.roomId){
      transition('outgoing_ringing', { otherUsername: m.toUsername || state.otherUsername, incoming:false, meta:{ optimistic:false, confirmed:true, createdAt } });
    } else if (state.phase==='outgoing_ringing' && state.roomId === m.roomId){
      // Обновляем meta если это был оптимистический режим
      if (state.meta && state.meta.optimistic && !state.meta.confirmed){
        state.meta.optimistic=false; state.meta.confirmed=true; log('server confirmation for optimistic ringing');
      }
    }
    return;
  }
  if (isForMe){
    if (!['idle','ended'].includes(state.phase)){
      // Попытка авто-восстановления если состояние устаревшее или не соответствует реальности
      const age = Date.now() - state.sinceTs;
      const recoverable = ['ended','active','connecting','dialing','outgoing_ringing','incoming_ringing'].includes(state.phase) && age > 2000;
      if (recoverable){
        warn('recover stale state before processing new invite', state.phase, age);
        try { clearTimers(); } catch{}
        state = { phase:'idle', sinceTs: Date.now() };
        emit();
      } else {
        warn('incoming invite while busy -> decline');
        declineCall(m.fromUserId, m.roomId).catch(()=>{});
        return;
      }
    }
    // Корректируем оставшийся ring timeout если invite пришёл из pending replay
    const remaining = Math.max(500, RING_TIMEOUT_MS - age);
    if (_ringTimer){ clearTimeout(_ringTimer); _ringTimer=null; }
    transition('incoming_ringing', { roomId: m.roomId, otherUserId: m.fromUserId, otherUsername: m.fromUsername, incoming:true, meta:{ createdAt, replay: !!m.pendingReplay, age } });
    // Переназначаем ring timeout под оставшееся окно
    if (_ringTimer) { clearTimeout(_ringTimer); _ringTimer=null; }
    _ringTimer = setTimeout(()=>{
      if (state.phase==='incoming_ringing' && state.roomId === m.roomId){
        warn('ring timeout (adjusted) auto end');
        transition('ended', { reason:'timeout' });
      }
    }, remaining);
    // Браузерное уведомление
    try {
      const showNotif = () => {
        const title = m.fromUsername ? `Звонок от ${m.fromUsername}` : 'Входящий звонок';
        const body = 'Нажмите, чтобы ответить';
        const icon = '/static/icons/phone.png'; // fallback, если нет — можно заменить
        const n = new Notification(title, { body, tag: 'incoming-call', icon, renotify: true, data: { roomId: m.roomId } });
        n.onclick = (ev) => {
          try { ev.preventDefault(); } catch {}
          try { window.focus && window.focus(); } catch {}
          try {
            // Переходим в комнату; если UI ещё не инициализирован — сохранится через navigate
            if (m.roomId && deps.navigateToRoom) deps.navigateToRoom(m.roomId);
          } catch {}
          try { n.close(); } catch {}
        };
        // Авто закрытие через 15с если пользователь не взаимодействует
        setTimeout(()=>{ try { n.close(); } catch {} }, 15000);
      };
      if ('Notification' in window){
        if (Notification.permission === 'granted') showNotif();
        else if (Notification.permission !== 'denied'){
          Notification.requestPermission().then(p=>{ if (p==='granted') showNotif(); });
        }
      }
    } catch {}
  }
}
function onAccept(m, acc){
  if (state.roomId !== m.roomId) { log('ignore call_accept (room mismatch)', { have: state.roomId, got: m.roomId }); return; }
  if (['outgoing_ringing','incoming_ringing','dialing','connecting'].includes(state.phase)){
    transition('active', {});
    try { deps.unlockAudio(); resumeAudio(); stopAllRings(); } catch{}
    if (m.roomId) {
      deps.navigateToRoom(m.roomId);
      // Fallback: через 900мс если нет открытогo ws к этой комнате – повтор
      setTimeout(()=>{
        try {
          if (!window.appState) return;
          const wsOk = window.appState.ws && window.appState.ws.readyState === WebSocket.OPEN;
          const same = window.appState.currentRoomId === m.roomId;
          if (!wsOk || !same){
            log('accept fallback: re-invoking navigateToRoom');
            deps.navigateToRoom(m.roomId);
          }
        } catch{}
      }, 900);
    }
  }
}
function onDecline(m, acc){
  if (state.roomId !== m.roomId){ log('ignore call_decline (room mismatch)', { have: state.roomId, got: m.roomId }); return; }
  if (state.phase !== 'idle') transition('ended', { reason:'declined' });
}
function onCancel(m, acc){
  if (state.roomId !== m.roomId){ log('ignore call_cancel (room mismatch)', { have: state.roomId, got: m.roomId }); return; }
  if (state.phase !== 'idle') transition('ended', { reason:'cancel' });
}
function onEnd(m, acc){
  if (state.roomId !== m.roomId){ log('ignore call_end (room mismatch)', { have: state.roomId, got: m.roomId }); return; }
  if (state.phase === 'idle'){ return; }
  if (state.phase === 'ended'){
    if (m.reason && !state.reason) state.reason = m.reason;
    return;
  }
  const derivedReason = m.reason || (state.incoming ? 'disconnect' : 'end');
  transition('ended', { reason: derivedReason });
}

// ============ Legacy совместимость (минимум) ============
// Сохраняем базовые хуки, чтобы старый код не ломался (если он обращается к предыдущим экспортам)
export function resetCallSystem(){
  clearTimers();
  transition('idle', { roomId: undefined, otherUserId: undefined, otherUsername: undefined, incoming: undefined });
  clearCallUI();
}

// Псевдонимы старых имён
export const startOutgoingCallOld = startOutgoingCall;
export const cancelOutgoingOld = cancelOutgoing;
export const declineIncomingOld = declineIncoming;
export const acceptIncomingOld = acceptIncoming;

// Принудительный внешний сброс, если вдруг UI остался в невалидном состоянии
export function forceResetCall(){
  try { warn('forceResetCall invoked'); } catch{}
  clearTimers();
  transition('idle', { roomId: undefined, otherUserId: undefined, otherUsername: undefined, incoming: undefined });
}

// Для консольной диагностики
try {
  window.__debugCallState = () => ({ state: {...state}, log:(window.__CALL_DEBUG||[]).slice(-20) });
  window.getCallState = () => ({...state});
  window.debugCallEngine = () => {
    const ws = (window.appState && window.appState.friendsWs) || null;
    return {
      state: { ...state },
      timers: {
        hasDial: !!_dialTimer,
        hasRing: !!_ringTimer,
        hasGrace: !!_graceTimer,
        hasOptimistic: !!_optimisticTimer,
      },
      ws: ws ? ['CONNECTING','OPEN','CLOSING','CLOSED'][ws.readyState] : 'NONE',
      accountId: deps.getAccountId && deps.getAccountId(),
      pendingBuffered: _pending.length,
    };
  };
} catch{}

// Экспорт типов для JSDoc других модулей
export {};

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\calls_signaling.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\app_init.js =====
--- SIZE: 100224 bytes ---

// modules/app_init.js
// Оркестрация инициализации приложения: UI, WebSocket комнаты, друзья, push, permissions.

import { buildWs, getMe } from '../../api.js';
import * as signal from '../../signal.js';
import { WebRTCManager } from '../../webrtc.js';
import { els, appendLog, appendChat, setText, setEnabled, showToast } from './dom.js';
import { appState } from './state.js';
import { loadVisitedRooms } from '../visited_rooms.js';
import { initFriendsModule, loadFriends, scheduleFriendsReload, initFriendsUI, markFriendSeen, refreshFriendStatuses, setOnlineSnapshot, addOnlineUser, removeOnlineUser } from '../friends_ui.js';
import { initDirectChatModule, handleIncomingDirect, handleDirectCleared, bindSendDirect } from '../direct_chat.js';
// Legacy calls.js оставляем временно для обратной совместимости (звук, часть тестов)
import { startSpecialRingtone, stopSpecialRingtone, resetActiveCall, getActiveCall, initCallModule } from '../calls.js';
// Новый signaling слой
import {
  initCallSignaling,
  handleWsMessage as handleCallSignal,
  startOutgoingCall as startOutgoingCallNew,
  resetCallSystem as resetCallEngine,
  forceResetCall as forceResetCallEngine,
  hangup as hangupCall,
} from '../calls_signaling.js';
import { checkAndRequestPermissionsInitial, updatePermBanner } from '../permissions.js';
import { initPush } from '../push_subscribe.js';
import { bus } from './event_bus.js';
import { startStatsLoop, stopStatsLoop, formatBitrate } from '../stats.js';
import { VoiceCaptureMixer } from '../voice/capture_mixer.js';

// ===== Helpers =====
function log(msg){ appendLog(els.logs, msg); }
function stat(line){ appendLog(els.stats, line); }

function cancelSoloLeave(reason){
  if (!appState.callAutoLeaveTimer) return;
  try {
    log(`auto-leave cancelled${reason ? ` (${reason})` : ''}`);
  } catch {}
  clearTimeout(appState.callAutoLeaveTimer);
  appState.callAutoLeaveTimer = null;
  appState.callAutoLeaveRoom = null;
}

function getStableConnId(){
  try {
    let id = sessionStorage.getItem('wc_connid');
    if (!id){ id = crypto.randomUUID(); sessionStorage.setItem('wc_connid', id); }
    return id;
  } catch { return crypto.randomUUID(); }
}
// Корректное декодирование JWT payload c base64url → JSON
function b64urlDecode(str){
  try {
    // Преобразуем base64url в base64
    str = str.replace(/-/g,'+').replace(/_/g,'/');
    const pad = str.length % 4; if (pad) str += '='.repeat(4-pad);
    return atob(str);
  } catch { return ''; }
}
function getAccountId(){
  try {
    const t = localStorage.getItem('wc_token'); if (!t) return null; const part = t.split('.')[1]; if (!part) return null;
    const raw = b64urlDecode(part); if (!raw) return null; const payload = JSON.parse(raw);
    return payload.sub || null;
  } catch { return null; }
}

// ====== Audio unlock ======
export function unlockAudioPlayback(){
  try {
    if (!appState.userGestureHappened) return false;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if (Ctx){
      if (!appState.globalAudioCtx) appState.globalAudioCtx = new Ctx();
      if (appState.globalAudioCtx.state === 'suspended') appState.globalAudioCtx.resume().catch(()=>{});
      try {
        const buffer = appState.globalAudioCtx.createBuffer(1,1,22050);
        const source = appState.globalAudioCtx.createBufferSource();
        source.buffer = buffer; source.connect(appState.globalAudioCtx.destination); source.start(0);
      } catch {}
      try { appState.audioUnlocked = (appState.globalAudioCtx.state === 'running'); } catch { appState.audioUnlocked = false; }
    }
    document.querySelectorAll('audio').forEach(a=>{ try{ a.playsInline = true; a.muted=false; a.volume=1.0; a.play().catch(()=>{}); }catch{} });
  } catch {}
}

// ===== Connection state UI =====
function showPreJoin(){ if (els.inCallControls) els.inCallControls.style.display='none'; if (els.inCallSection) els.inCallSection.style.display='none'; if (els.visitedCard) els.visitedCard.style.display=''; if (els.statusCard) els.statusCard.style.display='none'; }
function showInCall(){ if (els.inCallControls) els.inCallControls.style.display=''; if (els.inCallSection) els.inCallSection.style.display=''; if (els.visitedCard) els.visitedCard.style.display='none'; if (els.statusCard) els.statusCard.style.display=''; }

function setConnectingState(isConnecting){ setText(els.connStatus, isConnecting ? 'Подключение...' : 'Не подключено'); setEnabled(els.btnConnect, !isConnecting); setEnabled(els.btnLeave, false); setEnabled(els.btnSend, false); setEnabled(els.btnToggleMic, false); }
function setConnectedState(connected){ setText(els.connStatus, connected ? 'Подключено' : 'Не подключено'); setEnabled(els.btnConnect, !connected); setEnabled(els.btnSend, connected); setEnabled(els.btnLeave, connected); setEnabled(els.btnToggleMic, connected); if (connected) showInCall(); else { showPreJoin(); if (els.callContext) els.callContext.textContent=''; } }

function ensureToken(){
  appState.token = localStorage.getItem('wc_token');
  if (!appState.token){
    const params = new URLSearchParams({ redirect:'/call' });
    if (els.roomId?.value) params.set('room', els.roomId.value);
    location.href = `/auth?${params.toString()}`; return false;
  }
  try {
    const payload = JSON.parse(atob(appState.token.split('.')[1]));
    appState.accountId = payload.sub; const now = Math.floor(Date.now()/1000);
    if (payload.exp && now >= payload.exp){
      localStorage.removeItem('wc_token');
      const params = new URLSearchParams({ redirect:'/call' }); if (els.roomId?.value) params.set('room', els.roomId.value);
      location.href = `/auth?${params.toString()}`; return false;
    }
  } catch {}
  return true;
}

// ===== Devices =====
async function refreshDevices(){
  if (!navigator.mediaDevices?.enumerateDevices) return;
  const devs = await navigator.mediaDevices.enumerateDevices();
  const mics = devs.filter(d=>d.kind==='audioinput');
  const cams = devs.filter(d=>d.kind==='videoinput');
  const spks = devs.filter(d=>d.kind==='audiooutput');
  const fill = (sel,list,picked)=>{ if (!sel) return; sel.innerHTML=''; list.forEach(d=>{ const o=document.createElement('option'); o.value=d.deviceId; o.textContent=d.label||`Unknown ${d.kind}`; if (picked && picked===d.deviceId) o.selected=true; sel.appendChild(o); }); };
  fill(els.micSel,mics,appState.selected.mic); fill(els.camSel,cams,appState.selected.cam); fill(els.spkSel,spks,appState.selected.spk);
  const summary = devs.map(d=>`${d.kind}:${d.label||'(no)'}:${(d.deviceId||'').slice(0,6)}`).join(' | ');
  stat(`Devices: ${summary}`);
  try {
    if (els.camSel && !els.camSel._wc_bound){
      els.camSel.addEventListener('change', async ()=>{
        const devId = els.camSel.value; appState.selected.cam = devId; try { localStorage.setItem('wc_cam', devId); } catch {}
        if (appState.rtc){
          if (appState.rtc._currentVideoKind === 'camera'){
            await appState.rtc.switchCamera(devId);
          } else {
            appState.rtc.preferred.camId = devId;
          }
        }
      });
      els.camSel._wc_bound = true;
    }
  } catch {}
}

// ===== WS Room connect =====
export async function connectRoom(){
  cancelSoloLeave('connect-room');
  if (appState.ws){
    const rs = appState.ws.readyState;
    if (rs === WebSocket.OPEN || rs === WebSocket.CONNECTING){
      log('WS уже подключается или открыт');
      return;
    }
    try { appState.ws.close(); } catch {}
    appState.ws = null;
  }
  appState.isManuallyDisconnected = false;
  if (!ensureToken()) { log('Нет токена'); return; }
  const roomInput = els.roomId;
  const roomId = roomInput && 'value' in roomInput ? roomInput.value.trim() : '';
  if (!roomId){ log('Нужен ID комнаты'); return; }
  log(`Подключение к комнате ${roomId}...`); setConnectingState(true);
  appState.userId = getStableConnId();
  try {
    appState.currentRoomId = roomId;
    appState._lastPresenceRoom = roomId;
    appState._prevPresenceCount = 0;
    appState._multiPresenceSince = null;
    appState.callAutoLeaveRoom = null;
  } catch {}
  appState.ws = buildWs(roomId, appState.token);
  log(`Мой connId: ${appState.userId}`); log(`Адрес WS: ${appState.ws.__debug_url}`);

  appState.rtc = new WebRTCManager({
    localVideo: els.localVideo,
    outputDeviceId: appState.selected.spk,
    onLog: log,
    onPeerState: (peerId,key,value)=>{ const tile=document.querySelector(`.tile[data-peer="${peerId}"]`); if (tile) tile.dataset[key]=value; },
    onVideoState: (kind)=>{
      try {
        const camBtn = els.btnToggleCam; const screenBtn = els.btnScreenShare; const scrBadge = document.getElementById('screenShareBadge');
        const multiBadge = document.getElementById('multiBadge');
        const stopCam = document.getElementById('btnStopCam');
        const stopScr = document.getElementById('btnStopScreen');
        const mixBtn = document.getElementById('btnCompositeToggle');
        camBtn?.classList.remove('btn-media-active'); screenBtn?.classList.remove('btn-media-active');
        if (scrBadge) scrBadge.style.display = (kind==='screen' || kind==='multi') ? '' : 'none';
        if (multiBadge) multiBadge.style.display = (kind==='multi') ? '' : 'none';
        if (kind==='camera' || kind==='multi') camBtn?.classList.add('btn-media-active');
        if (kind==='screen' || kind==='multi') screenBtn?.classList.add('btn-media-active');
        if (stopCam) stopCam.style.display = (kind==='camera' || kind==='multi') ? '' : 'none';
        if (stopScr) stopScr.style.display = (kind==='screen' || kind==='multi') ? '' : 'none';
        if (mixBtn) {
          // Показываем кнопку только когда есть одновременно экран и камера
          mixBtn.style.display = (kind==='multi') ? '' : 'none';
        }
        const card = document.getElementById('localCard'); if (card) card.style.display = (kind==='none') ? 'none' : '';
      } catch {}
    }
  });

  const sendPingSafe = signal.sendPing ?? (ws => { try { if (ws && ws.readyState===WebSocket.OPEN) ws.send(JSON.stringify({type:'ping'})); } catch {} });

  appState.ws.onopen = async () => {
    cancelSoloLeave('ws-open');
    appState.isReconnecting = false; log('WS открыт'); setConnectedState(true);
    if (appState.reconnectTimeout) clearTimeout(appState.reconnectTimeout);
    if (appState.pingTimer) clearInterval(appState.pingTimer);
    appState.pingTimer = setInterval(()=> sendPingSafe(appState.ws), 30000);
    try { const storedU = localStorage.getItem('wc_username') || undefined; appState.ws.send(JSON.stringify({ type:'join', fromUserId: appState.userId, username: storedU })); } catch {}
    await appState.rtc.init(appState.ws, appState.userId, { micId: appState.selected.mic, camId: appState.selected.cam });
    // Запуск метрик после готовности rtc
    try {
      startStatsLoop({ intervalMs: 4000 });
    } catch {}
    try { stopSpecialRingtone(); } catch {}
    // peer cleanup
    try {
      if (appState.peerCleanupIntervalId) { clearInterval(appState.peerCleanupIntervalId); }
      appState.peerCleanupIntervalId = setInterval(()=>{
        try {
          if (!appState.rtc || !appState.rtc.peers) return;
          const now = Date.now();
          for (const [pid, st] of Array.from(appState.rtc.peers.entries())){
            const created = st.createdAt || st._createdAt || now; if (!st.createdAt) st.createdAt = created;
            const iceState = st.pc?.iceConnectionState || st.pc?.connectionState;
            const isBad = ['failed','disconnected','closed'].includes(iceState);
            if (isBad && (now - created > 120000)){
              try { st.pc && st.pc.close(); } catch {}
              try { if (st.level?.raf) cancelAnimationFrame(st.level.raf); } catch {}
              appState.rtc.peers.delete(pid);
              const tile = document.querySelector(`.tile[data-peer="${pid}"]`);
              if (tile){ safeReleaseMedia(tile); tile.remove(); }
              log(`Удалён проблемный пир ${pid} (state=${iceState})`);
            }
          }
        } catch {}
      }, 5000);
    } catch {}
    try {
      const hasVideo = !!(appState.rtc.localStream && appState.rtc.localStream.getVideoTracks()[0] && appState.rtc.localStream.getVideoTracks()[0].enabled);
      const card = document.getElementById('localCard'); if (card) card.style.display = hasVideo ? '' : 'none';
    } catch {}
    try { await loadVisitedRooms(); } catch {}
  };

  appState.ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);
    if (msg.type === 'signal'){
      await appState.rtc.handleSignal(msg, bindPeerMedia);
    } else if (msg.type === 'presence'){
      appState.latestUserNames = msg.userNames || {};
      const agentIds = new Set(msg.agentIds || []);
      const readable = msg.users.map(u => appState.latestUserNames[u] || u.slice(0,6));
      log(`В комнате: ${readable.join(', ')}`);
      document.querySelectorAll('.tile').forEach(tile => {
        const pid = tile.getAttribute('data-peer'); const nm = tile.querySelector('.name');
        if (pid && nm) nm.textContent = appState.latestUserNames[pid] || `user-${pid.slice(0,6)}`;
      });
      const myId = getStableConnId();
      const allowed = new Set(msg.users.filter(u => u !== myId));
      document.querySelectorAll('.tile').forEach(tile => { const pid=tile.getAttribute('data-peer'); if (pid && !allowed.has(pid)){ safeReleaseMedia(tile); tile.remove(); } });
      if (appState.rtc && appState.rtc.peers){ for (const [pid,st] of Array.from(appState.rtc.peers.entries())){ if (!allowed.has(pid)){ try { st.pc.onicecandidate=null; st.pc.close(); } catch {}; try { if (st.level?.raf) cancelAnimationFrame(st.level.raf); } catch {}; appState.rtc.peers.delete(pid); } } }
      for (const peerId of msg.users){
        if (peerId === myId) continue;
        if (agentIds.has(peerId)){
          // Рисуем/обновляем placeholder тайл агента (без медиапотоков)
          if (!document.querySelector(`.tile[data-peer="${peerId}"]`)){
            const tpl = document.getElementById('tpl-peer-tile');
            if (tpl && tpl.content){
              const tile = tpl.content.firstElementChild.cloneNode(true); tile.dataset.peer = peerId; els.peersGrid.appendChild(tile);
              const name = tile.querySelector('.name'); if (name) name.textContent = appState.latestUserNames[peerId] || 'AI AGENT';
              tile.classList.add('agent-tile');
            }
          }
          continue; // Не инициируем WebRTC к агенту
        }
        try { const last = appState.recentOffer.get(peerId) || 0; const now=Date.now(); if (now - last < 3000){ log(`Пропущен повторный старт для ${peerId}`); continue; } appState.recentOffer.set(peerId, now); } catch {}
        try { log(`Обнаружен пир ${peerId}, инициирую звонок...`); await appState.rtc.startOffer(peerId); } catch(e){ log(`startOffer(${peerId}) failed: ${e}`); }
      }
      try { updatePeerLayout(); } catch {}
      // Авто-выход из личной комнаты звонка если остались одни
      try {
        const roomField = els.roomId;
        const roomId = roomField && 'value' in roomField ? roomField.value || '' : '';
        const isCallRoom = /^call-/.test(roomId);
        if (isCallRoom){
          const nowCount = Array.isArray(msg.users) ? msg.users.length : 0;
          const trackedRoom = appState._lastPresenceRoom;
          const sameRoom = trackedRoom === roomId;
          const prev = sameRoom && typeof appState._prevPresenceCount === 'number' ? appState._prevPresenceCount : nowCount;
          let multiSince = sameRoom ? appState._multiPresenceSince : (nowCount >= 2 ? Date.now() : null);

          if (!sameRoom){
            appState._lastPresenceRoom = roomId;
            appState._prevPresenceCount = nowCount;
            appState._multiPresenceSince = multiSince;
          }

          if (nowCount >= 2){
            if (!multiSince) multiSince = Date.now();
            cancelSoloLeave('peers-present');
          }

          const stabilized = !!multiSince && (Date.now() - multiSince > 1200);
          if (sameRoom && prev >= 2 && nowCount <= 1 && stabilized){
            const phase = (window.getCallState && window.getCallState().phase) || 'idle';
            if (['active','ended','connecting'].includes(phase)){
              if (!appState.callAutoLeaveTimer){
                log(`call-room solitary detected (prev=${prev} -> now=${nowCount}), scheduling auto leave`);
                const timerRoom = roomId;
                appState.callAutoLeaveRoom = timerRoom;
                appState.callAutoLeaveTimer = setTimeout(()=>{
                  if (appState.callAutoLeaveRoom && appState.callAutoLeaveRoom !== timerRoom){
                    cancelSoloLeave('room-updated');
                    return;
                  }
                  try {
                    const latestCount = typeof appState._prevPresenceCount === 'number' ? appState._prevPresenceCount : 0;
                    if (latestCount > 1){
                      log('solo grace aborted: peer rejoined');
                      cancelSoloLeave('peer-rejoined');
                      return;
                    }
                    const currentRoom = roomField && 'value' in roomField ? roomField.value : '';
                    if (!currentRoom || currentRoom !== timerRoom){
                      cancelSoloLeave('room-changed');
                      return;
                    }
                    try {
                      if (window.getCallState && window.getCallState().phase === 'active'){
                        hangupCall();
                      }
                    } catch {}
                    try { resetCallEngine(); } catch {}
                    try { if (roomField && /^call-/.test(roomField.value)) roomField.value=''; } catch {}
                    appState.currentRoomId = null;
                    appState._prevPresenceCount = 0;
                    appState._multiPresenceSince = null;
                    leaveRoom();
                  } catch {}
                  cancelSoloLeave('completed');
                }, 800);
              }
            }
          }

          if (nowCount <= 1){
            // сбросим отметку стабилизации, чтобы новый звонок не наследовал старые значения
            if (!sameRoom) multiSince = null;
          }

          appState._prevPresenceCount = nowCount;
          appState._multiPresenceSince = nowCount >= 2 ? (multiSince || Date.now()) : multiSince;
          appState._lastPresenceRoom = roomId;
        } else {
          cancelSoloLeave('non-call-room');
          appState._prevPresenceCount = Array.isArray(msg.users) ? msg.users.length : 0;
          appState._multiPresenceSince = null;
          appState._lastPresenceRoom = roomId || null;
        }
      } catch {}
    } else if (msg.type === 'user_joined'){ log(`Присоединился: ${msg.userId}`); }
  else if (msg.type === 'user_left'){ log(`Отключился: ${msg.userId}`); const tile=document.querySelector(`.tile[data-peer="${msg.userId}"]`); if (tile) tile.remove(); try { updatePeerLayout(); } catch {} }
    else if (msg.type === 'chat'){
      const senderId = msg.fromUserId || msg.authorId;
      const who = msg.authorName || (senderId ? (appState.latestUserNames[senderId] || senderId.slice(0,6)) : 'unknown');
      let isSelf = false; const myConn = getStableConnId();
      if (senderId && senderId === myConn) isSelf = true; else {
        try { const storedU = localStorage.getItem('wc_username'); if (!senderId && storedU && storedU === msg.authorName) isSelf = true; if (!isSelf && storedU && storedU === msg.authorName && Date.now() - (window.__lastChatSendTs||0) < 1500) isSelf = true; } catch {}
      }
      appendChat(els.chat, who, msg.content, { self: isSelf });
    }
  };

  appState.ws.onclose = (ev) => {
    log(`WS закрыт: ${ev.code} ${ev.reason}`); setConnectedState(false); stopSpecialRingtone();
    if (appState.pingTimer) clearInterval(appState.pingTimer);
    if (appState.rtc) { appState.rtc.close(); appState.rtc = null; }
    try { stopStatsLoop(); } catch {}
    appState.ws = null; if (appState.peerCleanupIntervalId) { clearInterval(appState.peerCleanupIntervalId); appState.peerCleanupIntervalId=null; }
    cancelSoloLeave('ws-close');
    try {
      // Если закрылась эфемерная комната звонка — форсируем полный сброс сигналинга
      const rid = els.roomId?.value || '';
      if (/^call-/.test(rid) && forceResetCallEngine){ forceResetCallEngine(); }
      if (/^call-/.test(rid)){ try { els.roomId.value=''; } catch {} }
      appState.currentRoomId = null;
      appState._prevPresenceCount = 0;
      appState._multiPresenceSince = null;
      appState._lastPresenceRoom = null;
    } catch {}
    if (!appState.isManuallyDisconnected && !appState.isReconnecting){ appState.isReconnecting = true; log('Попытка переподключения через 3с...'); appState.reconnectTimeout = setTimeout(connectRoom, 3000); }
  };
  appState.ws.onerror = (err)=>{ log(`WS ошибка: ${err?.message||'unknown'}`); try { appState.ws?.close(); } catch {} };
}

// Привязка локальных дополнительных кнопок (камера/экран стоп и PiP)
document.addEventListener('click', (e)=>{
  const t = e.target;
  if (!(t instanceof HTMLElement)) return;
  if (t.id === 'btnStopCam'){
    try { appState.rtc?.stopCamera(); } catch {}
  } else if (t.id === 'btnStopScreen'){
    try { appState.rtc?.stopScreenShare(); } catch {}
  } else if (t.id === 'btnCompositeToggle'){
    try {
      const canvas = document.getElementById('localCompositeCanvas');
      appState.rtc?.toggleComposite(canvas);
      t.classList.toggle('btn-media-active');
    } catch {}
  }
});

// Обновление локального PiP (камера поверх экрана) при изменении треков
const _origOnVideoState = appState.rtc?.onVideoState;
// Уже встроено в onVideoState логика UI; PiP в локальном контейнере управляется в webrtc.js через _updateLocalPreview.

function safeReleaseMedia(el){
  try {
    if (!el) return;
    if (el.classList && el.classList.contains && el.classList.contains('tile')){
      const aud = el.querySelector('audio'); const vid = el.querySelector('video');
      try { safeReleaseMedia(aud); } catch {}; try { safeReleaseMedia(vid); } catch {}; return;
    }
    if (el instanceof HTMLMediaElement){
      try { const s = el._peerStream || el.srcObject; if (s && s.getTracks) s.getTracks().forEach(t=>{ try { t.stop(); } catch {} }); } catch {}
      try { el.pause(); } catch {}; try { el.srcObject=null; } catch {}; try { el.removeAttribute('src'); } catch {}; try { el.load?.(); } catch {}
    }
  } catch {}
}

function bindPeerMedia(peerId){
  if (document.querySelector(`.tile[data-peer="${peerId}"]`)) return;
  const tpl = document.getElementById('tpl-peer-tile');
  const tile = tpl.content.firstElementChild.cloneNode(true); tile.dataset.peer = peerId; els.peersGrid.appendChild(tile);
  try { updatePeerLayout(); } catch {}
  // Помечаем как компактный до первого успешного кадра
  tile.classList.add('initial-small');
  // Кнопка развёртывания для single-peer режима (создаём заранее, прячем если не нужно)
  let expandBtn = document.createElement('button');
  expandBtn.type='button';
  expandBtn.className='btn btn-fullscreen btn-expand-peer';
  expandBtn.textContent='↕';
  expandBtn.style.position='absolute';
  expandBtn.style.top='8px';
  expandBtn.style.right='8px';
  expandBtn.style.zIndex='7';
  expandBtn.style.opacity='0';
  expandBtn.style.transition='opacity .25s ease';
  expandBtn.addEventListener('click', ()=>{
    tile.classList.toggle('single-peer-expanded');
  });
  tile.appendChild(expandBtn);
  tile.addEventListener('mouseenter', ()=>{ if (tile.classList.contains('single-peer')) expandBtn.style.opacity='1'; });
  tile.addEventListener('mouseleave', ()=>{ expandBtn.style.opacity='0'; });
  const mainVideo = tile.querySelector('video.peer-main');
  const pipWrap = tile.querySelector('.pip');
  const pipVideo = tile.querySelector('video.peer-pip');
  const audio = tile.querySelector('audio');
  const name = tile.querySelector('.name');
  const vol = tile.querySelector('input[type="range"][name="volume"]');
  const level = tile.querySelector('.level-bar');
  name.textContent = appState.latestUserNames[peerId] || `user-${peerId.slice(0,6)}`;
  if (mainVideo){ mainVideo.playsInline=true; mainVideo.autoplay=true; mainVideo.muted=true; }
  if (pipVideo){ pipVideo.playsInline=true; pipVideo.autoplay=true; pipVideo.muted=true; }
  if (audio){ audio.autoplay=true; }

  // Локальное хранилище последнего распределения треков
  const assignTracks = (stream)=>{
    try {
      let vids = stream.getVideoTracks();
      // Подвязываем события mute/unmute/ended для динамической переразметки
      vids.forEach(t=>{
        if (!t._wcAssignBound){
          t._wcAssignBound = true;
          const reassign = (tag)=>{ log(`[diag] track ${tag} ${t.id} muted=${t.muted} ready=${t.readyState} peer=${peerId.slice(0,6)}`); setTimeout(()=> assignTracks(stream), 30); };
          t.addEventListener('ended', ()=> reassign('ended'));
          t.addEventListener('mute', ()=> reassign('mute'));
          t.addEventListener('unmute', ()=> reassign('unmute'));
        }
      });
      // Фильтруем завершённые и замьюченные (mute без кадров) треки
      const filtered = vids.filter(v => v.readyState === 'live' && !v.muted);
      if (filtered.length !== vids.length){
        log(`[diag] peer ${peerId.slice(0,6)} live(unmuted) tracks ${filtered.length}/${vids.length}`);
      }
      vids = filtered;
      log(`[diag] peer ${peerId.slice(0,6)} assignTracks vids=${vids.length} ids=[${vids.map(v=>v.id+':'+(v.label||'')).join(',')}]`);

      if (!vids.length){
        // Нет активных видеотреков: сбрасываем отображение (убираем последний кадр)
        if (mainVideo){
          try { mainVideo.pause(); } catch{}
          try { mainVideo.srcObject=null; } catch{}
          try { mainVideo.removeAttribute('src'); } catch{}
          try { mainVideo.load?.(); } catch{}
        }
        if (pipVideo){
          try { pipVideo.pause(); } catch{}
          try { pipVideo.srcObject=null; } catch{}
          try { pipVideo.removeAttribute('src'); } catch{}
          try { pipVideo.load?.(); } catch{}
        }
        if (pipWrap) pipWrap.style.display='none';
        tile.classList.add('no-remote-video');
        return;
      } else {
        tile.classList.remove('no-remote-video');
      }

      // Подписка на onended для автоматического пересчёта (один раз на трек)
      // (listeners уже навешаны выше вместе с mute/unmute)

      if (vids.length === 1){
        const ms = new MediaStream([vids[0]]);
        if (mainVideo && mainVideo.srcObject !== ms) mainVideo.srcObject = ms;
        if (pipWrap){ pipWrap.style.display='none'; if (pipVideo && pipVideo.srcObject){ pipVideo.srcObject=null; pipVideo.load?.(); } }
        return;
      }

      // Эвристика выбора экрана и камеры
      let screen = vids.find(v => /screen|display|window|share/i.test(v.label));
      let camera = vids.find(v => v !== screen);

      // Если эвристика по label не сработала: попробуем по настройкам (широкий трек считаем экраном)
      if (!screen && vids.length >= 2){
        try {
          const withRatio = vids.map(v=>{ const st=v.getSettings?.()||{}; return { v, ratio: (st.width||0) >= (st.height||0) ? (st.width||1)/(st.height||1) : 0 }; });
          // Экран обычно имеет высокий ratio (>=1.5)
          const candidate = withRatio.filter(o=> o.ratio >= 1.5).sort((a,b)=> b.ratio - a.ratio)[0];
          if (candidate){ screen = candidate.v; camera = vids.find(v=> v!==screen); }
        } catch {}
      }

      // Если всё ещё нет screen – просто берём первые два и считаем первый основным
      if (!screen){ screen = vids[0]; camera = vids.find(v=> v!==screen) || vids[0]; }

      // Если screen трек вдруг ended (мог закончиться между фильтрацией и выбором) – промоутим камеру в main
      if (screen.readyState !== 'live' && camera && camera.readyState === 'live'){
        screen = camera;
      }

      log(`[diag] peer ${peerId.slice(0,6)} screen=${screen && screen.id} camera=${camera && camera.id}`);
      const msScreen = new MediaStream([screen]);
      const msCam = camera && camera !== screen ? new MediaStream([camera]) : null;
      const manual = tile._manualSwap === true;
      if (!manual){
        if (mainVideo && mainVideo.srcObject !== msScreen) mainVideo.srcObject = msScreen;
        if (pipVideo && msCam){ pipVideo.srcObject = msCam; }
      } else {
        if (mainVideo && msCam && mainVideo.srcObject !== msCam) mainVideo.srcObject = msCam;
        if (pipVideo){ pipVideo.srcObject = msScreen; }
      }
      if (pipWrap) pipWrap.style.display = msCam ? '' : 'none';

      // Пост-эвристика: если вставили предполагаемый экран, но фактически кадры не идут → через 500мс свап
      try {
        if (mainVideo){
          setTimeout(()=>{
            try {
              if (!tile.isConnected) return; // уже удалён
              if (!tile._manualSwap && mainVideo.videoWidth === 0 && pipVideo && pipVideo.srcObject){
                log(`[diag] main video no frames, swapping with pip for ${peerId.slice(0,6)}`);
                const mvStream = mainVideo.srcObject; const pvStream = pipVideo.srcObject;
                if (pvStream){ mainVideo.srcObject = pvStream; }
                if (mvStream && msCam){ pipVideo.srcObject = mvStream; }
                tile._manualSwap = true;
              }
            } catch {}
          }, 500);
        }
      } catch {}
    } catch(e){ log(`assignTracks(${peerId.slice(0,6)}): ${e}`); }
  };

  // Ручной swap по двойному клику
  function manualSwap(){
    try {
      if (pipWrap && pipWrap.style.display === 'none') return; // нет второй дорожки
      const mv = mainVideo?.srcObject; const pv = pipVideo?.srcObject;
      if (!mv || !pv) return;
      mainVideo.srcObject = pv; pipVideo.srcObject = mv;
      tile._manualSwap = !tile._manualSwap;
      log(`[ui] manual swap peer ${peerId.slice(0,6)} => ${tile._manualSwap?'pip->main':'main->pip'}`);
    } catch(e){ log('manualSwap error '+e); }
  }
  if (mainVideo){ mainVideo.addEventListener('dblclick', manualSwap); }
  if (pipVideo){ pipVideo.addEventListener('dblclick', manualSwap); }

  appState.rtc.bindPeerMedia(peerId, {
    onTrack: (stream) => {
      log(`Получен медиа-поток от ${peerId.slice(0,6)}`); stopSpecialRingtone(); assignTracks(stream);
      try { updatePeerLayout(); } catch {}
      // Снимаем initial-small после появления первого кадра
      try {
        const v = tile.querySelector('video.peer-main');
        if (v){
          const onMeta = ()=>{ tile.classList.remove('initial-small'); v.removeEventListener('loadeddata', onMeta); };
          if (v.readyState >= 2){ tile.classList.remove('initial-small'); }
          else { v.addEventListener('loadeddata', onMeta); }
        }
      } catch {}
      if (audio){
        audio.srcObject=stream; try{ audio._peerStream=stream; }catch{}; audio.muted=false;
        audio.volume = vol ? (Math.min(100, Math.max(0, Number(vol.value)||100))/100) : 1.0;
        audio.play().catch(()=>{ unlockAudioPlayback(); setTimeout(()=> audio.play().catch(()=>{}), 250); });
      }
    },
    onLevel: (value)=>{ level.style.transform = `scaleX(${value})`; },
    onSinkChange: (deviceId)=>{ if (audio && audio.setSinkId){ audio.setSinkId(deviceId).catch(e=>log(`sinkAudio(${peerId.slice(0,6)}): ${e.name}`)); } }
  });
  if (vol && audio){ vol.addEventListener('input', ()=>{ const v = Math.min(100, Math.max(0, Number(vol.value)||0)); audio.volume = v/100; }); }
}

// Адаптация лэйаута: если один удалённый участник и нет screen share — делаем плитку широкой
function updatePeerLayout(){
  try {
    const tiles = Array.from(document.querySelectorAll('#peersGrid .tile'));
    const grid = document.getElementById('peersGrid');
    if (!grid) return;
    // Сортировка перед применением классов
    sortPeerTiles();
    // Сбрасываем классы
    tiles.forEach(t=> t.classList.remove('single-peer')); grid.classList.remove('layout-single-peer');
    if (tiles.length === 1){
      const t = tiles[0];
      t.classList.add('single-peer');
      grid.classList.add('layout-single-peer');
      // Показать кнопку expand если есть
      const btn = t.querySelector('.btn-expand-peer');
      if (btn){ btn.style.display=''; }
      // Подогнать ширину под локальное превью (если есть и видно)
      try {
        const localWrap = document.querySelector('#localCard .video-wrap');
        if (localWrap){
          const w = localWrap.getBoundingClientRect().width;
          if (w>0){ t.style.maxWidth = Math.round(w) + 'px'; }
        }
      } catch {}
    } else {
      // Скрыть expand кнопки
      tiles.forEach(t=>{ const btn=t.querySelector('.btn-expand-peer'); if (btn){ btn.style.display='none'; } t.classList.remove('single-peer-expanded'); try { t.style.removeProperty('max-width'); } catch {}; });
    }
  } catch {}
}

// Сортировка плиток по имени
function sortPeerTiles(){
  try {
    const grid = document.getElementById('peersGrid'); if (!grid) return;
    const tiles = Array.from(grid.querySelectorAll('.tile'));
    if (tiles.length < 2) return;
    const withNames = tiles.map(t=>({
      el: t,
      name: (t.querySelector('.name')?.textContent||'').toLowerCase(),
      peer: t.getAttribute('data-peer')||''
    }));
    withNames.sort((a,b)=> a.name.localeCompare(b.name, 'ru')); // сортировка по отображаемому имени
    const frag = document.createDocumentFragment();
    withNames.forEach(o=> frag.appendChild(o.el));
    grid.appendChild(frag);
  } catch {}
}

export function leaveRoom(){
  cancelSoloLeave('manual-leave');
  appState.isManuallyDisconnected = true;
  // Если активен AI Agent и мы не сделали manual summary — инициируем его перед уходом
  if (appState._aiAgent && appState.ws && appState.ws.readyState === WebSocket.OPEN){
    try {
      log('Leave: обнаружен активный AI Agent — выполняем финализацию перед выходом');
      // Остановить voice mixer и послать stop voice_capture
      try { if (appState.voiceMixer) appState.voiceMixer.stop(); } catch {}
      try { if (appState._voiceWs && appState._voiceWs.readyState === WebSocket.OPEN){ appState._voiceWs.send(JSON.stringify({ type:'stop', ts: Date.now() })); } } catch {}
      // Закрыть агентский WS присутствия
      try { appState._aiAgent.ws.close(1000,'leave'); } catch {}
      appState._aiAgent = null;
      // Отправить agent_summary и подождать ack (или 2.5с)
      let resolved = false;
      const waiter = new Promise(res=>{
        const to = setTimeout(()=>{ if (!resolved){ log('Leave: timeout ожидания agent_summary ack'); res(); } }, 2500);
        const handler = (ev)=>{
          try {
            const m = JSON.parse(ev.data);
            if (m.type === 'agent_summary_ack'){ resolved = true; clearTimeout(to); log(`Leave: получен ack summary status=${m.status}`); appState.ws.removeEventListener('message', handler); res(); }
          } catch {}
        };
        try { appState.ws.addEventListener('message', handler); } catch {}
      });
      // Небольшая задержка чтобы успел финализироваться транскрипт (если ещё идёт закрытие voice ws)
      setTimeout(()=>{
        try { appState.ws.send(JSON.stringify({ type:'agent_summary', ts: Date.now() })); log('Leave: отправлен agent_summary перед закрытием'); } catch {}
      }, 400);
      // Ждём завершения (не блокируем UI слишком долго — уже await)
      // eslint-disable-next-line no-unused-expressions
      waiter.then(()=>{ /* noop */ });
    } catch(e){ log('Leave: ошибка при финализации агента '+e); }
  }
  try {
    // Если это личный звонок (activeCall принят и roomId начинается с call-), шлём завершающий сигнал через friends WS
    const c = getActiveCall();
    if (c && c.status === 'accepted' && (c.roomId||'').startsWith('call-') && appState.friendsWs && appState.friendsWs.readyState===WebSocket.OPEN){
      const payload = { type:'call_end', roomId: c.roomId, toUserId: c.withUserId, reason:'leave' };
      appState.friendsWs.send(JSON.stringify(payload));
    }
  } catch {}
  // Принудительный сброс внутреннего signaling состояния для call-* комнат
  try {
    if (els.roomId && /^call-/.test(els.roomId.value)){
      forceResetCallEngine?.();
    }
  } catch {}
  const ws = appState.ws;
  try { ws?.send(JSON.stringify({ type:'leave', fromUserId: appState.userId })); } catch {}
  if (ws) ws.close();
  appState.ws = null;
  if (appState.rtc) { appState.rtc.close(); appState.rtc=null; }
  try { // Безопасно гасим локальное видео/шаринг (если остались треки)
    if (appState.rtc?.stopVideo) appState.rtc.stopVideo();
  } catch {}
  setConnectedState(false);
  try { els.peersGrid.querySelectorAll('.tile').forEach(t=> safeReleaseMedia(t)); } catch {}
  els.peersGrid.innerHTML=''; log('Отключено'); if (appState.peerCleanupIntervalId){ clearInterval(appState.peerCleanupIntervalId); appState.peerCleanupIntervalId=null; }
  if (getActiveCall()) resetActiveCall('leave');
  try {
    appState._prevPresenceCount = 0;
    appState._multiPresenceSince = null;
    appState._lastPresenceRoom = null;
    appState.callAutoLeaveRoom = null;
  } catch {}
  try { loadVisitedRooms(); } catch {}
}

// ===== Friends WS =====
function startFriendsWs(){
  log('🔧 startFriendsWs вызвана');
  
  // Предотвращаем множественные одновременные подключения
  if (appState.friendsWs && appState.friendsWs.readyState === WebSocket.OPEN) {
    log('Friends WS: уже подключен и активен');
    return; 
  }
  
  if (appState.friendsWsConnecting) {
    log('Friends WS: подключение уже в процессе');
    return;
  }
  
  const t = localStorage.getItem('wc_token'); 
  if (!t) {
    log('❌ Friends WS: токен не найден, пропуск подключения');
    appState.friendsWsConnecting = false;
    return;
  }
  
  log('✅ Friends WS: токен найден, продолжаем подключение');
  
  // Закрываем старое соединение если оно есть
  if (appState.friendsWs) {
    log('Friends WS: закрываем старое соединение');
    try {
      appState.friendsWs.onclose = null; // Убираем обработчик чтобы не вызвать переподключение
      appState.friendsWs.close();
    } catch (e) {
      log('Ошибка при закрытии старого WS:', e);
    }
    appState.friendsWs = null;
  }
  
  appState.friendsWsConnecting = true;
  const connectStartTime = Date.now();
  
  const proto = location.protocol === 'https:' ? 'wss' : 'ws';
  const url = new URL(`${proto}://${location.host}/ws/friends`); url.searchParams.set('token', t);
  log(`🔗 Friends WS: подключение к ${url.toString()}`);
  
  try {
    log('🔧 Создание WebSocket объекта...');
    appState.friendsWs = new WebSocket(url.toString());
    log('✅ WebSocket объект создан успешно');
    
    // Таймаут для подключения - если за 10 секунд не подключились, сбрасываем флаг
    const connectTimeout = setTimeout(() => {
      if (appState.friendsWsConnecting) {
        log('Friends WS: таймаут подключения, сбрасываем флаг connecting');
        appState.friendsWsConnecting = false;
        if (appState.friendsWs && appState.friendsWs.readyState === WebSocket.CONNECTING) {
          try { appState.friendsWs.close(); } catch {}
        }
      }
    }, 10000);
    
    appState.friendsWs.onopen = ()=>{ 
      const connectTime = Date.now() - connectStartTime;
      log(`✅ WS друзей открыт за ${connectTime}ms`); 
      clearTimeout(connectTimeout);
      // Сбрасываем счетчик попыток и флаг подключения при успешном подключении
      appState.wsReconnectAttempts = 0;
      appState.friendsWsConnecting = false;
      
      try { 
        appState.friendsWs.send(JSON.stringify({ type:'ping' })); 
        log('📤 Friends WS: ping отправлен');
      } catch (e) {
        log('❌ Friends WS: ошибка отправки ping:', e);
      }
    };
  appState.friendsWs.onmessage = async (ev)=>{
    try { 
      const msg = JSON.parse(ev.data); 
      if (!msg || typeof msg !== 'object') return; 
      // Глобальный сырой лог входящих сообщений друзей
      try {
        if (!window.__WS_RAW_MESSAGES) window.__WS_RAW_MESSAGES = [];
        window.__WS_RAW_MESSAGES.push({ ts: Date.now(), msg });
        if (window.__WS_RAW_MESSAGES.length > 500) window.__WS_RAW_MESSAGES.splice(0, window.__WS_RAW_MESSAGES.length-500);
      } catch {}
      
      // Подсчитываем сообщения
      if (!window.__FRIENDS_WS_STATS) window.__FRIENDS_WS_STATS = { total: 0, byType: {} };
      window.__FRIENDS_WS_STATS.total++;
      window.__FRIENDS_WS_STATS.byType[msg.type] = (window.__FRIENDS_WS_STATS.byType[msg.type] || 0) + 1;
      
      // Обновляем счётчик сообщений в appState для панели дебага
      appState.friendsWsMessageCount = window.__FRIENDS_WS_STATS.total;
      appState.lastFriendsMessage = msg;
      
      // Отправляем в панель дебага
      if (window.debugPanel) {
        window.debugPanel.logFriendsMessage(msg.type, msg, 'incoming');
      }
      
      // Логируем все входящие сообщения
      log(`📥 Friends WS message: ${msg.type} (всего: ${window.__FRIENDS_WS_STATS.total})`);
      
      switch(msg.type){
        case 'presence_snapshot':
          try { setOnlineSnapshot(msg.userIds || []); refreshFriendStatuses(); } catch{}
          break;
        case 'presence_join':
          try { addOnlineUser(msg.userId); refreshFriendStatuses(); } catch{}
          break;
        case 'presence_leave':
          try { removeOnlineUser(msg.userId); refreshFriendStatuses(); } catch{}
          break;
        case 'friend_request': case 'friend_accepted': case 'friend_cancelled': scheduleFriendsReload(); break;
        case 'friend_removed': scheduleFriendsReload(); break;
  case 'direct_message': handleIncomingDirect(msg); try { const acc=getAccountId(); const other= msg.fromUserId === acc ? msg.toUserId : msg.fromUserId; markFriendSeen(other); const isActiveChat = appState.currentDirectFriend && other === appState.currentDirectFriend; const iAmRecipient = msg.toUserId === acc; if (iAmRecipient && !isActiveChat && 'Notification' in window && Notification.permission==='granted'){ const title = 'Новое сообщение'; const body = msg.fromUsername ? `От ${msg.fromUsername}` : 'Личное сообщение'; const reg = await navigator.serviceWorker.getRegistration('/static/sw.js'); if (reg && reg.showNotification){ reg.showNotification(title, { body, data:{ type:'direct', from: other } }); } else { new Notification(title, { body, data:{ type:'direct', from: other } }); } } } catch {} break;
        case 'direct_cleared': handleDirectCleared(msg); break;
        case 'call_invite':
        case 'call_accept':
        case 'call_decline':
        case 'call_cancel':
        case 'call_end': {
          log(`📞 Call signal: ${msg.type} from ${msg.fromUserId} to ${msg.toUserId}`);
          try { const acc=getAccountId(); const other = msg.fromUserId === acc ? msg.toUserId : msg.fromUserId; markFriendSeen(other); } catch {}
          try { handleCallSignal(msg); } catch (e) { log(`❌ Error handling call signal: ${e.message}`); }
          break;
        }
        default: 
          log(`❓ Unknown message type: ${msg.type}`);
          break;
      } 
    } catch (e) {
      log(`❌ Error parsing Friends WS message: ${e.message}`);
    }
  };
    appState.friendsWs.onclose = (event)=>{ 
      log(`Friends WS закрыт: код=${event.code}, причина=${event.reason}`);
      appState.friendsWs = null; 
      appState.friendsWsConnecting = false;
      
      // Не переподключаемся если:
      // - страница выгружается (beforeunload/unload)
      // - код закрытия 1000 (нормальное закрытие) или 1001 (going away)
      // - нет токена авторизации
      // - слишком много попыток переподключения
      const maxReconnectAttempts = 10;
      if (document.visibilityState === 'hidden' || 
          event.code === 1000 || 
          event.code === 1001 ||
          !localStorage.getItem('wc_token') ||
          (appState.wsReconnectAttempts || 0) >= maxReconnectAttempts) {
        log('Friends WS: не переподключаемся, причина:', { 
          visibilityState: document.visibilityState, 
          code: event.code,
          hasToken: !!localStorage.getItem('wc_token'),
          attempts: appState.wsReconnectAttempts || 0,
          maxAttempts: maxReconnectAttempts
        });
        return;
      }
      
      // Увеличиваем интервал переподключения для предотвращения спама
      const reconnectDelay = Math.min(30000, 5000 * (appState.wsReconnectAttempts || 1));
      appState.wsReconnectAttempts = (appState.wsReconnectAttempts || 0) + 1;
      
      log(`Friends WS: переподключение через ${reconnectDelay}ms (попытка ${appState.wsReconnectAttempts}/${maxReconnectAttempts})`);
      setTimeout(()=>{ 
        if (!appState.friendsWs && !appState.friendsWsConnecting && localStorage.getItem('wc_token')) {
          try { startFriendsWs(); } catch {} 
        }
      }, reconnectDelay); 
    };
    appState.friendsWs.onerror = (error)=>{ 
      log('Friends WS ошибка:', error);
      clearTimeout(connectTimeout);
      appState.friendsWsConnecting = false;
      // Закрываем соединение при ошибке
      try { 
        if (appState.friendsWs) {
          appState.friendsWs.close(); 
        } 
      } catch {}; 
    };
  } catch (error) {
    log('Friends WS: ошибка создания соединения:', error);
    appState.friendsWs = null;
    appState.friendsWsConnecting = false;
    // Не делаем автоматический ретрай при ошибке создания
  }
}

async function ensureProfile(){
  try { const t = localStorage.getItem('wc_token'); const hasEmail = !!localStorage.getItem('wc_email'); const hasName = !!localStorage.getItem('wc_username'); if (t && (!hasEmail || !hasName)){ const me = await getMe(); if (me?.email) localStorage.setItem('wc_email', me.email); if (me?.username) localStorage.setItem('wc_username', me.username); } } catch {}
}

// ===== User badge (header current user) =====
function updateUserBadge(){
  try {
    const name = localStorage.getItem('wc_username');
    if (name && els.currentUserBadge && els.currentUsername){
      els.currentUsername.textContent = name;
      els.currentUserBadge.style.display = 'inline-flex';
    } else if (els.currentUserBadge){
      els.currentUserBadge.style.display = 'none';
    }
  } catch {}
}
try { window.updateUserBadge = updateUserBadge; } catch {}

// ===== UI Setup =====
function setupUI(){
  els.btnConnect?.addEventListener('click', ()=>{ unlockAudioPlayback(); connectRoom(); });
  els.btnLeave?.addEventListener('click', leaveRoom);
  els.btnCopyLink?.addEventListener('click', ()=>{ const url = new URL(location.href); url.searchParams.set('room', els.roomId.value); navigator.clipboard.writeText(url.toString()); log('Ссылка скопирована'); });
  els.btnSend?.addEventListener('click', ()=>{ const text = els.chatInput.value; if (text && appState.ws){ (signal.sendChat || (()=>{}))(appState.ws, text, getStableConnId()); try { window.__lastChatSendTs = Date.now(); } catch {}; els.chatInput.value=''; } });
  els.chatInput?.addEventListener('keydown', e=>{ if (e.key==='Enter') els.btnSend.click(); });
  els.btnToggleMic?.addEventListener('click', async ()=>{ if (!appState.rtc) return; const enabled = await appState.rtc.toggleMic(); els.btnToggleMic.textContent = enabled ? 'Выкл.микро' : 'Вкл.микро'; });
  els.btnToggleCam?.addEventListener('click', async ()=>{ if (!appState.rtc) return; const on = await appState.rtc.toggleCameraStream(); els.btnToggleCam.textContent = on ? '🎥 Камера выкл' : '🎥 Камера'; });
  els.btnScreenShare?.addEventListener('click', async ()=>{ if (!appState.rtc) return; const sharing = await appState.rtc.toggleScreenShare(); els.btnScreenShare.textContent = sharing ? '🛑 Остановить' : '🖥 Экран'; });
  // === AI Agent toggle ===
  els.btnAiAgent?.addEventListener('click', async () => {
    if (!appState.currentRoomId){ log('AI Agent: сначала подключитесь к комнате'); return; }
    // Проверяем привязку Telegram (однократно перед первой активацией агента)
    try {
      const ok = await ensureTelegramLinked();
      if (!ok){ log('AI Agent: запуск отменён — нет подтверждения Telegram'); return; }
    } catch(e){ log('AI Agent: ошибка проверки Telegram '+e); }
    // 1-й клик: активирует агента и поток голосовых чанков. 2-й клик: останавливает и шлёт manual summary.
    if (!appState._aiAgent){
      // Подключаем
      try {
        const token = localStorage.getItem('wc_token');
        if (!token){
          log('VoiceCapture: отсутствует токен — голосовой поток не будет запущен (frontend gate)');
        }
        // Детерминированный UUID агента на стороне клиента, синхронно с серверной формулой (uuid5 по namespace URL недоступен тут, поэтому просто локально генерируем и кешируем на комнату)
        // Сервер всё равно переопределит на свой стабильный UUID для room+agent
        const agentId = (()=>{
          try {
            const key = 'wc_agent_id_'+appState.currentRoomId;
            let v = sessionStorage.getItem(key);
            if (!v){ v = crypto.randomUUID(); sessionStorage.setItem(key, v); }
            return v;
          } catch { return crypto.randomUUID(); }
        })();
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        const url = new URL(`${proto}://${location.host}/ws/rooms/${encodeURIComponent(appState.currentRoomId)}`);
        if (token) url.searchParams.set('token', token);
        url.searchParams.set('agent','1');
        const ws = new WebSocket(url.toString());
        appState._aiAgent = { ws, id: agentId, active: true };
        log(`AI Agent: подключение (id=${agentId})...`);
        // Инициализируем / перезапускаем голосовой захват (важно корректно работать при повторных запусках)
        try {
          // Отмена отложенного закрытия, если пользователь быстро перезапускает агента
            if (appState._voiceCloseTimer){
              clearTimeout(appState._voiceCloseTimer);
              appState._voiceCloseTimer = null;
              log('VoiceCapture: отменено отложенное закрытие предыдущей сессии');
            }

          if (token){
            if (!appState.voiceMixer){
              appState.voiceMixer = new VoiceCaptureMixer({
                getPeers: ()=> appState.rtc?.peers,
                getLocalStream: ()=> appState.rtc?.localStream,
                chunkMs: 5000,
                onLog: (m)=> log(m),
                onChunk: (bytes)=>{
                  try {
                    if (appState._voiceWs && appState._voiceWs.readyState === WebSocket.OPEN){
                      appState._voiceWs.send(bytes);
                      appState._voiceChunkCount = (appState._voiceChunkCount||0)+1;
                      if ((appState._voiceChunkCount % 5) === 0){ log(`VoiceCapture: отправлено чанков=${appState._voiceChunkCount}`); }
                    }
                  } catch {}
                }
              });
            }
          } else {
            log('AI Agent: voice mixer и WS не создаются без токена');
          }

          // Функция запуска новой сессии (отправляет start даже при reuse WS)
          const startVoiceSession = () => {
            if (!token){
              log('VoiceCapture: попытка запустить session без токена — отклонено');
              return;
            }
            appState._voiceSessionSeq = (appState._voiceSessionSeq||0) + 1;
            appState._voiceChunkCount = 0;
            const sid = appState._voiceSessionSeq;
            const accId = getAccountId();
            const canonicalKey = `${appState.currentRoomId}:${accId||'unknown'}`;
            log(`VoiceCapture: start session #${sid} canonicalKey=${canonicalKey}`);
            try {
              appState._voiceWs?.send(JSON.stringify({ type:'start', roomId: appState.currentRoomId, ts: Date.now(), session: sid }));
            } catch {}
            try { appState.voiceMixer.start(); } catch {}
          };

          if (token){
            const needNew = !appState._voiceWs || [WebSocket.CLOSING, WebSocket.CLOSED].includes(appState._voiceWs.readyState);
            if (needNew){
              if (appState._voiceWs && appState._voiceWs.readyState === WebSocket.CLOSING){
                try { appState._voiceWs.close(); } catch {}
              }
              const base = location.origin.replace('http','ws');
              const url = `${base}/ws/voice_capture/${encodeURIComponent(appState.currentRoomId)}?token=${encodeURIComponent(token||'')}`;
              appState._voiceWs = new WebSocket(url);
              appState._voiceWs.binaryType = 'arraybuffer';
              appState._voiceWs.onopen = () => {
                log('VoiceCapture WS открыт (new)');
                startVoiceSession();
              };
              appState._voiceWs.onclose = () => { log('VoiceCapture WS закрыт'); try { appState.voiceMixer?.stop(); } catch {}; appState._voiceWs = null; };
              appState._voiceWs.onerror = () => { log('VoiceCapture WS ошибка'); };
            } else if (appState._voiceWs.readyState === WebSocket.CONNECTING){
              log('VoiceCapture: reuse CONNECTING WS – session будет запущена после onopen');
              try {
                appState._voiceWs.addEventListener('open', ()=> startVoiceSession(), { once:true });
              } catch {}
            } else if (appState._voiceWs.readyState === WebSocket.OPEN){
              log('VoiceCapture: reuse OPEN WS');
              startVoiceSession();
            }
          } else {
            log('VoiceCapture: пропуск создания WS (нет токена)');
          }
        } catch(e){ log(`VoiceMixer init/restart error: ${e}`); }
        ws.onopen = () => {
          log('AI Agent: WS открыт');
          try { ws.send(JSON.stringify({ type:'join', fromUserId: agentId, username: 'AI AGENT' })); } catch {}
          els.btnAiAgent?.classList.add('btn-media-active');
          els.btnAiAgent.textContent = 'AI Agent ✓';
        };
        ws.onmessage = ev => {
          try {
            const msg = JSON.parse(ev.data);
            if (msg.type === 'signal'){ /* агент сейчас пассивен */ }
            else if (msg.type === 'chat'){ /* не реагируем */ }
          } catch {}
        };
        ws.onclose = ev => { log(`AI Agent: закрыт (${ev.code})`); if (appState._aiAgent){ appState._aiAgent.active = false; appState._aiAgent = null; } els.btnAiAgent?.classList.remove('btn-media-active'); els.btnAiAgent && (els.btnAiAgent.textContent='AI Agent'); };
        ws.onerror = e => { log('AI Agent: ошибка WS'); };
      } catch (e){ log(`AI Agent: ошибка подключения: ${e}`); }
    } else {
      // Второй клик → завершаем сбор и триггерим agent_summary
      log('AI Agent: второй клик — завершаем и триггерим summary');
      try { if (appState.voiceMixer){ appState.voiceMixer.stop(); } } catch {}
      try { if (appState._voiceWs && appState._voiceWs.readyState === WebSocket.OPEN){ appState._voiceWs.send(JSON.stringify({ type:'stop', ts: Date.now() })); } } catch {}
      // Закрываем WS агента присутствия
      try { appState._aiAgent.ws.close(1000,'manual'); } catch {}
      appState._aiAgent = null;
      // Ждём ~600мс чтобы сервер успел финализировать транскрипт
      setTimeout(()=>{
        try {
          if (appState._voiceWs && appState._voiceWs.readyState === WebSocket.OPEN){
            try { appState._voiceWs.close(1000,'manual'); } catch {}
          }
          if (appState.ws && appState.ws.readyState === WebSocket.OPEN){
            log('AI Agent: отправляем type=agent_summary');
            appState.ws.send(JSON.stringify({ type:'agent_summary', ts: Date.now() }));
          } else {
            log('AI Agent: основной WS не готов для agent_summary');
          }
        } catch(e){ log('AI Agent: ошибка manual summary '+e); }
      }, 650);
      els.btnAiAgent?.classList.remove('btn-media-active');
      if (els.btnAiAgent) els.btnAiAgent.textContent='AI Agent (summary sent)';
    }
  });
  els.btnToggleTheme?.addEventListener('click', ()=>{
    // Цикл тем: light -> dark -> red -> light (визуально один кружок меняет цвет)
    const body = document.body;
    let mode = localStorage.getItem('theme') || 'light';
    if (mode === 'light'){
      mode='dark';
      body.classList.add('dark');
      body.classList.remove('theme-red');
    } else if (mode === 'dark'){
      mode='red';
      body.classList.remove('dark');
      body.classList.add('theme-red');
    } else {
      mode='light';
      body.classList.remove('dark','theme-red');
    }
    localStorage.setItem('theme', mode);
    if (els.btnToggleTheme){ els.btnToggleTheme.title = 'Тема: '+mode; }
  });
  els.btnLogout?.addEventListener('click', ()=>{ try { localStorage.removeItem('wc_token'); localStorage.removeItem('wc_username'); } catch {}; try { sessionStorage.removeItem('wc_connid'); } catch {}; if (appState.ws){ try { appState.ws.close(); } catch {} } const params = new URLSearchParams({ redirect:'/call' }); if (els.roomId.value) params.set('room', els.roomId.value); location.href = `/auth?${params.toString()}`; });

  // user gesture unlock
  const runPendingAutoplay = ()=>{ const tasks = appState.pendingAutoplayTasks.slice(); appState.pendingAutoplayTasks=[]; tasks.forEach(t=>{ try { t(); } catch {} }); };
  const gestureUnlock = ()=>{ appState.userGestureHappened = true; try { unlockAudioPlayback(); } catch {}; try { runPendingAutoplay(); } catch {}; document.removeEventListener('click', gestureUnlock, { capture:true }); document.removeEventListener('touchstart', gestureUnlock, { capture:true }); document.removeEventListener('keydown', gestureUnlock, { capture:true }); };
  document.addEventListener('click', gestureUnlock, { once:true, capture:true });
  document.addEventListener('touchstart', gestureUnlock, { once:true, capture:true });
  document.addEventListener('keydown', gestureUnlock, { once:true, capture:true });
  const onHidden = ()=>{ try { appState.pendingAutoplayTasks=[]; } catch {}; try { stopSpecialRingtone(); } catch {}; };
  document.addEventListener('visibilitychange', ()=>{ if (document.hidden) onHidden(); });
  window.addEventListener('pagehide', onHidden, { capture:true });
  // Применяем сохранённую тему
  try {
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme === 'dark'){
      document.body.classList.add('dark');
      document.body.classList.remove('theme-red');
    } else if (savedTheme === 'red'){
      document.body.classList.add('theme-red');
      document.body.classList.remove('dark');
    } else {
      document.body.classList.remove('dark','theme-red');
    }
    if (els.btnToggleTheme){ els.btnToggleTheme.title = 'Тема: '+(savedTheme||'light'); }
  } catch {}
  const u = new URL(location.href); if (u.searchParams.has('room')) els.roomId.value = u.searchParams.get('room');
  showPreJoin();

  // Делегирование кликов для кнопок полноэкранного режима (локальное и peer видео)
  try {
    document.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-action="fullscreen"], button[data-action="fullscreen-local"]');
      if (!btn) return;
      e.preventDefault();
      let container = null;
      if (btn.dataset.action === 'fullscreen-local') {
        container = document.getElementById('localCard')?.querySelector('.video-wrap') || document.getElementById('localCard');
      } else {
        container = btn.closest('.tile');
      }
      if (!container) return;
      const enter = () => {
        try { container.requestFullscreen?.(); } catch {}
        container.classList.add('fullscreen-active');
      };
      const exitMark = () => { container.classList.remove('fullscreen-active'); };
      if (document.fullscreenElement) {
        if (document.fullscreenElement === container) {
          document.exitFullscreen().catch(()=>{}).then(exitMark);
        } else {
          document.exitFullscreen().catch(()=>{}).then(()=> enter());
        }
      } else {
        enter();
      }
    });
    document.addEventListener('fullscreenchange', ()=>{
      if (!document.fullscreenElement) {
        document.querySelectorAll('.fullscreen-active').forEach(el => el.classList.remove('fullscreen-active'));
      }
    });
  } catch {}

  // Принудительная попытка воспроизведения локального видео (фикс черного экрана при некоторых политиках автоплея)
  try {
    const vid = document.getElementById('localVideo');
    if (vid) {
      vid.addEventListener('loadedmetadata', ()=>{ vid.play().catch(()=>{}); });
      setTimeout(()=>{ if (vid.paused) vid.play().catch(()=>{}); }, 800);
    }
  } catch {}

  // === Горячие клавиши медиа ===
  try {
    document.addEventListener('keydown', (e)=>{
      if (e.metaKey || e.ctrlKey || e.altKey) return;
      const tag = (e.target && e.target.tagName || '').toLowerCase();
      if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) return;
      switch(e.key){
        case 'm': // toggle mic
          if (appState.rtc){ appState.rtc.toggleMic(); showToast && showToast('Микрофон: toggle', 'info'); }
          break;
        case 'c': // toggle camera
          if (appState.rtc){ appState.rtc.toggleCameraStream(); showToast && showToast('Камера: toggle', 'info'); }
          break;
        case 's': // toggle screen
          if (appState.rtc){ appState.rtc.toggleScreenShare(); showToast && showToast('Экран: toggle', 'info'); }
          break;
        case 'x': // stop screen explicitly
          if (appState.rtc && appState.rtc._screenTrack){ appState.rtc.stopScreenShare(); showToast && showToast('Экран: стоп', 'info'); }
          break;
        case 'k': // stop camera explicitly
          if (appState.rtc && appState.rtc._cameraTrack){ appState.rtc.stopCamera(); showToast && showToast('Камера: стоп', 'info'); }
          break;
        case 'M': // Shift+M → composite toggle (регистр различается)
          if (appState.rtc){
            const canvas = document.getElementById('localCompositeCanvas');
            appState.rtc.toggleComposite(canvas);
            showToast && showToast('Composite: toggle', 'info');
            const btn = document.getElementById('btnCompositeToggle'); if (btn){ btn.classList.toggle('btn-media-active', appState.rtc._compositeEnabled); }
          }
          break;
        default: return;
      }
    });
  } catch {}

  // === Панель настроек отображения ===
  try {
    // Вставляем кнопку-шестерёнку рядом с кнопкой выхода
    if (els.btnLogout && !document.getElementById('btnUiSettings')){
      const gearBtn = document.createElement('button');
      gearBtn.id='btnUiSettings';
      gearBtn.title='Настройки отображения';
      gearBtn.textContent='⚙';
      gearBtn.style.marginLeft='6px';
      gearBtn.className='btn btn-sm btn-secondary';
      els.btnLogout.parentElement?.insertBefore(gearBtn, els.btnLogout);
      let panel = document.createElement('div');
      panel.id='uiSettingsPanel';
      panel.style.position='fixed';
      panel.style.top='50px';
      panel.style.right='20px';
      panel.style.background='#202124';
      panel.style.color='#fff';
      panel.style.padding='14px 16px';
      panel.style.borderRadius='10px';
      panel.style.boxShadow='0 8px 24px rgba(0,0,0,.35)';
      panel.style.display='none';
      panel.style.zIndex='2000';
      panel.style.minWidth='220px';
    panel.innerHTML = '<div style="font-weight:600;margin-bottom:8px">Отображение</div>';
    const container = document.createElement('div');
  container.style.display='flex';
  container.style.flexWrap='wrap';
  container.style.gap='6px';
      const groups = [
        { id:'logs', label:'Логи' },
        { id:'stats', label:'Статистика' },
        { id:'chat', label:'Чат' },
        { id:'friendsCard', label:'Друзья' },
        { id:'visitedCard', label:'Недавние' },
        { id:'statusCard', label:'Статус' },
        { id:'directChatCard', label:'Личные сообщения' },
      ];
      const prefsKey = 'wc_ui_panels_v1';
      const loadPrefs = ()=>{ try { return JSON.parse(localStorage.getItem(prefsKey)||'{}'); } catch { return {}; } };
      const savePrefs = (p)=>{ try { localStorage.setItem(prefsKey, JSON.stringify(p)); } catch {} };
      const apply = (prefs)=>{
        groups.forEach(g=>{
          // Базовый элемент (например logs, stats, chat)
            const base = els[g.id] || document.getElementById(g.id);
            // Альтернативный элемент c суффиксом Card (например logsCard)
            const alt = document.getElementById(g.id + 'Card');
            // Если базовый элемент вложен в card/panel – найдём ближайшего родителя
            const containers = [];
            if (base) containers.push(base);
            if (alt && alt !== base) containers.push(alt);
            // Собираем потенциальные обёртки
            const wrappers = new Set();
            for (const node of containers){
              if (!node) continue;
              // Ищем ближайшего родителя с классом card или panel
              let p = node;
              while (p && p !== document.body){
                if (p.classList && (p.classList.contains('card') || p.classList.contains('panel'))){ wrappers.add(p); break; }
                p = p.parentElement;
              }
            }
            const shouldShow = prefs[g.id] !== false;
            // Применяем display для всех собранных элементов
            [...wrappers, ...containers].forEach(el=>{ if (el) el.style.display = shouldShow ? '' : 'none'; });
        });
      };
      let prefs = loadPrefs();
      // Если первый запуск (нет ключей) — скрываем логи и статус по умолчанию
      if (!prefs || Object.keys(prefs).length === 0){
        prefs = { logs:false, statusCard:false };
        savePrefs(prefs);
      }
      groups.forEach(g=>{
        const wrap = document.createElement('label');
        wrap.style.display='inline-flex';
        wrap.style.alignItems='center';
        wrap.style.border='1px solid #404449';
        wrap.style.borderRadius='18px';
        wrap.style.padding='4px 10px 4px 8px';
        wrap.style.fontSize='12px';
        wrap.style.background='#2a2d31';
        wrap.style.cursor='pointer';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.checked = prefs[g.id] !== false; cb.style.marginRight='6px'; cb.style.accentColor='#4fa3ff';
        cb.addEventListener('change', ()=>{ const p=loadPrefs(); p[g.id] = cb.checked; savePrefs(p); apply(p); });
        wrap.appendChild(cb); wrap.appendChild(document.createTextNode(g.label)); container.appendChild(wrap);
      });
    panel.appendChild(container);
    // Кнопка перехода в профиль
    const profBtn = document.createElement('button');
  profBtn.type='button';
  profBtn.textContent='Изменить данные';
  profBtn.style.marginTop='10px';
  profBtn.style.width='100%';
  profBtn.style.background='#1fa060';
  profBtn.style.color='#fff';
  profBtn.style.border='none';
  profBtn.style.padding='8px 10px';
  profBtn.style.borderRadius='6px';
  profBtn.style.cursor='pointer';
      profBtn.addEventListener('click', (e)=>{ e.stopPropagation(); location.href='/static/profile.html'; });
      panel.appendChild(profBtn);
      document.body.appendChild(panel);
      gearBtn.addEventListener('click', ()=>{ panel.style.display = panel.style.display==='none' ? 'block' : 'none'; });
      document.addEventListener('click', (e)=>{ if (!panel.contains(e.target) && e.target!==gearBtn){ if (panel.style.display==='block') panel.style.display='none'; } }, { capture:true });
      apply(prefs);
      // Добавляем дополнительные блоки (Telegram / AI Prompt) отложенно, чтобы не было ReferenceError до создания панели
      try { initSettingsExtras(panel); } catch(e){ console.warn('initSettingsExtras error', e); }
    }
  } catch {}
}

// ===== Telegram linking (AI summary delivery) =====
// Доп. UI элементы (кнопка отвязки и prompt) инициализируем только после создания панели настроек.
function initSettingsExtras(panel){
  if (!panel) return;
  // Предотвращаем повторную инициализацию
  if (panel._extrasInitialized) return; panel._extrasInitialized = true;

  // Кнопка отвязки Telegram (появляется если уже был confirmed)
  const tgRevokeBtn = document.createElement('button');
  tgRevokeBtn.type='button';
  tgRevokeBtn.textContent='Отвязать Telegram';
  tgRevokeBtn.style.marginTop='8px';
  tgRevokeBtn.style.width='100%';
  tgRevokeBtn.style.background='#7a2d2d';
  tgRevokeBtn.style.color='#fff';
  tgRevokeBtn.style.border='none';
  tgRevokeBtn.style.padding='8px 10px';
  tgRevokeBtn.style.borderRadius='6px';
  tgRevokeBtn.style.cursor='pointer';
  tgRevokeBtn.addEventListener('click', async (e)=>{
    e.stopPropagation();
    try {
      const st = await getTelegramStatus();
      if (st.status !== 'confirmed') { showToast('Telegram не привязан', 'warn'); return; }
      if (!confirm('Вы уверены, что хотите отвязать Telegram? Придётся привязывать заново для получения summary.')) return;
      tgRevokeBtn.disabled = true; tgRevokeBtn.textContent='Отвязываем...';
      try {
        await revokeTelegramLink();
        showToast('Telegram отвязан', 'info');
        appState.telegramLinked = false; appState.telegramLinkChecked = false;
      } catch(e2){ showToast('Ошибка отвязки: '+e2.message, 'error'); }
    } finally { tgRevokeBtn.disabled=false; tgRevokeBtn.textContent='Отвязать Telegram'; }
  });
  panel.appendChild(tgRevokeBtn);

  // Блок настроек AI System Prompt
  const promptWrap = document.createElement('div');
  promptWrap.style.marginTop='14px';
  promptWrap.style.padding='8px 10px';
  promptWrap.style.background='#26292e';
  promptWrap.style.border='1px solid #3a3f44';
  promptWrap.style.borderRadius='8px';
  promptWrap.innerHTML = '<div style="font-weight:600;margin-bottom:6px;">AI Summary Prompt</div>'
    +'<div style="font-size:11px;color:#bbb;line-height:1.3;margin-bottom:6px;">Настраиваемый системный prompt для оценки встречи. Используется при генерации выжимки (OpenAI). Оставьте пустым или нажмите Сброс — вернётся стандартный. Ниже можно посмотреть текст стандартного и итогового (учитывая очистку/кастомизацию) prompt.</div>'
    +'<textarea id="aiPromptTxt" style="width:100%;min-height:90px;resize:vertical;background:#1e2124;color:#fff;border:1px solid #3a3f44;border-radius:6px;padding:6px;font:12px/1.4 system-ui, sans-serif;outline:none;"></textarea>'
    +'<div style="display:flex;gap:8px;margin-top:6px;">'
    +'<button id="aiPromptSave" class="btn btn-primary" style="flex:1;">Сохранить</button>'
    +'<button id="aiPromptReset" class="btn btn-secondary" style="flex:0 0 auto;">Сброс</button>'
    +'</div>'
  +'<div style="display:flex;gap:6px;margin-top:6px;">'
  +'<button id="aiPromptClear" class="btn btn-secondary" style="flex:0 0 auto;font-size:11px;padding:4px 8px;">Очистить</button>'
  +'<div style="flex:1;font-size:10px;color:#777;align-self:center;text-align:right;">Пустое поле = стандартный</div>'
  +'</div>'
    +'<div id="aiPromptStatus" style="margin-top:4px;font-size:11px;color:#888;">&nbsp;</div>'
    +'<details id="aiPromptDetails" style="margin-top:6px;">'
      +'<summary style="cursor:pointer;font-size:12px;color:#ccc;">Показать стандартный и итоговый prompt</summary>'
      +'<div style="margin-top:6px;">'
        +'<div style="font-size:11px;color:#8fa;">Стандартный:</div>'
        +'<pre id="aiPromptDefault" style="white-space:pre-wrap;max-height:160px;overflow:auto;background:#1e2124;padding:6px;border:1px solid #3a3f44;border-radius:6px;font:11px/1.35 ui-monospace,monospace;color:#d0d0d0;"></pre>'
        +'<div style="font-size:11px;color:#8fa;margin-top:8px;">Итоговый (effective):</div>'
        +'<pre id="aiPromptEffective" style="white-space:pre-wrap;max-height:160px;overflow:auto;background:#1e2124;padding:6px;border:1px solid #3a3f44;border-radius:6px;font:11px/1.35 ui-monospace,monospace;color:#d0d0d0;"></pre>'
      +'</div>'
    +'</details>';
  panel.appendChild(promptWrap);

  async function loadPrompt(){
    const token = localStorage.getItem('wc_token'); if (!token) return;
    const stEl = document.getElementById('aiPromptStatus'); if (stEl) stEl.textContent='Загрузка...';
    let data = null;
    try {
      const r = await fetch('/api/v1/ai/prompt', { headers:{ 'Authorization':'Bearer '+token } });
      if (!r.ok) throw new Error('HTTP '+r.status);
      data = await r.json();
      const ta = document.getElementById('aiPromptTxt');
      if (ta) ta.value = data.is_default ? '' : (data.prompt||'');
      if (stEl) stEl.textContent = data.is_default ? 'Используется стандартный prompt' : 'Кастомный prompt активен';
      // Заполняем блоки просмотра
      try {
        const defEl = document.getElementById('aiPromptDefault');
        const effEl = document.getElementById('aiPromptEffective');
        if (defEl) defEl.textContent = data.default_prompt || '';
        if (effEl) effEl.textContent = data.effective_prompt || (data.prompt || '');
      } catch {}
    } catch(e){ const stEl2 = document.getElementById('aiPromptStatus'); if (stEl2) stEl2.textContent='Ошибка загрузки prompt'; }
    return data;
  }
  loadPrompt();
  const saveBtn = document.getElementById('aiPromptSave');
  const resetBtn = document.getElementById('aiPromptReset');
  const clearBtn = document.getElementById('aiPromptClear');
  saveBtn?.addEventListener('click', async ()=>{
    const token = localStorage.getItem('wc_token'); if (!token) return;
    const ta = document.getElementById('aiPromptTxt'); if (!ta) return;
    const val = ta.value.trim();
    const stEl = document.getElementById('aiPromptStatus'); if (stEl) stEl.textContent='Сохранение...';
    try {
      const r = await fetch('/api/v1/ai/prompt', { method:'PUT', headers:{ 'Authorization':'Bearer '+token, 'Content-Type':'application/json' }, body: JSON.stringify({ prompt: val }) });
      if (!r.ok){ const txt = await r.text(); throw new Error(txt); }
      const data = await r.json();
      if (data.is_default) ta.value='';
      if (stEl) stEl.textContent = data.is_default ? 'Сохранён стандартный prompt' : 'Сохранён кастомный prompt';
      // Обновляем просмотр
      try {
        const defEl = document.getElementById('aiPromptDefault');
        const effEl = document.getElementById('aiPromptEffective');
        if (defEl) defEl.textContent = data.default_prompt || '';
        if (effEl) effEl.textContent = data.effective_prompt || (data.prompt || '');
        if (ta && defEl && data.is_default){ ta.placeholder = defEl.textContent; }
      } catch {}
      showToast('Prompt сохранён', 'info');
    } catch(e){ const stEl2 = document.getElementById('aiPromptStatus'); if (stEl2) stEl2.textContent='Ошибка сохранения'; showToast('Ошибка сохранения prompt', 'error'); }
  });
  resetBtn?.addEventListener('click', async ()=>{
    const token = localStorage.getItem('wc_token'); if (!token) return;
    const ta = document.getElementById('aiPromptTxt'); if (!ta) return;
    const stEl = document.getElementById('aiPromptStatus'); if (stEl) stEl.textContent='Сброс...';
    try {
      const r = await fetch('/api/v1/ai/prompt', { method:'DELETE', headers:{ 'Authorization':'Bearer '+token } });
      if (!r.ok) throw new Error('HTTP '+r.status);
      const data = await r.json();
      ta.value='';
      if (stEl) stEl.textContent='Используется стандартный prompt';
      try {
        const defEl = document.getElementById('aiPromptDefault');
        const effEl = document.getElementById('aiPromptEffective');
        if (defEl) defEl.textContent = data.default_prompt || '';
        if (effEl) effEl.textContent = data.effective_prompt || (data.prompt || '');
        if (ta && defEl){ ta.placeholder = defEl.textContent; }
      } catch {}
      showToast('Prompt сброшен', 'info');
    } catch(e){ const stEl2 = document.getElementById('aiPromptStatus'); if (stEl2) stEl2.textContent='Ошибка сброса'; showToast('Ошибка сброса prompt', 'error'); }
  });
  clearBtn?.addEventListener('click', ()=>{
    const ta = document.getElementById('aiPromptTxt'); if (!ta) return; ta.value=''; const stEl = document.getElementById('aiPromptStatus'); if (stEl) stEl.textContent='Поле очищено (не сохранено)';
  });
  // Устанавливаем placeholder после первой загрузки
  (async ()=>{
    try {
      const d = await loadPrompt();
      const ta = document.getElementById('aiPromptTxt');
      const defEl = document.getElementById('aiPromptDefault');
      if (ta && defEl){ ta.placeholder = defEl.textContent || ''; }
    } catch {}
  })();
}
async function fetchJson(url, opts){
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error('HTTP '+r.status);
  return r.json();
}

async function getTelegramStatus(){
  try {
    const token = localStorage.getItem('wc_token');
    if (!token) return { status: 'absent' };
    return await fetchJson('/api/v1/telegram/status', { headers:{ 'Authorization':'Bearer '+token } });
  } catch { return { status: 'absent' }; }
}

async function createTelegramLink(){
  const token = localStorage.getItem('wc_token'); if (!token) throw new Error('no token');
  const data = await fetchJson('/api/v1/telegram/link', { method:'POST', headers:{ 'Content-Type':'application/json', 'Authorization':'Bearer '+token } });
  return data; // { token, deeplink, expires_at }
}

async function revokeTelegramLink(){
  const token = localStorage.getItem('wc_token'); if (!token) throw new Error('no token');
  return await fetchJson('/api/v1/telegram/link', { method:'DELETE', headers:{ 'Authorization':'Bearer '+token } });
}
async function pollTelegramStatus(timeoutMs=60000, intervalMs=2000){
  const started = Date.now();
  while (Date.now() - started < timeoutMs){
    const st = await getTelegramStatus();
    if (st.status === 'confirmed') return st;
    await new Promise(r=> setTimeout(r, intervalMs));
  }
  return { status:'timeout' };
}

async function ensureTelegramLinked(){
  // Кешируем успешную проверку в appState, чтобы не дергать каждый клик
  if (appState.telegramLinkChecked && appState.telegramLinked) return true;
  const st = await getTelegramStatus();
  if (st.status === 'confirmed'){ appState.telegramLinked=true; appState.telegramLinkChecked=true; return true; }

  // Показываем модал (простой overlay) с инструкцией
  let overlay = document.getElementById('tgLinkOverlay');
  if (!overlay){
    overlay = document.createElement('div');
    overlay.id='tgLinkOverlay';
    overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.background='rgba(0,0,0,.55)'; overlay.style.zIndex='5000'; overlay.style.display='flex'; overlay.style.alignItems='center'; overlay.style.justifyContent='center';
    overlay.innerHTML = '<div id="tgLinkModal" style="background:#1e2227;padding:22px 26px;border-radius:14px;max-width:480px;width:100%;box-shadow:0 10px 34px rgba(0,0,0,.45);font:14px/1.4 system-ui,sans-serif;color:#fff;">'
      +'<div style="font-size:18px;font-weight:600;margin-bottom:10px;">Подключение Telegram</div>'
      +'<div id="tgLinkBody">'
      +'Чтобы получать итоговую выжимку в Telegram — свяжите аккаунт. Нажмите кнопку ниже и в открывшемся боте отправьте команду /start.<br><br>'
      +'<b>Шаги:</b><ol style="padding-left:18px;margin:6px 0 10px 0;">'
      +'<li>Открыть бота</li>'
      +'<li>Нажать Start и отправить /start (токен подставится автоматически)</li>'
      +'<li>Вернуться сюда — статус обновится</li>'
      +'</ol>'
      +'</div>'
      +'<div id="tgLinkActions" style="display:flex;gap:10px;align-items:center;margin-top:8px;">'
      +'<button id="btnTgOpen" class="btn btn-primary">Открыть Telegram</button>'
      +'<button id="btnTgRecheck" class="btn btn-secondary" disabled>Ожидание...</button>'
      +'<button id="btnTgCancel" class="btn btn-secondary">Отмена</button>'
      +'</div>'
      +'<div id="tgLinkStatus" style="margin-top:10px;font-size:12px;color:#aaa;">Статус: not linked</div>'
      +'</div>';
    document.body.appendChild(overlay);
  } else {
    overlay.style.display='flex';
  }

  const btnOpen = overlay.querySelector('#btnTgOpen');
  const btnRecheck = overlay.querySelector('#btnTgRecheck');
  const btnCancel = overlay.querySelector('#btnTgCancel');
  const statusEl = overlay.querySelector('#tgLinkStatus');
  const bodyEl = overlay.querySelector('#tgLinkBody');

  let deeplinkData = null;
  async function prepareLink(){
    try {
      btnOpen.disabled = true; btnOpen.textContent='Генерация...';
      deeplinkData = await createTelegramLink();
      btnOpen.disabled = false; btnOpen.textContent='Открыть Telegram';
      statusEl.textContent = 'Статус: ожидание подтверждения';
    } catch(e){
      statusEl.textContent = 'Ошибка создания ссылки: '+e;
      btnOpen.disabled=false; btnOpen.textContent='Повторить';
    }
  }
  await prepareLink();

  function closeOverlay(){ overlay.style.display='none'; }

  btnCancel.onclick = ()=>{ closeOverlay(); };
  btnOpen.onclick = ()=>{
    if (!deeplinkData){ prepareLink(); return; }
    try { window.open(deeplinkData.deeplink, '_blank'); } catch {}
    // Запускаем polling
    btnRecheck.disabled = false; btnRecheck.textContent='Проверить';
    statusEl.textContent = 'Статус: ждём подтверждения...';
  };
  btnRecheck.onclick = async ()=>{
    btnRecheck.disabled = true; btnRecheck.textContent='Проверка...';
    const st2 = await getTelegramStatus();
    if (st2.status === 'confirmed'){
      statusEl.textContent = '✅ Привязано! Можно запускать AI Agent.';
      appState.telegramLinked = true; appState.telegramLinkChecked = true;
      setTimeout(()=>{ closeOverlay(); }, 800);
    } else {
      statusEl.textContent = 'Пока не подтверждено. Попробуйте ещё раз через пару секунд.';
      btnRecheck.disabled = false; btnRecheck.textContent='Проверить';
    }
  };

  // Автоматический polling (до 60с) после открытия modala — не блокирует UI
  (async ()=>{
    try {
      const res = await pollTelegramStatus(60000, 3000);
      if (res.status === 'confirmed'){
        statusEl.textContent = '✅ Привязано!';
        appState.telegramLinked = true; appState.telegramLinkChecked = true;
        setTimeout(()=>{ closeOverlay(); }, 800);
      }
    } catch {}
  })();

  // Возвращаем false (ещё не привязан)
  return false;
}

// ===== Public init =====
export async function appInit(){
  log('🚀 Начало инициализации приложения');
  setConnectedState(false);
  setupUI();
  refreshDevices();
  log('✅ Приложение инициализировано');

  // Инициализация модуля звонков (хуки для подключения комнаты и аудио)
  try { initCallModule({ reloadFriends: loadFriends, unlockAudioPlayback, connectRoom }); } catch {}
  try {
    initCallSignaling({
      getAccountId,
      unlockAudio: unlockAudioPlayback,
      navigateToRoom: (roomId)=>{
        try {
          if (!roomId) return;
          // Если мы НЕ на странице /call – делаем переход с параметром
          if (!location.pathname.startsWith('/call')){
            const url = new URL(location.origin + '/call');
            url.searchParams.set('room', roomId);
            log(`navigateToRoom: redirect to ${url.toString()}`);
            location.href = url.toString();
            return;
          }
          // Уже на /call: выставляем значение в input при необходимости
            if (els.roomId && els.roomId.value !== roomId){
              els.roomId.value = roomId;
              log(`navigateToRoom: roomId input set to ${roomId}`);
            }
          // Если уже есть WS и это тот же room – ничего не делаем
          if (appState.ws){
            if (appState.currentRoomId && appState.currentRoomId === roomId){
              log('navigateToRoom: already connected to this room');
              return;
            }
            // Иначе попытка переподключиться: аккуратно закрываем и откроем заново
            try { log('navigateToRoom: switching room, closing existing ws'); appState.ws.close(); } catch {}
            appState.ws = null;
          }
          // Подключаемся
          try { appState.currentRoomId = roomId; } catch {}
          connectRoom();
          // Fallback: если через 1.2с не подключены к нужной комнате – повторяем попытку
          setTimeout(()=>{
            try {
              const need = roomId;
              const have = appState.currentRoomId;
              if (need === roomId && (!appState.ws || appState.ws.readyState !== WebSocket.OPEN)){
                log('navigateToRoom fallback retry connectRoom');
                if (!appState.ws) connectRoom();
              }
            } catch {}
          }, 1200);
        } catch(e){ log('navigateToRoom error: '+ (e?.message||e)); }
      }
    });
  } catch {}

  initDirectChatModule({ log, getAccountId });
  try { bindSendDirect(); } catch {}
  initFriendsModule({ log, unlockAudioPlayback, connectRoom });
  try { initFriendsUI(); } catch {}

  loadVisitedRooms().catch(()=>{});
  checkAndRequestPermissionsInitial();
  try { initPush(); } catch {}
  await ensureProfile();
  try { updateUserBadge(); } catch {}
  
  // Делаем showToast и startFriendsWs доступными глобально для удобства использования из других модулей
  try {
    window.showToast = showToast;
    window.startFriendsWs = startFriendsWs;
    window.appState = appState; // Для диагностики
    window.resetCallSystem = resetCallEngine;
    window.forceResetCall = forceResetCallEngine;
    window.hangup = hangupCall;

    // Добавляем функцию диагностики WebSocket (для отладки)
    window.debugWebSocket = () => {
      const ws = window.appState?.friendsWs;
      const connecting = window.appState?.friendsWsConnecting;
      const token = localStorage.getItem('wc_token');
      const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
      const info = {
        hasToken: !!token,
        hasWebSocket: !!ws,
        wsState: ws ? states[ws.readyState] || ws.readyState : 'не создан',
        connecting: connecting,
        url: ws ? ws.url : 'нет',
        reconnectAttempts: window.appState?.wsReconnectAttempts || 0,
        visibilityState: document.visibilityState
      };
      console.log('🔍 WebSocket диагностика:', info);
      showToast(`WS: ${info.wsState}${info.connecting ? ' (подключается)' : ''}, Token: ${info.hasToken ? 'есть' : 'нет'}, Попыток: ${info.reconnectAttempts}`, 'info');
      
      // Показываем состояние звонков если доступно
      try {
        if (window.getCallState) {
          const callState = window.getCallState();
          console.log('📞 Состояние звонков:', callState);
        }
      } catch {}
      
      return info;
    };
    
    // Функция полной диагностики
    window.debugCalls = () => {
      const wsInfo = window.debugWebSocket();
      
      console.log('🔧 Системная информация:', {
        userAgent: navigator.userAgent,
        online: navigator.onLine,
        connectionType: navigator?.connection?.effectiveType || 'unknown'
      });
      
      console.log('📡 Доступность API звонков:', {
        notifyCall: typeof window.notifyCall !== 'undefined',
        startOutgoingCall: typeof window.startOutgoingCall !== 'undefined',
        getCallState: typeof window.getCallState !== 'undefined'
      });
      
      return wsInfo;
    };
    
    // Функция для принудительного переподключения
    window.forceReconnectWebSocket = () => {
      console.log('🔄 Принудительное переподключение WebSocket...');
      if (window.appState?.friendsWs) {
        window.appState.friendsWs.onclose = null;
        window.appState.friendsWs.close();
      }
      window.appState.friendsWs = null;
      window.appState.friendsWsConnecting = false;
      window.appState.wsReconnectAttempts = 0;
      startFriendsWs();
      showToast('Принудительное переподключение WebSocket', 'info');
    };
    
    // Функция для тестирования Friends WebSocket
    window.testFriendsWS = () => {
      const ws = window.appState?.friendsWs;
      if (!ws) {
        console.log('❌ Friends WebSocket не создан');
        return false;
      }
      
      const states = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
      const state = states[ws.readyState] || 'UNKNOWN';
      console.log(`🔍 Friends WebSocket состояние: ${state} (${ws.readyState})`);
      
      if (ws.readyState === WebSocket.OPEN) {
        try {
          ws.send(JSON.stringify({ type: 'test_message', timestamp: Date.now() }));
          console.log('📤 Тестовое сообщение отправлено');
          return true;
        } catch (e) {
          console.log(`❌ Ошибка отправки: ${e.message}`);
          return false;
        }
      } else {
        console.log('⚠️ WebSocket не в состоянии OPEN');
        return false;
      }
    };
    
    // Функция для получения статистики Friends WebSocket
    window.getFriendsWSStats = () => {
      const ws = window.appState?.friendsWs;
      const stats = window.__FRIENDS_WS_STATS || { total: 0, byType: {} };
      
      return {
        websocket: {
          exists: !!ws,
          state: ws ? ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'][ws.readyState] : 'NOT_CREATED',
          url: ws?.url || null,
          connecting: window.appState?.friendsWsConnecting || false,
          reconnectAttempts: window.appState?.wsReconnectAttempts || 0
        },
        messages: stats,
        token: !!localStorage.getItem('wc_token')
      };
    };
  } catch {}
  
  // Предотвращаем переподключения при закрытии страницы
  window.addEventListener('beforeunload', () => {
    if (appState.friendsWs) {
      appState.friendsWs.onclose = null; // Отключаем автопереподключение
      appState.friendsWs.close(1000, 'Page unload');
    }
  });
  
  log('🔗 Инициализация WebSocket друзей...');
  startFriendsWs();
  try { await loadFriends(); } catch {}
  // Подписка на статистику
  try {
    bus.on('stats:sample', (s)=>{
      if (!els.stats) return;
      const last = s.peers.map(p=> `${p.peerId.slice(0,6)} in:${formatBitrate(p.inAudioBitrate)} out:${formatBitrate(p.outAudioBitrate)} lossIn:${p.packetLossIn!=null?(p.packetLossIn*100).toFixed(1)+'%':'-'} rtt:${p.rtt!=null?Math.round(p.rtt)+'ms':'-'}`).join(' | ');
      appendLog(els.stats, `STATS ${new Date(s.ts).toLocaleTimeString()} ${last}`);
    });
  } catch {}
  // SW уведомления → открыть чат
  try { if ('serviceWorker' in navigator){ navigator.serviceWorker.addEventListener('message', (e)=>{ const data=e.data||{}; if (data.type==='openDirect' && data.userId){ const open=()=> selectDirectFriend(data.userId, data.userId, { force:true }).catch(()=>{}); if (els.friendsList && els.friendsList.children.length) open(); else setTimeout(open,300); } }); } } catch {}
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\app_init.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\dom.js =====
--- SIZE: 5632 bytes ---

// core/dom.js
// Сбор ссылок на DOM и простые утилиты для текстов, логов, кнопок.

export const els = {
  roomId: document.getElementById('roomId'),
  btnConnect: document.getElementById('btnConnect'),
  btnLeave: document.getElementById('btnLeave'),
  btnCopyLink: document.getElementById('btnCopyLink'),
  btnSend: document.getElementById('btnSend'),
  chatInput: document.getElementById('chatInput'),
  connStatus: document.getElementById('connStatus'),
  callContext: document.getElementById('callContext'),
  logs: document.getElementById('logs'),
  chat: document.getElementById('chat'),
  btnToggleMic: document.getElementById('btnToggleMic'),
  btnToggleCam: document.getElementById('btnToggleCam'),
  btnScreenShare: document.getElementById('btnScreenShare'),
  localVideo: document.getElementById('localVideo'),
  peersGrid: document.getElementById('peersGrid'),
  stats: document.getElementById('stats'),
  micSel: document.getElementById('micSel'),
  camSel: document.getElementById('camSel'),
  spkSel: document.getElementById('spkSel'),
  btnAiAgent: document.getElementById('btnAiAgent'),
  btnToggleTheme: document.getElementById('btnToggleTheme'),
  btnLogout: document.getElementById('btnLogout'),
  currentUserBadge: document.getElementById('currentUserBadge'),
  currentUsername: document.getElementById('currentUsername'),
  membersList: document.getElementById('membersList'),
  visitedRooms: document.getElementById('visitedRooms'),
  friendsCard: document.getElementById('friendsCard'),
  friendsList: document.getElementById('friendsList'),
  friendRequests: document.getElementById('friendRequests'),
  friendSearch: document.getElementById('friendSearch'),
  btnFriendSearch: document.getElementById('btnFriendSearch'),
  friendSearchResults: document.getElementById('friendSearchResults'),
  preJoinControls: document.getElementById('preJoinControls'),
  inCallControls: document.getElementById('inCallControls'),
  inCallSection: document.getElementById('inCallSection'),
  visitedCard: document.getElementById('visitedCard'),
  statusCard: document.getElementById('statusCard'),
  directChatCard: document.getElementById('directChatCard'),
  directChatTitle: document.getElementById('directChatTitle'),
  directMessages: document.getElementById('directMessages'),
  directInput: document.getElementById('directInput'),
  btnDirectSend: document.getElementById('btnDirectSend'),
  directActions: document.getElementById('directActions'),
  permBanner: document.getElementById('permBanner'),
  toastRegion: document.getElementById('toastRegion'),
};

export function setText(el, text){ if (el) el.textContent = text; }
export function setEnabled(btn, enabled){ if (btn) btn.disabled = !enabled; }
export function appendLog(container, msg){
  if (!container) return;
  const line = document.createElement('div');
  line.className = 'log-line';
  const t = document.createElement('span'); t.className = 'time'; t.textContent = new Date().toLocaleTimeString();
  const m = document.createElement('span'); m.className = 'msg'; m.textContent = msg;
  line.appendChild(t); line.appendChild(m);
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}
export function appendChat(container, who, content, opts={}){
  if (!container) return;
  const div = document.createElement('div'); div.className = 'chat-line' + (opts.self ? ' self' : '');
  const w = document.createElement('span'); w.className = 'who'; w.textContent = who;
  const c = document.createElement('span'); c.className = 'msg'; c.textContent = content;
  const tm = document.createElement('span'); tm.className = 'time'; tm.textContent = new Date().toLocaleTimeString();
  div.appendChild(w); div.appendChild(c); div.appendChild(tm);
  container.appendChild(div);
  container.scrollTop = container.scrollHeight;
}
export function bind(el, evt, fn){ if (el) el.addEventListener(evt, fn); }

export function makeBtn(label, cls='btn', onClick){
  const b = document.createElement('button'); b.className = cls; b.textContent = label; b.addEventListener('click', onClick); return b;
}

// ===== Toast / уведомления =====
/**
 * Показ краткого toast сообщения поверх интерфейса.
 * Автоматически создаёт контейнер если отсутствует.
 * @param {string} message
 * @param {{ type?: 'info'|'success'|'error', timeoutMs?: number }} [opts]
 */
export function showToast(message, opts={}){
  const { type='info', timeoutMs = 3500 } = opts;
  let region = els.toastRegion;
  if (!region){
    region = document.createElement('div');
    region.id = 'toastRegion';
    region.setAttribute('role','status');
    region.setAttribute('aria-live','polite');
    region.style.position='fixed';
    region.style.top='14px';
    region.style.right='14px';
    region.style.display='flex';
    region.style.flexDirection='column';
    region.style.gap='10px';
    region.style.zIndex='400';
    document.body.appendChild(region);
    els.toastRegion = region;
  }
  const item = document.createElement('div');
  item.className = `wc-toast wc-toast-${type}`;
  item.textContent = message;
  item.style.cursor='pointer';
  item.addEventListener('click', ()=>{ try { region.removeChild(item); } catch {} });
  region.appendChild(item);
  setTimeout(()=>{ try { item.classList.add('leaving'); } catch {}; setTimeout(()=>{ try { region.removeChild(item); } catch {}; }, 320); }, timeoutMs);
}


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\dom.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\event_bus.js =====
--- SIZE: 2718 bytes ---

// core/event_bus.js
// Лёгкая внутренняя шина событий поверх window.dispatchEvent.
// Унифицирует имена и даёт удобные on/off/once/waitFor + JSDoc типы.

/**
 * Префикс всех внутренних событий. Стараемся придерживаться пространства имён 'wc:'.
 * Сами имена без префикса передаём в on/emit: emit('join-room').
 */
const PREFIX = 'wc:';
const target = window;

/**
 * @typedef {(
 *  | 'join-room'
 *  | 'rtc-ready'
 *  | 'stats:sample'
 * )} BusEventName
 *
 * Дополняй список по мере появления новых доменных событий.
 */

/**
 * @template T
 * @param {string} name
 * @param {T} [detail]
 */
export function emit(name, detail){
  const evName = name.startsWith(PREFIX) ? name : PREFIX + name;
  target.dispatchEvent(new CustomEvent(evName, { detail }));
}

/**
 * @template T
 * @param {string} name
 * @param {(detail: T, ev: CustomEvent)=>void} handler
 * @param {AddEventListenerOptions | boolean} [opts]
 * @returns {() => void} off fn
 */
export function on(name, handler, opts){
  const evName = name.startsWith(PREFIX) ? name : PREFIX + name;
  const wrap = (e)=>{ try { handler(e.detail, e); } catch {} };
  target.addEventListener(evName, wrap, opts);
  return ()=> off(name, wrap, opts);
}

/**
 * Одноразовый обработчик.
 * @template T
 * @param {string} name
 * @param {(detail: T, ev: CustomEvent)=>void} handler
 * @returns {() => void} off fn (досрочно отменить)
 */
export function once(name, handler){
  let offFn = on(name, (d,e)=>{ offFn && offFn(); handler(d,e); }, { once:true });
  return offFn;
}

/**
 * @param {string} name
 * @param {EventListenerOrEventListenerObject} handler
 * @param {EventListenerOptions | boolean} [opts]
 */
export function off(name, handler, opts){
  const evName = name.startsWith(PREFIX) ? name : PREFIX + name;
  try { target.removeEventListener(evName, handler, opts); } catch {}
}

/**
 * Promise-утилита: ждём событие (или таймаут).
 * @template T
 * @param {string} name
 * @param {number} [timeoutMs]
 * @returns {Promise<T>}
 */
export function waitFor(name, timeoutMs){
  return new Promise((resolve, reject)=>{
    let timer = null;
    const offFn = once(name, (d)=>{ if (timer) clearTimeout(timer); resolve(d); });
    if (timeoutMs){ timer = setTimeout(()=>{ offFn(); reject(new Error('waitFor timeout: '+name)); }, timeoutMs); }
  });
}

export const bus = { emit, on, once, off, waitFor };

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\event_bus.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\message_contracts.js =====
--- SIZE: 1907 bytes ---

// core/message_contracts.js
// Типовые структуры сообщений WebSocket (JSDoc) для документации и навигации.

/**
 * @typedef {Object} WsChatMessage
 * @property {'chat'} type
 * @property {string} content
 * @property {string} [fromUserId]
 * @property {string} [authorId]
 * @property {string} [authorName]
 */

/**
 * @typedef {Object} WsPresenceMessage
 * @property {'presence'} type
 * @property {string[]} users
 * @property {Record<string,string>} userNames
 */

/**
 * @typedef {Object} WsSignalEnvelope
 * @property {'signal'} type
 * @property {string} fromUserId
 * @property {string} targetUserId
 * @property {'offer'|'answer'|'ice-candidate'|'ice_candidate'} signalType
 * @property {string} [sdp]
 * @property {RTCIceCandidateInit} [candidate]
 */

/**
 * @typedef {Object} FriendDirectMessage
 * @property {'direct_message'} type
 * @property {string} id
 * @property {string} fromUserId
 * @property {string} toUserId
 * @property {string} [fromUsername]
 * @property {string} [toUsername]
 * @property {string} ciphertext
 * @property {string} [created_at]
 */

/**
 * @typedef {Object} FriendCallInvite
 * @property {'call_invite'} type
 * @property {string} roomId
 * @property {string} fromUserId
 * @property {string} toUserId
 * @property {string} [fromUsername]
 * @property {string} [toUsername]
 */

/**
 * @typedef {Object} FriendCallAccept
 * @property {'call_accept'} type
 * @property {string} roomId
 */

/**
 * @typedef {Object} FriendCallDecline
 * @property {'call_decline'|'call_cancel'} type
 * @property {string} roomId
 */

/**
 * @typedef {(
 *  WsChatMessage | WsPresenceMessage | WsSignalEnvelope |
 *  FriendDirectMessage | FriendCallInvite | FriendCallAccept | FriendCallDecline
 * )} AnyInboundMessage
 */

export {}; // только типы

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\message_contracts.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\state.js =====
--- SIZE: 3754 bytes ---

// @ts-check
// core/state.js
// Глобальное состояние приложения (раньше было в main.js). Никакой DOM-логики.

/** @typedef {Object} SpecialInviteState
 *  @property {HTMLAudioElement|null} ringtone
 *  @property {number|null} timer
 *  @property {boolean} active
 *  @property {boolean} playing
 *  @property {Promise<any>|null} readyPromise
 *  @property {number} session
 */

/** @typedef {Object} ActiveCallState
 *  @property {string} roomId
 *  @property {string} withUserId
 *  @property {string=} username
 *  @property {'incoming'|'outgoing'} direction
 *  @property {'invited'|'accepted'|'declined'} status
 */

/** @typedef {Object} AppState
 *  @property {string|null} token
 *  @property {WebSocket|null} ws
 *  @property {import('../../webrtc.js').WebRTCManager|null} rtc
 *  @property {string|null} userId
 *  @property {string|null} accountId
 *  @property {number|null} reconnectTimeout
 *  @property {boolean} isManuallyDisconnected
 *  @property {number|null} pingTimer
 *  @property {boolean} isReconnecting
 *  @property {{ mic: string|null, cam: string|null, spk: string|null }} selected
 *  @property {boolean} audioUnlocked
 *  @property {AudioContext|null} globalAudioCtx
 *  @property {boolean} audioGestureAllowed
 *  @property {Record<string,string>} latestUserNames
 *  @property {WebSocket|null} friendsWs
 *  @property {boolean} friendsWsConnecting
 *  @property {number} wsReconnectAttempts
 *  @property {string|null} currentDirectFriend
 *  @property {Map<string,number>} recentOffer
 *  @property {number|null} peerCleanupIntervalId
 *  @property {Map<string,number>} directSeenByFriend
 *  @property {Map<string,number>} directUnread
 *  @property {SpecialInviteState} special
 *  @property {boolean} userGestureHappened
 *  @property {Array<Function>} pendingAutoplayTasks
 *  @property {ActiveCallState|null} activeCall
 *  @property {Map<string, any>} pendingIncomingInvites
 *  @property {number|null} callAutoLeaveTimer
 *  @property {string|null} callAutoLeaveRoom
 *  @property {string|null} currentRoomId
 *  @property {number|null} _multiPresenceSince
 *  @property {number} _prevPresenceCount
 *  @property {string|null} _lastPresenceRoom
 */

/** @type {AppState} */
export const appState = {
  token: null,
  ws: null,
  // Добавлены JSDoc типы для облегчения навигации/перехода на TS.

  rtc: null,
  userId: null,          // stable connId (session scope)
  accountId: null,       // account (JWT sub)
  reconnectTimeout: null,
  isManuallyDisconnected: false,
  pingTimer: null,
  isReconnecting: false,
  selected: { mic: null, cam: null, spk: null },
  audioUnlocked: false,
  globalAudioCtx: null,
  audioGestureAllowed: false,
  latestUserNames: {},
  friendsWs: null,
  friendsWsConnecting: false,
  wsReconnectAttempts: 0,
  currentDirectFriend: null,
  recentOffer: new Map(),
  peerCleanupIntervalId: null,
  directSeenByFriend: new Map(),
  directUnread: new Map(),
  // Ringtone / special invite state
  special: {
    ringtone: null,
    timer: null,
    active: false,
    playing: false,
    readyPromise: null,
    session: 0,
  },
  userGestureHappened: false,
  pendingAutoplayTasks: [],
  // Call state
  activeCall: null, // { roomId, withUserId, direction, status }
  pendingIncomingInvites: new Map(),
  callAutoLeaveTimer: null,
  callAutoLeaveRoom: null,
  currentRoomId: null,
  _multiPresenceSince: null,
  _prevPresenceCount: 0,
  _lastPresenceRoom: null,
};

export function resetTransient(){
  appState.recentOffer.clear();
  appState.pendingIncomingInvites.clear();
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\core\state.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\direct_chat.js =====
--- SIZE: 9976 bytes ---

// modules/direct_chat.js
// Логика личного чата (direct messages): выбор друга, загрузка истории, отправка, приём, unread.

import { els } from './core/dom.js';
import { appState } from './core/state.js';
// Клиентское E2EE отключено для DM: сервер возвращает plaintext.

// Внешние хуки (интеграция с друзьями и логами)
let hooks = {
  log: (msg)=>{},          // (string)
  getAccountId: ()=> null, // () => account UUID (JWT sub)
};

export function initDirectChatModule(options={}){ hooks = { ...hooks, ...options }; }

function updateFriendUnreadBadge(friendId){
  const btn = document.querySelector(`button.chat-btn[data-friend-id="${friendId}"]`);
  if (!btn) return;
  const count = appState.directUnread.get(friendId) || 0;
  if (count > 0){
    btn.classList.add('has-unread');
    btn.dataset.unread = String(count);
  } else {
    btn.classList.remove('has-unread');
    delete btn.dataset.unread;
  }
}

function appendDirectMessage(m, isSelf){
  if (!els.directMessages) return;
  const div = document.createElement('div');
  div.className = 'chat-line' + (isSelf ? ' self' : '');
  const dt = new Date(m.sent_at || m.sentAt || Date.now());
  const ts = dt.toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
  const full = dt.toLocaleString();
  const whoSpan = document.createElement('span'); whoSpan.className = 'who'; whoSpan.textContent = isSelf ? 'Я' : (m.from_user_id||m.fromUserId||'--').slice(0,6);
  const msgSpan = document.createElement('span'); msgSpan.className = 'msg'; msgSpan.textContent = m.content;
  const timeSpan = document.createElement('span'); timeSpan.className = 'time'; timeSpan.title = full; timeSpan.textContent = ts;
  timeSpan.style.marginLeft = '6px';
  div.appendChild(whoSpan); div.appendChild(msgSpan); div.appendChild(timeSpan);
  els.directMessages.appendChild(div);
}
function scrollDirectToEnd(){ try { els.directMessages.scrollTop = els.directMessages.scrollHeight; } catch {} }

// scheduleAutoRedecrypt удалён — не требуется.

export async function selectDirectFriend(friendId, label, opts={}){
  const already = appState.currentDirectFriend === friendId;
  appState.currentDirectFriend = friendId;
  if (els.directChatCard) els.directChatCard.style.display = '';
  if (els.directChatTitle) els.directChatTitle.textContent = 'Чат с: ' + (label || friendId.slice(0,8));
  // E2EE отключено — никакой ensureE2EEKeys.
  ensureDirectActions();
  if (already && !opts.force){
    if (appState.directUnread.has(friendId)) { appState.directUnread.delete(friendId); updateFriendUnreadBadge(friendId); }
    const hasAny = !!els.directMessages && els.directMessages.querySelector('.chat-line');
    const showsEmpty = !!els.directMessages && /Пусто|Загрузка|Ошибка/.test(els.directMessages.textContent||'');
    if (!hasAny || showsEmpty){ return await selectDirectFriend(friendId, label, { force: true }); }
    return;
  }
  if (appState.directUnread.has(friendId)) { appState.directUnread.delete(friendId); updateFriendUnreadBadge(friendId); }
  try {
    const t = localStorage.getItem('wc_token');
    fetch(`/api/v1/direct/${friendId}/read-ack`, { method: 'POST', headers: { 'content-type':'application/json','Authorization': `Bearer ${t}` }, body: JSON.stringify({}) }).catch(()=>{});
  } catch {}
  if (els.directMessages) els.directMessages.innerHTML = '<div class="muted">Загрузка...</div>';
  try {
    const t = localStorage.getItem('wc_token');
    const r = await fetch(`/api/v1/direct/${friendId}/messages`, { headers: { 'Authorization': `Bearer ${t}` } });
    const arr = await r.json();
    let seen = new Set();
    appState.directSeenByFriend.set(friendId, seen);
    let added = 0;
    if (Array.isArray(arr) && arr.length){
      els.directMessages.innerHTML = '';
      arr.forEach(m => {
        if (m.id) seen.add(m.id); added++;
        appendDirectMessage(m, m.from_user_id === hooks.getAccountId());
      });
  // plaintext уже
      if (added === 0) els.directMessages.innerHTML = '<div class="muted">Пусто</div>'; else scrollDirectToEnd();
    } else {
      els.directMessages.innerHTML = '<div class="muted">Пусто</div>';
      setTimeout(async ()=>{
        try {
          const t2 = localStorage.getItem('wc_token');
          const r2 = await fetch(`/api/v1/direct/${friendId}/messages`, { headers:{ 'Authorization': `Bearer ${t2}` } });
          if (r2.ok){
            const arr2 = await r2.json();
            if (Array.isArray(arr2) && arr2.length){
              els.directMessages.innerHTML='';
              let seen2 = appState.directSeenByFriend.get(friendId);
              if (!seen2){ seen2 = new Set(); appState.directSeenByFriend.set(friendId, seen2); }
              let added2 = 0;
              arr2.forEach(m => { if (m.id && !seen2.has(m.id)){ seen2.add(m.id); added2++; appendDirectMessage(m, m.from_user_id === hooks.getAccountId()); } });
              // plaintext уже
              if (added2 === 0) els.directMessages.innerHTML = '<div class="muted">Пусто</div>'; else scrollDirectToEnd();
            }
          }
        } catch {}
      }, 600);
    }
  } catch {
    try { els.directMessages.innerHTML = '<div class="muted">Ошибка загрузки</div>'; } catch {}
  }
}

export function handleIncomingDirect(msg){
  const acc = hooks.getAccountId();
  const other = msg.fromUserId === acc ? msg.toUserId : msg.fromUserId;
  const show = appState.currentDirectFriend && other === appState.currentDirectFriend;
  if (show){
    const mid = msg.messageId || msg.id;
    let seen = appState.directSeenByFriend.get(appState.currentDirectFriend);
    if (!seen){ seen = new Set(); appState.directSeenByFriend.set(appState.currentDirectFriend, seen); }
    if (mid && seen.has(mid)) return;
    if (mid) seen.add(mid);
    (async ()=>{
      appendDirectMessage({ id: mid, from_user_id: msg.fromUserId, content: msg.content, sent_at: msg.sentAt }, msg.fromUserId === acc);
      scrollDirectToEnd();
    })();
  } else {
    if (acc && msg.fromUserId !== acc){
      const prev = appState.directUnread.get(other) || 0;
      appState.directUnread.set(other, prev + 1);
      updateFriendUnreadBadge(other);
      // Уведомление на каждое 10-е непросмотренное сообщение (10,20,30 ...)
      try {
        const unreadNow = prev + 1;
        if (unreadNow % 10 === 0 && Notification && Notification.permission === 'granted'){
            new Notification('Новые сообщения', { body: `Еще ${unreadNow} непрочитанных от собеседника` });
        }
      } catch {}
    }
  }
}

export function handleDirectCleared(msg){
  if (!appState.currentDirectFriend) return;
  const acc = hooks.getAccountId(); if (!acc) return;
  const ids = msg.userIds || [];
  if (ids.includes(acc) && ids.includes(appState.currentDirectFriend)){
    if (els.directMessages) els.directMessages.innerHTML = '<div class="muted">Пусто</div>';
    appState.directSeenByFriend.set(appState.currentDirectFriend, new Set());
    appState.directUnread.delete(appState.currentDirectFriend);
    updateFriendUnreadBadge(appState.currentDirectFriend);
  }
}

function ensureDirectActions(){
  if (!els.directActions) return;
  if (!els.directActions.querySelector('[data-act="clear"]')){
    const btn = document.createElement('button');
    btn.className = 'btn danger ghost';
    btn.textContent = 'Очистить чат';
    btn.dataset.act = 'clear';
    btn.addEventListener('click', async ()=>{
      if (!appState.currentDirectFriend) return;
      if (!confirm('Удалить всю переписку?')) return;
      try {
        const t = localStorage.getItem('wc_token');
        const r = await fetch(`/api/v1/direct/${appState.currentDirectFriend}/messages`, { method:'DELETE', headers:{ 'Authorization': `Bearer ${t}` } });
        if (r.ok){
          const j = await r.json();
          if (els.directMessages) els.directMessages.innerHTML = '<div class="muted">Пусто</div>';
          appState.directSeenByFriend.set(appState.currentDirectFriend, new Set());
          hooks.log && hooks.log(`Переписка удалена (${j.removed||0})`);
        }
      } catch {}
    });
    els.directActions.appendChild(btn);
  }
}

export function bindSendDirect(){
  if (!els.btnDirectSend) return;
  els.btnDirectSend.addEventListener('click', async ()=>{
    if (!appState.currentDirectFriend) return;
    const text = (els.directInput?.value || '').trim();
    if (!text) return;
    try {
      const ct = text; // отправляем plaintext
      const t = localStorage.getItem('wc_token');
      const r = await fetch(`/api/v1/direct/${appState.currentDirectFriend}/messages`, { method:'POST', headers:{ 'content-type':'application/json','Authorization': `Bearer ${t}` }, body: JSON.stringify({ content: ct }) });
      if (r.ok){
        const m = await r.json();
        let seen = appState.directSeenByFriend.get(appState.currentDirectFriend);
        if (!seen){ seen = new Set(); appState.directSeenByFriend.set(appState.currentDirectFriend, seen); }
        if (m.id && !seen.has(m.id)){
          seen.add(m.id);
          appendDirectMessage({ id: m.id, from_user_id: hooks.getAccountId(), content: text, sent_at: m.sent_at || new Date().toISOString() }, true);
          scrollDirectToEnd();
        }
      }
    } catch (e){ console.error('send direct failed', e); }
    els.directInput.value='';
  });
  els.directInput?.addEventListener('keydown', e=>{ if (e.key==='Enter') els.btnDirectSend.click(); });
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\direct_chat.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\e2ee.js =====
--- SIZE: 7393 bytes ---

// modules/e2ee.js
// Изоляция клиентского E2EE слоя (ECDH P-256 + AES-GCM)
// Публичные функции: ensureE2EEKeys, encryptForFriend, decryptFromFriend, tryDecryptVisibleMessages

const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();

let _keypair = null;          // CryptoKeyPair
let _exportedPub = null;      // base64 raw public key
let _ensuring = null;         // concurrency guard

// --- IndexedDB helpers ---
function idbPut(dbName, storeName, key, value){
  return new Promise((resolve,reject)=>{
    try{
      const req = indexedDB.open(dbName, 1);
      req.onupgradeneeded = ()=>{ req.result.createObjectStore(storeName); };
      req.onsuccess = ()=>{
        const db = req.result;
        const tx = db.transaction(storeName, 'readwrite');
        const os = tx.objectStore(storeName);
        os.put(value, key);
        tx.oncomplete = ()=>{ db.close(); resolve(); };
        tx.onerror = (e)=>{ db.close(); reject(e); };
      };
      req.onerror = (e)=> reject(e);
    }catch(e){ reject(e); }
  });
}
function idbGet(dbName, storeName, key){
  return new Promise((resolve,reject)=>{
    try{
      const req = indexedDB.open(dbName, 1);
      req.onupgradeneeded = ()=>{ req.result.createObjectStore(storeName); };
      req.onsuccess = ()=>{
        const db = req.result;
        const tx = db.transaction(storeName, 'readonly');
        const os = tx.objectStore(storeName);
        const g = os.get(key);
        g.onsuccess = ()=>{ db.close(); resolve(g.result); };
        g.onerror = ()=>{ db.close(); resolve(null); };
      };
      req.onerror = (e)=> reject(e);
    }catch(e){ reject(e); }
  });
}
async function saveKeypair(privatePk8B64, publicRawB64){
  try{ await idbPut('wc_keys', 'keys', 'e2ee', { priv: privatePk8B64, pub: publicRawB64 }); return; }catch{}
  try{ localStorage.setItem('wc_e2ee_priv', privatePk8B64); localStorage.setItem('wc_e2ee_pub', publicRawB64); }catch{}
}
async function loadKeypair(){
  try{ const v = await idbGet('wc_keys','keys','e2ee'); if (v) return v; }catch{}
  try{
    const priv = localStorage.getItem('wc_e2ee_priv');
    const pub  = localStorage.getItem('wc_e2ee_pub');
    if (priv && pub) return { priv, pub };
  }catch{}
  return null;
}

export async function ensureE2EEKeys(){
  if (_keypair) return _keypair;
  if (_ensuring) return _ensuring;
  _ensuring = (async () => {
    try {
      const stored = await loadKeypair();
      if (stored && stored.priv && stored.pub){
        try {
          const rawPub = Uint8Array.from(atob(stored.pub), c=>c.charCodeAt(0)).buffer;
          const priv = Uint8Array.from(atob(stored.priv), c=>c.charCodeAt(0)).buffer;
          const publicKey = await crypto.subtle.importKey('raw', rawPub, { name:'ECDH', namedCurve:'P-256' }, true, []);
          const privateKey = await crypto.subtle.importKey('pkcs8', priv, { name:'ECDH', namedCurve:'P-256' }, true, ['deriveKey']);
          _keypair = { publicKey, privateKey }; _exportedPub = stored.pub;
          publishMyPublicKey(_exportedPub).catch(()=>{});
          return _keypair;
        }catch{ /* regenerate */ }
      }
      _keypair = await crypto.subtle.generateKey({ name:'ECDH', namedCurve:'P-256' }, true, ['deriveKey']);
      const raw = await crypto.subtle.exportKey('raw', _keypair.publicKey);
      _exportedPub = btoa(String.fromCharCode(...new Uint8Array(raw)));
      try {
        const pkcs8 = await crypto.subtle.exportKey('pkcs8', _keypair.privateKey);
        const pkcs8b64 = btoa(String.fromCharCode(...new Uint8Array(pkcs8)));
        await saveKeypair(pkcs8b64, _exportedPub);
      }catch{}
      try { await publishMyPublicKey(_exportedPub); } catch {}
      return _keypair;
    } finally { _ensuring = null; }
  })();
  return _ensuring;
}

async function publishMyPublicKey(base64){
  try {
    const mod = await import('../api.js');
    if (mod && typeof mod.setMyPublicKey === 'function') {
      await mod.setMyPublicKey(base64);
    }
  } catch {}
}

async function importPeerPublicKey(base64){
  try {
    const raw = Uint8Array.from(atob(base64), c=>c.charCodeAt(0)).buffer;
    return await crypto.subtle.importKey('raw', raw, { name:'ECDH', namedCurve:'P-256' }, true, []);
  } catch { return null; }
}
async function deriveSharedKey(peerPubKey){
  try {
    return await crypto.subtle.deriveKey({ name:'ECDH', public: peerPubKey }, _keypair.privateKey, { name:'AES-GCM', length:256 }, false, ['encrypt','decrypt']);
  } catch { return null; }
}
async function aesGcmEncrypt(key, plaintext){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, key, textEncoder.encode(plaintext));
  const buf = new Uint8Array(iv.byteLength + ct.byteLength);
  buf.set(iv,0); buf.set(new Uint8Array(ct), iv.byteLength);
  return btoa(String.fromCharCode(...buf));
}
async function aesGcmDecrypt(key, b64){
  try {
    const raw = Uint8Array.from(atob(b64), c=>c.charCodeAt(0));
    const iv = raw.slice(0,12);
    const ct = raw.slice(12).buffer;
    const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv }, key, ct);
    return textDecoder.decode(plain);
  } catch { return null; }
}

async function fetchPeerPublic(friendId){
  const mod = await import('../api.js');
  if (mod && typeof mod.getUserPublicKey === 'function') {
    return await mod.getUserPublicKey(friendId);
  }
  return null;
}

export async function encryptForFriend(friendId, plaintext){
  try {
    await ensureE2EEKeys();
    const pkResp = await fetchPeerPublic(friendId);
    const pub = pkResp && pkResp.public_key;
    if (!pub) throw new Error('no peer pk');
    const peerKey = await importPeerPublicKey(pub); if (!peerKey) throw new Error('bad pk');
    const shared = await deriveSharedKey(peerKey); if (!shared) throw new Error('derive failed');
    return await aesGcmEncrypt(shared, plaintext);
  } catch (e){ console.error('encryptForFriend failed', e); return null; }
}

export async function decryptFromFriend(friendId, b64cipher){
  try {
    await ensureE2EEKeys();
    const pkResp = await fetchPeerPublic(friendId);
    const pub = pkResp && pkResp.public_key; if (!pub) return null;
    const peerKey = await importPeerPublicKey(pub); if (!peerKey) return null;
    const shared = await deriveSharedKey(peerKey); if (!shared) return null;
    return await aesGcmDecrypt(shared, b64cipher);
  } catch (e){ console.error('decryptFromFriend failed', e); return null; }
}

export async function tryDecryptVisibleMessages(friendId, container){
  if (!friendId || !container) return;
  try {
    const lines = Array.from(container.querySelectorAll('.chat-line'));
    for (const line of lines){
      try {
        const msgEl = line.querySelector('.msg'); if (!msgEl) continue;
        const currentText = msgEl.textContent || '';
        if (/^[A-Za-z0-9+/=\-_.]+$/.test(currentText) && currentText.length > 16){
          const dec = await decryptFromFriend(friendId, currentText);
            if (dec) msgEl.textContent = dec;
        }
      } catch {}
    }
  } catch {}
}

// Автоматически генерируем ключи (best effort)
ensureE2EEKeys().catch(()=>{});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\e2ee.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\friends_ui.js =====
--- SIZE: 12402 bytes ---

// modules/friends_ui.js
// Логика отображения списка друзей, заявок, кнопок звонков и поиска.

import { els, makeBtn } from './core/dom.js';
import { appState } from './core/state.js';
import { notifyCall, acceptCall, declineCall, cancelCall, findUsers, listFriends, listFriendRequests, sendFriendRequest, acceptFriend } from '../api.js';
import { getActiveCall, getPendingIncomingInvites } from './calls.js'; // legacy (activeCall пока может использоваться)
import { startOutgoingCall as startOutgoingCallNew } from './calls_signaling.js';
import { selectDirectFriend } from './direct_chat.js';

let hooks = {
  log: (m)=>{},
  unlockAudioPlayback: ()=>{},
  connectRoom: ()=>{},           // () => void (подключение к roomId из els.roomId)
};

// ===== Онлайн статус друзей =====
// Простая эвристика: если видели активность (сообщение, сигнал звонка, вступление в звонок) < FRIEND_ONLINE_WINDOW -> online
// ===== Presence через сервер =====
const onlineUsers = new Set();
export function setOnlineSnapshot(arr){ try { onlineUsers.clear(); (arr||[]).forEach(id=> onlineUsers.add(String(id).toLowerCase())); } catch{} }
export function addOnlineUser(id){ if(!id) return; onlineUsers.add(String(id).toLowerCase()); }
export function removeOnlineUser(id){ if(!id) return; onlineUsers.delete(String(id).toLowerCase()); }
export function markFriendSeen(friendId){ /* больше не используется для presence, оставляем заглушку для совместимости */ }
export function refreshFriendStatuses(){
  try {
    document.querySelectorAll('#friendsList .list-item').forEach(li => {
      const fid = (li.getAttribute('data-friend-id')||'').toLowerCase(); if (!fid) return;
      const dot = li.querySelector('.status-dot'); if (!dot) return;
      const online = onlineUsers.has(fid);
      dot.classList.toggle('online', online);
      dot.classList.toggle('offline', !online);
      dot.title = online ? 'Онлайн' : 'Оффлайн';
    });
  } catch{}
}

export function initFriendsModule(options={}){ hooks = { ...hooks, ...options }; }

function renderUserRow(container, u, opts={}){
  const row = document.createElement('div');
  row.className = 'list-item';
  row.setAttribute('data-friend-id', u.id || u.user_id || '');
  const left = document.createElement('div'); left.className = 'grow';
  const bold = document.createElement('div'); bold.className = 'bold';
  const statusDot = document.createElement('span'); statusDot.className='status-dot offline'; statusDot.title='Оффлайн';
  bold.appendChild(statusDot);
  const nameSpan = document.createElement('span'); nameSpan.textContent = u.username; bold.appendChild(nameSpan);
  const meta = document.createElement('div'); meta.className = 'muted small'; meta.textContent = `${u.email} • ${u.id?.slice?.(0,8)||''}`;
  left.appendChild(bold); left.appendChild(meta);
  const actions = document.createElement('div'); actions.className='list-item-actions';
  row.appendChild(left); row.appendChild(actions);
  (opts.actions || []).forEach(a => actions.appendChild(a));
  if (opts.onSelectDirect){
    row.style.cursor='pointer';
    row.addEventListener('click', ()=> opts.onSelectDirect(u));
  }
  container.appendChild(row);
}

function updateFriendUnreadBadge(friendId){
  const btn = document.querySelector(`button.chat-btn[data-friend-id="${friendId}"]`);
  if (!btn) return;
  const count = appState.directUnread.get(friendId) || 0;
  if (count > 0){
    btn.classList.add('has-unread');
    btn.dataset.unread = String(count);
  } else {
    btn.classList.remove('has-unread');
    delete btn.dataset.unread;
  }
}

export async function loadFriends(){
  if (!els.friendsList || !els.friendRequests) return;
  const prevDirect = appState.currentDirectFriend;
  els.friendsList.innerHTML = '<div class="muted">Загрузка...</div>';
  els.friendRequests.innerHTML = '<div class="muted">Загрузка...</div>';
  try {
    const startedAt = Date.now();
    let friends, reqs;
    try {
      [friends, reqs] = await Promise.all([listFriends(), listFriendRequests()]);
    } catch(e){
      console.warn('[friends_ui] Ошибка загрузки списков друзей/заявок:', e);
      throw e; // пробрасываем дальше в общий catch
    }
    if (!Array.isArray(friends)) { console.warn('[friends_ui] Неверный формат friends', friends); friends = []; }
    if (!Array.isArray(reqs)) { console.warn('[friends_ui] Неверный формат friend requests', reqs); reqs = []; }
    els.friendsList.innerHTML = '';
    if (!friends.length) els.friendsList.innerHTML = '<div class="muted">Нет друзей</div>';
    const activeCall = getActiveCall();
    const pendingInvites = getPendingIncomingInvites();
    friends.forEach(f => {
      if (typeof f.unread === 'number'){
        if (f.unread > 0) appState.directUnread.set(f.user_id, f.unread); else appState.directUnread.delete(f.user_id);
      }
      const callControls = [];
      const isActiveWith = activeCall && activeCall.withUserId === f.user_id && activeCall.status !== 'ended';
      if (!isActiveWith){
        const btnCall = makeBtn('Позвонить','btn primary', async (ev)=>{
          ev?.stopPropagation?.();
          startOutgoingCallNew(f);
        });
        callControls.push(btnCall);
      } else {
        if (activeCall.direction === 'outgoing' && activeCall.status === 'invited'){
          const span = document.createElement('span'); span.className='muted small'; span.textContent='Ожидание...';
          const btnCancel = makeBtn('Отменить','btn ghost', async (ev)=>{
            ev?.stopPropagation?.();
            try { if (activeCall.withUserId && activeCall.roomId) await cancelCall(activeCall.withUserId, activeCall.roomId); }
            catch { try { if (activeCall.withUserId && activeCall.roomId) await declineCall(activeCall.withUserId, activeCall.roomId); } catch {} }
            // Сброс будет инициирован через модуль calls внешне
            // markCallDeclined(activeCall.roomId); оставим логику централизованной
          });
          callControls.push(span, btnCancel);
        } else if (activeCall.status === 'accepted'){
          const span = document.createElement('span'); span.className='muted small'; span.textContent='В звонке'; callControls.push(span);
        } else if (activeCall.status === 'declined'){
          const span = document.createElement('span'); span.className='muted small'; span.textContent='Отклонён'; callControls.push(span);
        }
      }
      const btnChat = makeBtn('Чат','btn chat-btn', ()=> selectDirectFriend(f.user_id, f.username || f.user_id));
      btnChat.addEventListener('click', e=> e.stopPropagation());
      btnChat.dataset.friendId = f.user_id;
      const btnDel = makeBtn('Удалить','btn danger ghost', async (ev)=>{
        ev?.stopPropagation?.();
        if (!confirm('Удалить этого друга?')) return;
        try {
          const t = localStorage.getItem('wc_token');
          const resp = await fetch(`/api/v1/friends/${f.user_id}`, { method:'DELETE', headers:{ 'Authorization': `Bearer ${t}` } });
          if (resp.ok){
            if (appState.currentDirectFriend === f.user_id){
              appState.currentDirectFriend = null;
              if (els.directChatTitle) els.directChatTitle.textContent = 'Личный чат';
              if (els.directMessages) els.directMessages.innerHTML = '<div class="muted">Выберите друга</div>';
            }
            appState.directSeenByFriend.delete(f.user_id);
            appState.directUnread.delete(f.user_id);
            await loadFriends();
          } else alert('Не удалось удалить');
        } catch(e){ alert('Ошибка: '+e); }
      });
      renderUserRow(els.friendsList, { id:f.user_id, username:f.username||f.user_id, email:f.email||'' }, {
        actions: [...callControls, btnChat, btnDel],
        onSelectDirect: (user)=> selectDirectFriend(user.id, user.username || user.id)
      });
      updateFriendUnreadBadge(f.user_id);
    });
    if (prevDirect && friends.some(fr => fr.user_id === prevDirect)){
      const fr = friends.find(fr => fr.user_id === prevDirect);
      if (fr && els.directChatTitle && appState.currentDirectFriend === prevDirect){
        els.directChatTitle.textContent = 'Чат с: ' + (fr.username || prevDirect.slice(0,8));
      }
    }
    // Requests
    els.friendRequests.innerHTML='';
    if (!reqs.length) els.friendRequests.innerHTML = '<div class="muted">Нет заявок</div>';
    reqs.forEach(r => {
      const btnAccept = makeBtn('Принять','btn success', async ()=>{ try { await acceptFriend(r.user_id); await loadFriends(); } catch(e){ alert(String(e)); } });
      renderUserRow(els.friendRequests, { id:r.user_id, username:r.username || r.user_id, email:r.email || '' }, { actions:[btnAccept] });
    });
    // Обновим статусы после полной перерисовки
    refreshFriendStatuses();
  } catch(e){
    const msg = (e && e.message) ? e.message : 'Ошибка';
    const needsUsernameFix = /Username must be 3-32 chars/.test(msg);
    const extra = needsUsernameFix ? `<div class="small" style="margin-top:6px;">
      Требуется валидный username. <button class="btn btn-sm" id="btnGoProfile">Исправить профиль</button>
    </div>` : '';
    const html = `<div class="muted">Ошибка загрузки: ${msg}</div>${extra}`;
    els.friendsList.innerHTML = html;
    els.friendRequests.innerHTML = html;
    if (needsUsernameFix){
      setTimeout(()=>{
        const b = document.getElementById('btnGoProfile');
        if (b){
          b.addEventListener('click', ()=>{ try { location.href='/profile.html'; } catch {} });
        }
      }, 30);
    }
  }
}

let _friendsReloadTimer = null;
export function scheduleFriendsReload(){
  if (_friendsReloadTimer) clearTimeout(_friendsReloadTimer);
  _friendsReloadTimer = setTimeout(()=>{ loadFriends(); }, 300);
}

export function initFriendsUI(){
  if (!els.friendsCard) return;
  els.btnFriendSearch?.addEventListener('click', async ()=>{
    const q = (els.friendSearch?.value || '').trim();
    if (!q) return;
    els.friendSearchResults.innerHTML = '<div class="muted">Поиск...</div>';
    try {
      const t0 = performance.now();
      const arr = await findUsers(q);
      const dt = (performance.now()-t0).toFixed(0);
      els.friendSearchResults.innerHTML='';
      if (!Array.isArray(arr)) {
        console.warn('[friends_ui] findUsers: ожидался массив, получено', arr);
        els.friendSearchResults.innerHTML = '<div class="muted">Неверный ответ сервера</div>';
        return;
      }
      if (!arr.length) {
        els.friendSearchResults.innerHTML = '<div class="muted">Ничего не найдено</div>';
        return;
      }
      arr.forEach(u => {
        const btnAdd = makeBtn('Добавить','btn', async ()=>{
          try { await sendFriendRequest(u.id); alert('Заявка отправлена'); await loadFriends(); }
          catch(e){ alert('Ошибка отправки: '+ String(e?.message||e)); }
        });
        renderUserRow(els.friendSearchResults, u, { actions:[btnAdd] });
      });
      console.debug(`[friends_ui] Поиск "${q}" -> ${arr.length} (за ${dt}мс)`);
    } catch(e) {
      console.warn('[friends_ui] Ошибка поиска пользователей:', e);
      els.friendSearchResults.innerHTML = `<div class="muted">Ошибка поиска: ${e?.message||e}</div>`;
    }
  });
  // Поиск по Enter
  els.friendSearch?.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter') {
      e.preventDefault();
      els.btnFriendSearch?.click();
    }
  });
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\friends_ui.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\permissions.js =====
--- SIZE: 2977 bytes ---

// modules/permissions.js
// Управление правами: микрофон и уведомления + баннер.

import { els } from './core/dom.js';

export async function requestMicIfNeeded(opts={}){
  try {
    if (navigator.permissions && navigator.permissions.query){
      const st = await navigator.permissions.query({ name:'microphone' });
      if (st.state === 'granted') return true;
    }
  } catch {}
  try {
    await navigator.mediaDevices.getUserMedia({ audio:true });
    return true;
  } catch(e){
    if (!opts.silent) alert('Нет доступа к микрофону. Разрешите в настройках браузера.');
    return false;
  }
}

export async function ensurePushPermission(opts={}){
  if (!('Notification' in window)) return false;
  if (Notification.permission === 'granted') return true;
  if (Notification.permission === 'denied') return false;
  try {
    const perm = await Notification.requestPermission();
    return perm === 'granted';
  } catch { return false; }
}

export function updatePermBanner(){
  if (!els.permBanner) return;
  const banner = els.permBanner;
  const msgs = [];
  (async () => {
    try {
      if (navigator.permissions && navigator.permissions.query){
        const st = await navigator.permissions.query({ name:'microphone' });
        if (st.state === 'denied') msgs.push('Доступ к микрофону запрещён. Разрешите в настройках браузера.');
        else if (st.state === 'prompt') msgs.push('Предоставьте доступ к микрофону для звонков.');
      }
    } catch {}
    try {
      if ('Notification' in window){
        if (Notification.permission === 'denied') msgs.push('Уведомления заблокированы. Разрешите их в настройках браузера.');
        else if (Notification.permission === 'default') msgs.push('Разрешите отправку уведомлений, чтобы получать оповещения о звонках.');
      }
    } catch {}
    if (msgs.length){
      banner.innerHTML = '';
      msgs.forEach(m => { const el = document.createElement('div'); el.className='warn'; el.textContent = m; banner.appendChild(el); });
      banner.style.display = '';
    } else {
      banner.innerHTML=''; banner.style.display='none';
    }
  })();
}

export async function checkAndRequestPermissionsInitial(){
  try { await requestMicIfNeeded({ silent:true }); } catch {}
  try { await ensurePushPermission({ silent:true }); } catch {}
  updatePermBanner();
}

// Глобальные функции для кнопок в HTML (если они есть)
window.__wc_requestMic = () => requestMicIfNeeded({ silent:false }).then(()=> updatePermBanner());
window.__wc_requestPush = () => ensurePushPermission({ silent:false }).then(()=> updatePermBanner());

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\permissions.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\push_subscribe.js =====
--- SIZE: 2976 bytes ---

// modules/push_subscribe.js
// Инициализация push подписки и отправка subscription на сервер.

import { subscribePush } from '../api.js';
import { updatePermBanner } from './permissions.js';

export async function initPush(){
  if (!('serviceWorker' in navigator) || !('PushManager' in window) || !('Notification' in window)) return;
  if (Notification.permission === 'denied') { updatePermBanner(); return; }
  if (Notification.permission === 'default') { updatePermBanner(); return; }
  const reg = await navigator.serviceWorker.getRegistration('/static/sw.js') || await navigator.serviceWorker.register('/static/sw.js');
  const r = await fetch('/api/v1/push/vapid-public');
  const j = await r.json();
  const vapidKey = (j && j.key) ? urlBase64ToUint8Array(j.key) : null;
  const existing = await reg.pushManager.getSubscription();
  let sub = existing;
  if (!sub){
    sub = await reg.pushManager.subscribe({ userVisibleOnly:true, applicationServerKey: vapidKey });
  }
  const payload = { endpoint: sub.endpoint, keys: sub.toJSON().keys };
  // Идемпотентность: вычисляем fingerprint на основе endpoint + ключей и сравниваем с сохранённым.
  try {
    const keys = payload.keys || {};
    const fpSource = payload.endpoint + '|' + (keys.p256dh || '') + '|' + (keys.auth || '');
    const enc = new TextEncoder();
    const digest = await crypto.subtle.digest('SHA-256', enc.encode(fpSource));
    const fpArr = Array.from(new Uint8Array(digest));
    const fingerprint = fpArr.map(b=>b.toString(16).padStart(2,'0')).join('');
    const stored = localStorage.getItem('pushSubFingerprint');
    const tsRaw = localStorage.getItem('pushSubFingerprintTs');
    let expired = true;
    try { const ts = Number(tsRaw); if (ts && (Date.now() - ts) < 1000*60*60*12) expired = false; } catch {}
    if (stored === fingerprint && !expired) {
      // Ничего не изменилось и TTL (12h) ещё не истёк — не дергаем сервер заново.
      return;
    }
    await subscribePush(payload); // upsert на бэкенде
    localStorage.setItem('pushSubFingerprint', fingerprint);
    localStorage.setItem('pushSubFingerprintTs', String(Date.now()));
    try { console.debug('[push] subscription sent (updated or new)'); } catch {}
  } catch(e){
    // В случае ошибки fallback на прежнее поведение
    await subscribePush(payload);
  }
}

function urlBase64ToUint8Array(base64String){
  if (!base64String) return null;
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding).replace(/-/g,'+').replace(/_/g,'/');
  const rawData = atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i=0;i<rawData.length;i++) outputArray[i] = rawData.charCodeAt(i);
  return outputArray;
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\push_subscribe.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\stats.js =====
--- SIZE: 3538 bytes ---

// modules/stats.js
// Сбор периодической статистики WebRTC и эмит 'stats:sample' через event bus.

import { bus } from './core/event_bus.js';
import { appState } from './core/state.js';

/**
 * @typedef {Object} PeerStatSample
 * @property {string} peerId
 * @property {number} timestamp
 * @property {number} [outAudioBitrate]
 * @property {number} [inAudioBitrate]
 * @property {number} [rtt]
 * @property {number} [packetLossIn]
 * @property {number} [packetLossOut]
 */

/**
 * @typedef {Object} StatsSample
 * @property {number} ts
 * @property {PeerStatSample[]} peers
 */

let intervalId = null;
let lastTotals = new Map(); // peerId -> { bytesIn, bytesOut, ts }

/**
 * Запуск цикла сбора статистики.
 * @param {object} opts
 * @param {number} [opts.intervalMs=3000]
 * @param {(StatsSample)=>void} [opts.onSample]
 */
export function startStatsLoop(opts={}){
  stopStatsLoop();
  const intervalMs = opts.intervalMs ?? 3000;
  intervalId = setInterval(async ()=>{
    if (!appState.rtc) return;
    const samples = [];
    for (const [peerId, st] of appState.rtc.peers){
      const pc = st.pc; if (!pc) continue;
      try {
        const stats = await pc.getStats();
        let bytesIn = 0, bytesOut = 0, rtt = undefined, packetsRecv = 0, packetsLost = 0, packetsSent = 0, packetsSentLost = 0;
        stats.forEach(r=>{
          if (r.type === 'inbound-rtp' && r.kind === 'audio'){
            bytesIn += r.bytesReceived || 0; packetsRecv += r.packetsReceived||0; packetsLost += r.packetsLost||0;
          } else if (r.type === 'outbound-rtp' && r.kind === 'audio'){
            bytesOut += r.bytesSent || 0; packetsSent += r.packetsSent||0; // нет packetsLost у outbound, иногда отдельные отчёты
          } else if (r.type === 'remote-inbound-rtp' && r.kind === 'audio'){
            // удалённая сторона сообщает о потере наших пакетов
            packetsSentLost += r.packetsLost || 0; if (typeof r.roundTripTime === 'number') rtt = r.roundTripTime*1000;
          }
        });
        const now = Date.now();
        const prev = lastTotals.get(peerId) || { bytesIn, bytesOut, ts: now };
        const dt = (now - prev.ts)/1000 || 1;
        const outAudioBitrate = (bytesOut - prev.bytesOut) * 8 / dt; // bps
        const inAudioBitrate = (bytesIn - prev.bytesIn) * 8 / dt;
        lastTotals.set(peerId, { bytesIn, bytesOut, ts: now });
        const sample = {
          peerId,
          timestamp: now,
          outAudioBitrate: outAudioBitrate >=0 ? Math.round(outAudioBitrate) : undefined,
          inAudioBitrate: inAudioBitrate >=0 ? Math.round(inAudioBitrate) : undefined,
          rtt,
          packetLossIn: packetsRecv ? packetsLost/packetsRecv : undefined,
          packetLossOut: packetsSent ? packetsSentLost/packetsSent : undefined,
        };
        samples.push(sample);
      } catch {}
    }
    if (!samples.length) return;
    const payload = { ts: Date.now(), peers: samples };
    bus.emit('stats:sample', payload);
    if (opts.onSample) { try { opts.onSample(payload); } catch {} }
  }, intervalMs);
}

export function stopStatsLoop(){ if (intervalId){ clearInterval(intervalId); intervalId=null; } }

export function formatBitrate(v){ if (v==null) return '-'; if (v<1000) return v+'bps'; if (v<1e6) return (v/1000).toFixed(1)+'kbps'; return (v/1e6).toFixed(1)+'Mbps'; }

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\stats.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\visited_rooms.js =====
--- SIZE: 3274 bytes ---

// modules/visited_rooms.js
// Управление историей посещённых комнат.

import { els } from './core/dom.js';
import { appState } from './core/state.js';
import { bus } from './core/event_bus.js';

export async function loadVisitedRooms(){
  if (!els.visitedRooms) return;
  try {
    const rawToken = localStorage.getItem('wc_token');
    if (!rawToken) { els.visitedRooms.innerHTML = '<div class="muted">Войдите, чтобы увидеть историю комнат</div>'; return; }
    const r = await fetch('/api/v1/rooms/visited', { headers: { 'Authorization': `Bearer ${rawToken}` } });
    if (!r.ok){ els.visitedRooms.innerHTML = '<div class="muted">Не удалось загрузить историю</div>'; return; }
    const items = await r.json();
    let arr = Array.isArray(items) ? items : [];
    // Фильтруем эфемерные (call-*)
    arr = arr.filter(it => !(it.room_id || '').startsWith('call-'));
    if (!arr.length){ els.visitedRooms.innerHTML = '<div class="muted">История пуста</div>'; return; }
    els.visitedRooms.innerHTML = '';
    for (const it of arr){
      const div = document.createElement('div');
      div.className = 'list-item';
      const title = it.name || it.room_id;
      const when = new Date(it.last_seen).toLocaleString();
      const left = document.createElement('div'); left.className = 'grow';
      const b = document.createElement('div'); b.className = 'bold'; b.textContent = title;
      const meta = document.createElement('div'); meta.className = 'muted small'; meta.textContent = `${it.room_id} • ${when}`;
      left.appendChild(b); left.appendChild(meta);
      const right = document.createElement('div'); right.setAttribute('style','display:flex; gap:8px;');
      const btnJoin = document.createElement('button'); btnJoin.className = 'btn'; btnJoin.dataset.room = it.room_id; btnJoin.textContent = 'Войти';
      const btnDel = document.createElement('button'); btnDel.className = 'btn ghost danger'; btnDel.dataset.del = it.room_id; btnDel.title = 'Удалить из истории'; btnDel.textContent = 'Удалить';
      right.appendChild(btnJoin); right.appendChild(btnDel);
      div.appendChild(left); div.appendChild(right);
      btnJoin.addEventListener('click', ()=>{
        if (els.roomId) els.roomId.value = it.room_id;
        // Через внутреннюю шину событий
        bus.emit('join-room', { roomId: it.room_id });
      });
      btnDel.addEventListener('click', async ()=>{
        try {
          const resp = await fetch(`/api/v1/rooms/visited/${encodeURIComponent(it.room_id)}`, {
            method: 'DELETE',
            headers: { 'Authorization': `Bearer ${rawToken}` }
          });
          if (resp.ok){
            div.remove();
            if (!els.visitedRooms.children.length){
              els.visitedRooms.innerHTML = '<div class="muted">История пуста</div>';
            }
          }
        } catch {}
      });
      els.visitedRooms.appendChild(div);
    }
  } catch (e) {
    try { els.visitedRooms.innerHTML = '<div class="muted">Ошибка загрузки</div>'; } catch {}
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\visited_rooms.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\voice\capture_mixer.js =====
--- SIZE: 7402 bytes ---

// capture_mixer.js
// Смешивает локальный и удалённые аудиотреки в один MediaStream и выдаёт WebM Opus чанки через callback

export class VoiceCaptureMixer {
  constructor(opts){
    this.getPeers = opts.getPeers; // функция возвращающая appState.rtc.peers (Map)
    this.getLocalStream = opts.getLocalStream; // функция -> MediaStream | null
    this.onChunk = opts.onChunk; // (Uint8Array, meta) => void
    this.onLog = opts.onLog || (()=>{});
    this.chunkMs = opts.chunkMs || 5000;
    this.initialChunkMs = Math.min(2000, this.chunkMs); // более быстрый первый чанк для снижения латентности
    this.enabled = false;
    this._rec = null;
    this._ctx = null;
    this._dest = null;
    this._lastTracksKey = null;
    this._rebuildInterval = null;
    this._sources = [];
    this._closing = false;
    this._startTs = 0;
    this._initialTimer = null;
    this._waitingForTrack = false;
  }

  start(){
    if (this.enabled) return;
    this.enabled = true;
    this.onLog('VoiceMixer: start');
    this._startTs = Date.now();
    this._ensureContext();
    // Отложенный запуск, если ещё нет ни одного активного трека (частая причина пустой первой сессии)
    const hasAnyLiveTrack = () => {
      try {
        const local = this.getLocalStream?.();
        if (local && local.getAudioTracks().some(t=> t.readyState==='live' && t.enabled)) return true;
        const peers = this.getPeers?.();
        if (peers){
          for (const [, st] of peers.entries()){
            const ms = st.remoteStream; if (ms && ms.getAudioTracks().some(t=> t.readyState==='live' && t.enabled)) return true;
          }
        }
      } catch {}
      return false;
    };
    if (!hasAnyLiveTrack()){
      this._waitingForTrack = true;
      let attempts = 0;
      const maxAttempts = 20; // ~2s (20 * 100ms)
      const poll = () => {
        if (!this.enabled) return;
        if (hasAnyLiveTrack()){
          this._waitingForTrack = false;
          this.onLog(`VoiceMixer: обнаружен первый трек спустя ${Date.now()-this._startTs}ms`);
          this._finishStart();
          return;
        }
        attempts++;
        if (attempts >= maxAttempts){
          this._waitingForTrack = false;
          this.onLog('VoiceMixer: нет треков через 2s — стартуем пустой поток (может быть тишина)');
          this._finishStart();
          return;
        }
        setTimeout(poll, 100);
      };
      poll();
    } else {
      this._finishStart();
    }
  }

  stop(){
    this.enabled = false;
    this.onLog('VoiceMixer: stop');
    try { if (this._initialTimer){ clearTimeout(this._initialTimer); } } catch {}
    this._initialTimer = null;
    try { if (this._rebuildInterval) clearInterval(this._rebuildInterval); } catch {}
    this._rebuildInterval = null;
    this._waitingForTrack = false;
    this._lastTracksKey = null;
    this._startTs = 0;
    try {
      if (this._rec && this._rec.state === 'recording'){
        // Принудительно запрашиваем финальный буфер до stop для более надёжного последнего чанка
        try { this._rec.requestData(); } catch {}
        this._rec.stop();
      }
    } catch {}
    this._rec = null;
    // Отвязываем источники
    try { this._sources.forEach(src=>{ try { src.disconnect(); } catch {} }); } catch {}
    this._sources = [];
    this._dest = null;
    // Закрываем аудио-контекст один раз
    if (this._ctx && !this._closing && this._ctx.state !== 'closed'){
      this._closing = true;
      try {
        this._ctx.close().catch(()=>{}).finally(()=>{ this._ctx=null; this._dest=null; this._closing=false; });
      } catch {
        this._closing=false; this._ctx=null; this._dest=null;
      }
    } else {
      this._ctx = null; this._dest = null; this._closing = false;
    }
  }

  _ensureContext(){
    if (this._ctx && this._ctx.state === 'closed'){
      this._ctx = null;
      this._dest = null;
      this._closing = false;
    }
    if (this._ctx && !this._dest){
      try { this._dest = this._ctx.createMediaStreamDestination(); } catch {}
    }
    if (this._ctx) return;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    this._ctx = new Ctx();
    this._dest = this._ctx.createMediaStreamDestination();
  }

  _finishStart(){
    if (!this.enabled) return;
    this._rebuildGraph();
    try {
      this._rec = new MediaRecorder(this._dest.stream, { mimeType: 'audio/webm;codecs=opus' });
    } catch(e){
      this.onLog('VoiceMixer: MediaRecorder error '+e);
      return;
    }
    this._rec.ondataavailable = (ev)=>{
      if (!ev.data || !ev.data.size) return;
      ev.data.arrayBuffer().then(buf => {
        if (!this.enabled) return; 
        this.onChunk(new Uint8Array(buf), { ts: Date.now() });
      }).catch(()=>{});
    };
    // Первый чанк ускоренно
    try { this._rec.start(this.chunkMs); } catch(e){ this.onLog('VoiceMixer: start error '+e); }
    if (this.initialChunkMs < this.chunkMs){
      this._initialTimer = setTimeout(()=>{
        try {
          if (!this.enabled || !this._rec || this._rec.state !== 'recording') return;
          this.onLog('VoiceMixer: early requestData (initial)');
          this._rec.requestData();
        } catch {}
      }, this.initialChunkMs);
    }
    this._rebuildInterval = setInterval(()=>{ try { this._rebuildGraph(); } catch {} }, 4000);
  }

  _rebuildGraph(){
    if (!this._ctx || !this._dest) return;
    const local = this.getLocalStream?.();
    const peers = this.getPeers?.();
    const tracks = [];
    if (local){ local.getAudioTracks().forEach(t=>{ if (t.readyState==='live' && t.enabled) tracks.push(t); }); }
    if (peers){
      try {
        for (const [pid, st] of peers.entries()){
          const ms = st.remoteStream;
          if (ms){ ms.getAudioTracks().forEach(t=>{ if (t.readyState==='live' && t.enabled) tracks.push(t); }); }
        }
      } catch {}
    }
    const key = tracks.map(t=>t.id).sort().join('|');
    let forced = false;
    if (key === this._lastTracksKey){
      if (tracks.length && this._sources.length === 0){
        forced = true;
        this.onLog('VoiceMixer: forcing rebuild for stale sources');
      } else {
        return; // нет изменений
      }
    }
    this.onLog(`VoiceMixer: update graph tracks=${tracks.length}${forced ? ' (forced)' : ''}`);
    this._lastTracksKey = key;
    // Отключаем старые
    try { this._sources.forEach(src=>{ try { src.disconnect(); } catch {} }); } catch {}
    this._sources = [];
    // Подключаем новые
    for (const tr of tracks){
      try {
        const ms = new MediaStream([tr]);
        const src = this._ctx.createMediaStreamSource(ms);
        src.connect(this._dest);
        this._sources.push(src);
      } catch(e){ this.onLog('VoiceMixer: source err '+e); }
    }
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\modules\voice\capture_mixer.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\password.js =====
--- SIZE: 1550 bytes ---

import { changePassword } from './api.js';

function setMsg(el, text, cls){
  el.textContent = text || '';
  el.className = 'inline-msg ' + (cls||'');
}

async function init(){
  const form = document.getElementById('formPassword');
  const msg = document.getElementById('pwdMsg');
  const oldEl = document.getElementById('old_password');
  const newEl = document.getElementById('new_password');
  const new2El = document.getElementById('new_password2');

  form.addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    setMsg(msg, 'Обновление...', '');
    const oldPwd = oldEl.value.trim();
    const newPwd = newEl.value.trim();
    const new2Pwd = new2El.value.trim();

    if (!oldPwd || !newPwd || !new2Pwd){
      setMsg(msg, 'Заполните все поля', 'error');
      return;
    }
    if (newPwd !== new2Pwd){
      setMsg(msg, 'Новые пароли не совпадают', 'error');
      return;
    }
    if (newPwd.length < 6){
      setMsg(msg, 'Минимум 6 символов', 'error');
      return;
    }
    try {
      await changePassword(oldPwd, newPwd);
      setMsg(msg, 'Пароль изменён', 'success');
      oldEl.value=''; newEl.value=''; new2El.value='';
    } catch(e){
      let m = String(e);
      if (m.includes('400')) m = 'Старый пароль неверен или новый некорректен';
      else if (m.startsWith('Error:')) m = m.slice(6);
      setMsg(msg, m, 'error');
    }
  });
}

init();

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\password.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\profile.js =====
--- SIZE: 1861 bytes ---

// Импорт API методов (исправлено: убран лишний сегмент js/ в пути)
import { getMe, updateProfile } from './api.js';

function setMsg(el, text, cls){
  el.textContent = text || '';
  el.className = 'inline-msg ' + (cls||'');
}

async function init(){
  const emailEl = document.getElementById('email');
  const usernameEl = document.getElementById('username');
  const profileMsg = document.getElementById('profileMsg');
  const formProfile = document.getElementById('formProfile');

  // Prefill
  try {
    const me = await getMe();
    emailEl.value = me.email || '';
    usernameEl.value = me.username || '';
  } catch (e){
    setMsg(profileMsg, 'Не удалось загрузить профиль', 'error');
  }

  formProfile.addEventListener('submit', async (ev)=>{
    ev.preventDefault();
    setMsg(profileMsg, 'Сохранение...', '');
    const email = emailEl.value.trim();
    const username = usernameEl.value.trim();
    if (!email && !username){
      setMsg(profileMsg, 'Укажите email и/или имя', 'error');
      return;
    }
    try {
      const updated = await updateProfile({ email, username });
      try {
        localStorage.setItem('wc_email', updated.email);
        localStorage.setItem('wc_username', updated.username);
      } catch {}
      setMsg(profileMsg, 'Сохранено', 'success');
    } catch (e){
      let msg = String(e);
      if (msg.includes('409')) msg = 'Email или имя уже занято';
      else if (msg.includes('400')) msg = 'Некорректные данные';
      else if (msg.startsWith('Error:')) msg = msg.slice(6);
      else if (msg.includes('401')) msg = 'Нужна авторизация';
      setMsg(profileMsg, msg, 'error');
    }
  });

}

init();

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\profile.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\signal.js =====
--- SIZE: 1275 bytes ---

// signal.js — WebSocket helpers (добавлены повторы и лог)
function isWsOpen(ws) {
  return ws && ws.readyState === WebSocket.OPEN;
}

function _safeSend(ws, obj, maxRetries = 3) {
  if (!isWsOpen(ws)) {
    if (maxRetries > 0) {
      setTimeout(() => _safeSend(ws, obj, maxRetries - 1), 300);
    }
    return false;
  }
  try {
    ws.send(JSON.stringify(obj));
    return true;
  } catch (e) {
    console.warn("WS send failed:", e);
    if (maxRetries > 0) {
      setTimeout(() => _safeSend(ws, obj, maxRetries - 1), 300);
    }
    return false;
  }
}

function sendPing(ws) {
  _safeSend(ws, { type: "ping" });
}

/**
 * @param {WebSocket} ws
 * @param {"offer"|"answer"|"ice-candidate"} type
 * @param {object} payload - { sdp } или { candidate }
 * @param {string} fromUserId
 * @param {string=} targetUserId
 */
function sendSignal(ws, type, payload, fromUserId, targetUserId) {
  const body = { type: "signal", signalType: type, fromUserId, ...payload };
  if (targetUserId) body.targetUserId = targetUserId;
  _safeSend(ws, body);
}

function sendChat(ws, content, fromUserId) {
  _safeSend(ws, { type: "chat", content, fromUserId });
}

export { isWsOpen, sendPing, sendSignal, sendChat };

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\signal.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\ui.js =====
--- SIZE: 1272 bytes ---

// ui.js - UI helpers
export function bind(el, event, fn){ el?.addEventListener(event, fn); }
export function setText(el, text){ if (el) el.textContent = text; }
export function setEnabled(el, enabled){ if (el) el.disabled = !enabled; }

export function appendLog(container, msg){
  const tpl = document.getElementById('tpl-log-line');
  const node = tpl.content.firstElementChild.cloneNode(true);
  node.querySelector('.time').textContent = new Date().toLocaleTimeString() + ' ';
  node.querySelector('.msg').textContent = msg;
  container.appendChild(node);
  container.scrollTop = container.scrollHeight;
}

export function appendChat(container, who, text, opts={}){
  const { self=false } = opts;
  const line = document.createElement('div');
  line.classList.add('chat-line', self ? 'self' : 'other');
  if (self) {
    line.innerHTML = `<span class="bubble">${escapeHtml(text)}</span>`;
  } else {
    line.innerHTML = `<span class="bubble"><strong class="nick">${escapeHtml(who)}</strong> ${escapeHtml(text)}</span>`;
  }
  container.appendChild(line);
  container.scrollTop = container.scrollHeight;
}

function escapeHtml(s){
  return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\ui.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc.js =====
--- SIZE: 2648 bytes ---

// webrtc.js — thin compatibility wrapper. All real logic in WebCallClient (webrtc_manager.js)
// Используем фасад WebCallClient. При потребности можно также импортировать части из './webrtc/index.js'
import { WebCallClient } from './webrtc_manager.js';

export class WebRTCManager {
  constructor(opts){ this._client = new WebCallClient(opts); }
  init(...a){ return this._client.init(...a); }
  handleSignal(...a){ return this._client.handleSignal(...a); }
  startOffer(...a){ return this._client.startOffer(...a); }
  toggleMic(...a){ return this._client.toggleMic(...a); }
  toggleCameraStream(...a){ return this._client.toggleCameraStream(...a); }
  startCamera(...a){ return this._client.startCamera(...a); }
  startScreenShare(...a){ return this._client.startScreenShare(...a); }
  stopCamera(...a){ return this._client.stopCamera(...a); }
  stopScreenShare(...a){ return this._client.stopScreenShare(...a); }
  stopVideo(...a){ return this._client.stopVideo(...a); }
  toggleScreenShare(...a){ return this._client.toggleScreenShare(...a); }
  switchCamera(...a){ return this._client.switchCamera(...a); }
  switchScreenShareWindow(...a){ return this._client.switchScreenShareWindow(...a); }
  enableComposite(...a){ return this._client.enableComposite(...a); }
  disableComposite(...a){ return this._client.disableComposite(...a); }
  toggleComposite(...a){ return this._client.toggleComposite(...a); }
  updateAllPeerTracks(...a){ return this._client.updateAllPeerTracks(...a); }
  diagnoseAudio(...a){ return this._client.diagnoseAudio(...a); }
  diagnoseVideo(...a){ return this._client.diagnoseVideo(...a); }
  close(...a){ return this._client.close(...a); }
  setPreferredDevices(...a){ return this._client.setPreferredDevices(...a); }
  getOutputDeviceId(...a){ return this._client.getOutputDeviceId(...a); }
  bindPeerMedia(...a){ return this._client.bindPeerMedia(...a); }

  // === Back-compat property proxies (старый код обращается к этим полям напрямую) ===
  get peers(){ return this._client.peers; }
  get localStream(){ return this._client.localStream; }
  get preferred(){ return this._client.preferred; }
  get _currentVideoKind(){ return this._client._currentVideoKind; }
  get _cameraTrack(){ return this._client._cameraTrack; }
  get _screenTrack(){ return this._client._screenTrack; }
  // Не делаем сеттеры — изменение через возвращённые объекты (preferred.camId=) затронет оригинал.
}

export { WebCallClient };

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\architecture.md =====
--- SIZE: 5404 bytes ---

# Архитектура модульного WebRTC слоя (план рефакторинга)

Этот документ описывает целевую декомпозицию текущего монолитного `WebRTCManager`.

## Текущее состояние
Один класс `WebRTCManager` (~1.4K LOC) совмещает:
1. Управление локальными медиа (микрофон / камера / экран / адаптация качества / превью / композиция Canvas).
2. Управление пирами и их жизненным циклом (создание `RTCPeerConnection`, transceiver policy, ICE restart, glare resolution, watchdog).
3. Логику протокола сигналинга (обработка offer/answer/candidates + коллизии).
4. Диагностику и метрики (audio RMS, video stats, SDP introspection, watchdog).
5. UI‑ориентированные побочные эффекты (манипуляции DOM: canvas, видео‑элемент, inline стили).

Это нарушает принцип **SRP** и затрудняет тестирование/расширение.

## Целевая декомпозиция (итеративно)
Модули (директория `./webrtc/`):

| Модуль | Ответственность | Внешний контракт |
|--------|-----------------|------------------|
| `media.js` (`MediaManager`) | Локальные устройства и треки: захват, переключение, адаптация качества, screen share | Методы `startCamera()`, `stopCamera()`, `startScreenShare()`, `stopScreenShare()`, события колбеков |
| `peers.js` (`PeerConnectionManager`) | Создание/хранение `RTCPeerConnection`, политика transceivers, ICE restart, glare, watchdog | CRUD пиров, события состояния, методы `ensurePeer`, `handleOffer/Answer/Candidate` |
| `signaling.js` (`SignalingOrchestrator`) | Высокоуровневый FSM переговоров, согласование ролей (polite/impolite), очереди glare, ретраи | Метод `handleSignal(raw)` produce actions для PeerConnectionManager |
| `tracks.js` (`TrackRouter`) | Привязка локальных треков к пирам (замена/добавление senders), слот экрана/камеры, политика up/downscale | `attachLocalTrack(kind, track)` |
| `composite.js` | Canvas PiP композиция (экран + камера) | `enable(canvas)`, `disable()` |
| `metrics.js` | Сбор локальных видео метрик и аудио RMS | Подписка на треки, колбеки обновлений |
| `diagnostics.js` | Функции инспекции (SDP, transceivers, stats) без побочных изменений | Набор чистых утилит |
| `webrtc_manager.js` | Фасад — связывает все менеджеры и сохраняет прежний публичный API | Экспорт совместимого класса |

## Принципы SOLID
* **SRP** — каждый модуль узко сфокусирован.
* **OCP** — расширения (например новая стратегия кандидатов или альтернативный анализатор уровня) добавляются новыми классами без правки фасада.
* **LSP** — мелкие интерфейсы (например стратегия адаптации качества) можно подменять.
* **ISP** — вместо одного «толстого» интерфейса WebRTC предоставляются целевые контракты (Media, Peers, Signaling...).
* **DIP** — `webrtc_manager.js` зависит от абстракций (интерфейсы стратегий), а не от конкретных реализаций.

## Стратегия миграции
1. (Этап 1 — текущий) Ввести новые файлы и перенести логику локальных медиа в `MediaManager` с минимальными зависимостями.
2. Этап 2: Извлечь управление пирами (`_ensurePeer`, ICE restart, watchdog) в `PeerConnectionManager`.
3. Этап 3: Вынести разбор сигналов (offer/answer/candidate) + glare очередь в `SignalingOrchestrator`.
4. Этап 4: Выделить композицию и метрики.
5. Этап 5: Очистить `webrtc.js`, заменить на тонкий реэкспорт `webrtc_manager.js` (обратная совместимость через прежнее имя класса).

## Критерии завершенности этапа 1
* Существующий код продолжает работать без модификации импортов.
* Добавлен `MediaManager` и документация.
* Следующий коммит может начать замену методов камеры/экрана на делегирование.

Этот файл удалится или упростится после полной миграции.

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\architecture.md =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\composite.js =====
--- SIZE: 2579 bytes ---

// composite.js — отвечает за композицию локального видео (камера + экран) в canvas

export class CanvasCompositeManager {
  constructor({ logger }){
    this._log = logger || (()=>{});
    this._enabled = false;
    this._canvas = null;
    this._raf = null;
    this._getTracks = null; // () => { screenTrack, camTrack }
  }
  bindEnvironment({ getTracks }){ this._getTracks = getTracks; }

  enable(canvas){
    try {
      if (!canvas) return false;
      this._canvas = canvas;
      this._enabled = true;
      canvas.style.display = '';
      this._loop();
      this._log('Composite canvas enabled');
      return true;
    } catch(e){ this._log('enableComposite error: '+(e?.name||e)); return false; }
  }
  disable(){
    this._enabled = false;
    if (this._raf) cancelAnimationFrame(this._raf); this._raf=null;
    if (this._canvas){ this._canvas.getContext('2d')?.clearRect(0,0,this._canvas.width,this._canvas.height); this._canvas.style.display='none'; }
    this._log('Composite canvas disabled');
  }
  toggle(canvas){ if (this._enabled) this.disable(); else this.enable(canvas||this._canvas); }
  isEnabled(){ return this._enabled; }
  currentCanvas(){ return this._canvas; }

  _loop(){
    if (!this._enabled || !this._canvas){ return; }
    const ctx = this._canvas.getContext('2d'); if (!ctx){ return; }
    const { screenTrack, camTrack } = (this._getTracks?.() || {});
    const W = this._canvas.width; const H = this._canvas.height;
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H);
    const drawTrack = (track, dx,dy,dw,dh)=>{
      try {
        const el = track._wcOffscreenEl || (track._wcOffscreenEl = document.createElement('video'));
        if (!el.srcObject){ const ms = new MediaStream([track]); el.srcObject = ms; el.muted=true; el.playsInline=true; el.autoplay=true; el.play().catch(()=>{}); }
        if (el.readyState >= 2){ ctx.drawImage(el, dx,dy,dw,dh); }
      } catch {}
    };
    if (screenTrack){
      drawTrack(screenTrack, 0,0,W,H);
      if (camTrack){
        const pipW = Math.round(W*0.22); const pipH = Math.round(pipW*(9/16));
        drawTrack(camTrack, W-pipW-24, H-pipH-24, pipW, pipH);
        ctx.strokeStyle = 'rgba(255,255,255,0.8)'; ctx.lineWidth = 3; ctx.strokeRect(W-pipW-24+1.5, H-pipH-24+1.5, pipW-3, pipH-3);
      }
    } else if (camTrack){
      drawTrack(camTrack, 0,0,W,H);
    } else {
      this.disable();
      return;
    }
    this._raf = requestAnimationFrame(()=> this._loop());
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\composite.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\diagnostics.js =====
--- SIZE: 5311 bytes ---

// diagnostics.js — диагностика аудио/видео и трансиверов
export class DiagnosticsManager {
  constructor({ logger } = {}) {
    this._logger = logger || (()=>{});
    this._env = { getLocalStream: ()=>null, getPeers: ()=> new Map() };
  }
  bindEnvironment(env){
    this._env = Object.assign(this._env, env||{});
  }
  _log(m){ try { this._logger(m); } catch {} }

  async diagnoseAudio(){
    const localStream = this._env.getLocalStream();
    const peers = this._env.getPeers();
    this._log('=== 🔊 АУДИО ДИАГНОСТИКА ===');
    if (localStream){
      const ats = localStream.getAudioTracks();
      this._log(`📱 Локальный поток: ${ats.length} аудио треков`);
      ats.forEach((t,i)=> this._log(`🎤 Трек ${i}: enabled=${t.enabled}, readyState=${t.readyState}, muted=${t.muted}`));
    } else {
      this._log('❌ НЕТ локального потока!');
    }
    this._log(`🔗 Активных соединений: ${peers.size}`);

    for (const [peerId, st] of peers){
      const pc = st.pc;
      this._log(`--- Peer ${peerId.slice(0,8)} ---`);
      this._log(`📊 Состояние: ${pc.connectionState}`);
      this._log(`🧊 ICE: ${pc.iceConnectionState}`);
      this._log(`📡 Signaling: ${pc.signalingState}`);
      try {
        const localSdp = pc.localDescription?.sdp || ''; const remoteSdp = pc.remoteDescription?.sdp || '';
        const mAudioLocal = (localSdp.match(/^m=audio /gm)||[]).length;
        const mAudioRemote = (remoteSdp.match(/^m=audio /gm)||[]).length;
        this._log(`📝 SDP m=audio local=${mAudioLocal} remote=${mAudioRemote}`);
      } catch {}
      try {
        pc.getTransceivers().filter(t=> t.receiver?.track?.kind==='audio' || t.sender?.track?.kind==='audio').forEach((t,idx)=>{
          this._log(`🔁 TR#a${idx} mid=${t.mid} dir=${t.direction} cur=${t.currentDirection} hasSender=${!!t.sender?.track} hasRecv=${!!t.receiver?.track}`);
        });
      } catch {}
      // Статистика
      try {
        const stats = await pc.getStats();
        let hasActiveConnection = false;
        stats.forEach(r=>{
          if (r.type === 'transport' && r.selectedCandidatePairId) {
            const candidatePair = stats.get(r.selectedCandidatePairId);
            if (candidatePair && candidatePair.state === 'succeeded') {
              hasActiveConnection = true;
              this._log(`🌐 Активное соединение: ${candidatePair.localCandidateId} ↔ ${candidatePair.remoteCandidateId}`);
            }
          }
          if (r.type === 'inbound-rtp' && r.kind === 'audio') {
            this._log(`📥 Входящий аудио: ${r.bytesReceived} bytes, ${r.packetsReceived} packets`);
          }
          if (r.type === 'outbound-rtp' && r.kind === 'audio') {
            this._log(`📤 Исходящий аудио: ${r.bytesSent} bytes, ${r.packetsSent} packets`);
          }
        });
        this._log(`✅ Активное соединение: ${hasActiveConnection ? 'Да' : 'Нет'}`);
      } catch(e){ this._log(`❌ Ошибка получения статистики: ${e}`); }
    }
    this._log('=== КОНЕЦ ДИАГНОСТИКИ ===');
  }

  async diagnoseVideo(){
    const localStream = this._env.getLocalStream();
    const peers = this._env.getPeers();
    this._log('=== 🎥 ВИДЕО ДИАГНОСТИКА ===');
    if (localStream){
      const vts = localStream.getVideoTracks();
      this._log(`📱 Локальный поток: ${vts.length} видео трек(а)`);
      vts.forEach((t,i)=> this._log(`📸 Трек ${i}: id=${t.id}, label="${t.label}", state=${t.readyState}, enabled=${t.enabled}`));
    } else {
      this._log('❌ НЕТ локального потока (video)');
    }
    for (const [peerId, st] of peers){
      const pc = st.pc;
      this._log(`--- Peer ${peerId.slice(0,8)} video ---`);
      try {
        const trans = pc.getTransceivers();
        trans.filter(t=> (t.sender?.track?.kind==='video') || (t.receiver?.track?.kind==='video')).forEach((t,idx)=>{
          this._log(`🔁 TX#${idx} mid=${t.mid} dir=${t.direction} cur=${t.currentDirection} senderTrack=${t.sender?.track?.id||'-'} recvTrack=${t.receiver?.track?.id||'-'}`);
        });
        const senders = pc.getSenders().filter(s=> s.track && s.track.kind==='video');
        senders.forEach(s=> this._log(`➡️ sender track=${s.track.id} rtcp=${s.transport?.state||'?'} params=${(s.getParameters().encodings||[]).length}enc`));
        const receivers = pc.getReceivers().filter(r=> r.track && r.track.kind==='video');
        receivers.forEach(r=> this._log(`⬅️ receiver track=${r.track.id} state=${r.track.readyState}`));
        if (st.stream){
          const remoteV = st.stream.getVideoTracks();
            this._log(`📥 remote stream video tracks=${remoteV.length}`);
            remoteV.forEach((t,i)=> this._log(`   [${i}] id=${t.id} ready=${t.readyState} muted=${t.muted}`));
        }
      } catch(e){ this._log(`diagnoseVideo error: ${e?.name||e}`); }
    }
    this._log('=== КОНЕЦ ВИДЕО ДИАГНОСТИКИ ===');
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\diagnostics.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\event_bus.js =====
--- SIZE: 1268 bytes ---

// event_bus.js
// Простой шина событий без внешних зависимостей.
// API: on(event, handler), off(event, handler), once(event, handler), emit(event, payload)

export class EventBus {
  constructor(logger){ this._handlers = new Map(); this._logger = logger || (()=>{}); }
  on(evt, fn){ if(!this._handlers.has(evt)) this._handlers.set(evt, new Set()); this._handlers.get(evt).add(fn); return ()=> this.off(evt, fn); }
  once(evt, fn){ const wrap = (p)=>{ try{ fn(p); } finally { this.off(evt, wrap); } }; return this.on(evt, wrap); }
  off(evt, fn){ const s = this._handlers.get(evt); if(!s) return; s.delete(fn); if(!s.size) this._handlers.delete(evt); }
  emit(evt, payload){ const s = this._handlers.get(evt); if(!s) return; for(const fn of [...s]){ try{ fn(payload); } catch(e){ this._logger('EventBus handler error '+(e?.message||e)); } } }
  clear(){ this._handlers.clear(); }
}

// Список рекомендуемых событий:
// peer:state      { peerId, key, value }
// video:state     { kind, track }
// metrics:video   { peerId?, fps, width, height }
// audio:level     { peerId, rms }
// negotiation     { peerId, type }
// diagnostics:audio { result }
// diagnostics:video { result }

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\event_bus.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\index.js =====
--- SIZE: 573 bytes ---

// index.js — централизованный реэкспорт всех модулей WebRTC слоя
export { MediaManager } from './media.js';
export { PeerConnectionManager } from './peers.js';
export { SignalingOrchestrator } from './signaling.js';
export { CanvasCompositeManager } from './composite.js';
export { MetricsManager, AudioLevelAnalyzer } from './metrics.js';
export { DiagnosticsManager } from './diagnostics.js';
export { DefaultVideoAdaptationStrategy } from './strategies/video_adaptation.js';
export { EventBus } from './event_bus.js';

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\index.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\media.js =====
--- SIZE: 7802 bytes ---

// media.js — управление локальными медиа (камера, экран, адаптация)
// Этап 1: извлекаем часть логики из монолита WebRTCManager.

export class MediaManager {
  constructor({ logger, onVideoState, constraints } = {}) {
    this._log = typeof logger === 'function' ? logger : (()=>{});
    this.onVideoState = onVideoState || (()=>{});
    this.videoConstraints = constraints || {
      camera: { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 24, max: 30 } },
      screen: { frameRate: 15 }
    };
    // Текущее состояние
    this._cameraTrack = null;
    this._screenTrack = null;
    this._screenStream = null;
    this._currentVideoKind = 'none'; // camera | screen | multi | none
    this._localStreamProvider = null; // функция получения/создания общего локального потока (инжектируется)
    this._attachVideoTrack = null; // стратегия присоединения/замены трека к пирам (инжектируется)
    this._updateLocalPreview = null; // колбек обновления DOM превью
    this._adaptationStrategy = this._defaultAdaptation.bind(this);
  }

  // Инъекция зависимостей (поздняя, чтобы не тянуть весь WebRTCManager внутрь)
  bindEnvironment({ getOrCreateLocalStream, attachVideoTrack, updateLocalPreview }) {
    this._localStreamProvider = getOrCreateLocalStream;
    this._attachVideoTrack = attachVideoTrack;
    this._updateLocalPreview = updateLocalPreview;
  }

  get cameraTrack() { return this._cameraTrack; }
  get screenTrack() { return this._screenTrack; }
  get currentKind() { return this._currentVideoKind; }

  async startCamera(preferredDeviceId) {
    if (this._cameraTrack && this._cameraTrack.readyState === 'live') {
      this._log('MediaManager: камера уже активна');
      return this._cameraTrack;
    }
    try {
      const base = preferredDeviceId ? { deviceId: { exact: preferredDeviceId }, ...this.videoConstraints.camera } : this.videoConstraints.camera;
      const gum = await navigator.mediaDevices.getUserMedia({ video: base, audio: false });
      const track = gum.getVideoTracks()[0];
      if (!track) throw new Error('Нет video track после getUserMedia');
      track._wcType = 'camera';
      const stream = await this._ensureLocalStream();
      if (this._cameraTrack) { try { this._cameraTrack.stop(); } catch {}; try { stream.removeTrack(this._cameraTrack); } catch {} }
      this._cameraTrack = track;
      stream.addTrack(track);
      await this._attachVideo(track);
      this._updatePreview();
      this._refreshKind();
      track.onended = () => { if (this._cameraTrack === track) this.stopCamera(); };
      this._log(`MediaManager: камера запущена id=${track.id}`);
      this._emitState('camera', track);
      return track;
    } catch (e) {
      this._log('MediaManager: startCamera error: ' + (e?.name || e));
      return null;
    }
  }

  stopCamera() {
    const track = this._cameraTrack;
    if (!track) return;
    try { track.stop(); } catch {}
    this._cameraTrack = null;
    const stream = this._safeLocalStream();
    if (stream) { try { stream.getVideoTracks().forEach(t => { if (t === track) stream.removeTrack(t); }); } catch {} }
    this._detachIfSender(track);
    this._updatePreview();
    this._refreshKind();
    this._log('MediaManager: камера остановлена');
    this._emitState(this._currentVideoKind, this._activeTrack());
  }

  async startScreenShare() {
    if (this._screenTrack && this._screenTrack.readyState === 'live') {
      this._log('MediaManager: screen share уже активен');
      return this._screenTrack;
    }
    try {
      const ds = await navigator.mediaDevices.getDisplayMedia({ video: this.videoConstraints.screen, audio: false });
      const track = ds.getVideoTracks()[0];
      if (!track) throw new Error('Нет screen трека');
      track._wcType = 'screen';
      this._screenStream = ds;
      const stream = await this._ensureLocalStream();
      if (this._screenTrack) { try { this._screenTrack.stop(); } catch {}; try { stream.removeTrack(this._screenTrack); } catch {} }
      this._screenTrack = track;
      stream.addTrack(track);
      await this._attachVideo(track);
      this._updatePreview();
      this._refreshKind();
      track.onended = () => { if (this._screenTrack === track) this.stopScreenShare(); };
      this._log('MediaManager: screen share запущен');
      this._emitState('screen', track);
      return track;
    } catch (e) {
      this._log('MediaManager: startScreenShare error: ' + (e?.name || e));
      return null;
    }
  }

  stopScreenShare() {
    const track = this._screenTrack;
    if (!track) return;
    try { track.stop(); } catch {}
    const stream = this._safeLocalStream();
    if (stream) { try { stream.removeTrack(track); } catch {} }
    this._screenStream?.getTracks().forEach(t => { try { t.stop(); } catch {} });
    this._screenStream = null;
    this._screenTrack = null;
    this._detachIfSender(track);
    this._updatePreview();
    this._refreshKind();
    this._log('MediaManager: screen share остановлен');
    this._emitState(this._currentVideoKind, this._activeTrack());
  }

  async toggleCamera(preferredDeviceId) {
    if (this._cameraTrack) { this.stopCamera(); return false; }
    return !!(await this.startCamera(preferredDeviceId));
  }

  async toggleScreenShare() {
    if (this._screenTrack) { this.stopScreenShare(); return false; }
    return !!(await this.startScreenShare());
  }

  // === Internal helpers ===
  async _ensureLocalStream() {
    if (!this._localStreamProvider) throw new Error('Local stream provider не инжектирован');
    return await this._localStreamProvider();
  }
  _safeLocalStream() { try { return this._localStreamProvider ? this._localStreamProvider() : null; } catch { return null; } }
  async _attachVideo(track) { if (this._attachVideoTrack) await this._attachVideoTrack(track); }
  _detachIfSender(/*track*/) { /* На этапе 1 делегируем отсоединение внешнему коду позже */ }
  _updatePreview() { if (this._updateLocalPreview) try { this._updateLocalPreview(); } catch {} }
  _emitState(kind, track) { try { this.onVideoState(kind, track); } catch {} }
  _activeTrack() { return this._screenTrack || this._cameraTrack || null; }
  _refreshKind() {
    const cam = !!(this._cameraTrack && this._cameraTrack.readyState === 'live');
    const scr = !!(this._screenTrack && this._screenTrack.readyState === 'live');
    this._currentVideoKind = scr && cam ? 'multi' : (scr ? 'screen' : (cam ? 'camera' : 'none'));
    this._adaptationStrategy();
  }
  async _defaultAdaptation() {
    try {
      const camLive = this._cameraTrack && this._cameraTrack.readyState === 'live';
      const scrLive = this._screenTrack && this._screenTrack.readyState === 'live';
      if (!camLive) return;
      if (scrLive) {
        await this._cameraTrack.applyConstraints({ frameRate: 12, width: { ideal: 960 }, height: { ideal: 540 } }).catch(()=>{});
        this._log('MediaManager: адаптация камеры при активном screen share');
      } else {
        await this._cameraTrack.applyConstraints(this.videoConstraints.camera).catch(()=>{});
        this._log('MediaManager: восстановлены ограничения камеры');
      }
    } catch {}
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\media.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\metrics.js =====
--- SIZE: 3021 bytes ---

// metrics.js — сбор локальных видео метрик и анализ аудио уровня пиров

export class MetricsManager {
  constructor({ logger }){
    this._log = logger || (()=>{});
    this._videoTimer = null;
    this._metrics = { fps:0, width:0, height:0 };
    this._getCurrentTracks = null; // ()=> ({ cameraTrack, screenTrack, kind })
  }
  bindEnvironment({ getTracks }){ this._getCurrentTracks = getTracks; }
  ensureLoop(){ if (!this._videoTimer) this._start(); }
  stopLoop(){ if (this._videoTimer){ clearInterval(this._videoTimer); this._videoTimer=null; this._updateDom(null); } }
  _start(){
    const update = ()=>{
      try {
        const { cameraTrack, screenTrack, kind } = this._getCurrentTracks?.() || {};
        const track = screenTrack || cameraTrack;
        if (!track || track.readyState!=='live'){ this.stopLoop(); return; }
        let st = {}; try { st = track.getSettings? track.getSettings():{}; } catch{}
        this._metrics.width = st.width || this._metrics.width;
        this._metrics.height = st.height || this._metrics.height;
        this._metrics.fps = st.frameRate ? Math.round(st.frameRate) : this._metrics.fps;
        this._updateDom(kind);
      } catch{}
    };
    this._videoTimer = setInterval(update, 1000);
    update();
  }
  _updateDom(kind){
    const el = document.getElementById('localVideoMetrics');
    if (!el) return;
    if (!kind){ el.style.display='none'; el.textContent='—'; return; }
    el.style.display='';
    el.textContent = `${kind} ${this._metrics.width||'?'}x${this._metrics.height||'?'} @${this._metrics.fps||0}fps`;
  }
}

export class AudioLevelAnalyzer {
  constructor({ logger }){
    this._log = logger || (()=>{});
  }
  attach(peerState, peerId){
    try {
      if (!window.AudioContext || !peerState.stream?.getAudioTracks().length) return;
      if (peerState.level?.raf) cancelAnimationFrame(peerState.level.raf);
      peerState.level = peerState.level || {};
      peerState.level.ctx = new AudioContext();
      const src = peerState.level.ctx.createMediaStreamSource(peerState.stream);
      peerState.level.analyser = peerState.level.ctx.createAnalyser();
      peerState.level.analyser.fftSize = 256;
      src.connect(peerState.level.analyser);
      const data = new Uint8Array(peerState.level.analyser.frequencyBinCount);
      const loop = ()=>{
        peerState.level.analyser.getByteTimeDomainData(data);
        let sum=0; for (let i=0;i<data.length;i++){ const v=(data[i]-128)/128; sum+=v*v; }
        const rms = Math.sqrt(sum/data.length);
        if (peerState.handlers?.onLevel) peerState.handlers.onLevel(rms);
        peerState.level.raf = requestAnimationFrame(loop);
      };
      peerState.level.raf = requestAnimationFrame(loop);
      this._log(`Настроен аудио анализатор для ${peerId.slice(0,8)}`);
    } catch(e){ this._log(`level[${peerId.slice(0,8)}]: ${e?.name||e}`); }
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\metrics.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\peers.js =====
--- SIZE: 6051 bytes ---

// peers.js — управление RTCPeerConnection экземплярами
import { sendSignal } from '../signal.js';

export class PeerConnectionManager {
  constructor({ logger, iceConfigProvider, onPeerState, isPoliteFn }) {
    this._log = logger || (()=>{});
    this._iceConfigProvider = iceConfigProvider; // async () => RTCConfiguration
    this._onPeerState = onPeerState || (()=>{});
    this._isPolite = isPoliteFn || ((myId, otherId) => String(myId) > String(otherId));
    this._peers = new Map(); // peerId -> state
    this._userId = null;
    this._ws = null;
  }

  bindSession({ userId, ws }) { this._userId = userId; this._ws = ws; }
  get peersMap() { return this._peers; }
  get(peerId){ return this._peers.get(peerId); }
  listIds(){ return Array.from(this._peers.keys()); }

  async ensurePeer(peerId, { onTrackCallback }) {
    if (this._peers.has(peerId)) return this._peers.get(peerId);
    const iceConfig = await this._iceConfigProvider();
    const pc = new RTCPeerConnection({ ...iceConfig, bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' });
    const state = {
      pc,
      stream: new MediaStream(),
      candidates: [],
      remoteSet: false,
      handlers: null,
      makingOffer: false,
      ignoreOffer: false,
      polite: this._isPolite(this._userId, peerId),
      iceFailTimer: null,
      audioTransceiver: null,
      videoWatchdogTimer: null,
    };

    pc.addEventListener('icecandidate', (e) => {
      if (e.candidate) {
        sendSignal(this._ws, 'ice-candidate', { candidate: e.candidate }, this._userId, peerId);
        this._log(`🧊 Sent ICE candidate to ${peerId.slice(0,8)}: ${e.candidate.candidate}`);
      }
    });

    pc.addEventListener('track', (e) => {
      try { this._log(`Получен трек от ${peerId.slice(0,8)}: ${e.track.kind}`); } catch {}
      if (e.track && !state.stream.getTracks().some(t=> t.id === e.track.id)) {
        state.stream.addTrack(e.track);
      }
      if (state.handlers?.onTrack) {
        try { state.handlers.onTrack(state.stream); } catch {}
      } else if (onTrackCallback) {
        try { onTrackCallback(peerId, state.stream); } catch {}
      }
    });

    pc.addEventListener('negotiationneeded', async () => {
      if (state.makingOffer) return;
      try {
        state.makingOffer = true;
        this._log(`⚙️ negotiationneeded → createOffer (polite=${state.polite}) for ${peerId.slice(0,8)}`);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        sendSignal(this._ws, 'offer', { sdp: offer.sdp }, this._userId, peerId);
        this._log(`📤 Sent offer → ${peerId.slice(0,8)} (negotiationneeded)`);
      } catch(e){ this._log(`negotiationneeded(${peerId.slice(0,8)}): ${e?.name||e}`); }
      finally { state.makingOffer = false; }
    });

    pc.addEventListener('connectionstatechange', () => {
      const s = pc.connectionState;
      try { this._onPeerState(peerId, 'net', s); } catch {}
      this._log(`PC(${peerId.slice(0,8)}) = ${s}`);
      if (s === 'failed') {
        this.iceRestart(peerId).catch(()=>{});
      } else if (s === 'disconnected') {
        clearTimeout(state.iceFailTimer);
        state.iceFailTimer = setTimeout(()=>{ if (pc.connectionState === 'disconnected') this.iceRestart(peerId).catch(()=>{}); }, 2000);
      } else if (s === 'connected' || s === 'completed') {
        clearTimeout(state.iceFailTimer); state.iceFailTimer = null;
      }
    });

    // Превентивные transceivers
    try {
      const hasVideoTr = pc.getTransceivers().some(t=> t.receiver?.track?.kind==='video' || t.sender?.track?.kind==='video');
      if (!hasVideoTr) pc.addTransceiver('video', { direction: 'recvonly' });
      const hasAudioTr = pc.getTransceivers().some(t=> t.receiver?.track?.kind==='audio' || t.sender?.track?.kind==='audio');
      if (!hasAudioTr) {
        const atr = pc.addTransceiver('audio', { direction:'recvonly'});
        state.audioTransceiver = atr;
      }
    } catch {}

    this._peers.set(peerId, state);
    return state;
  }

  async iceRestart(peerId){
    const st = this._peers.get(peerId); if (!st) return;
    this._log(`ICE-restart → ${peerId.slice(0,8)}`);
    try {
      const offer = await st.pc.createOffer({ iceRestart: true });
      await st.pc.setLocalDescription(offer);
      sendSignal(this._ws, 'offer', { sdp: offer.sdp }, this._userId, peerId);
    } catch(e){ this._log(`ICE-restart(${peerId.slice(0,8)}): ${e?.name||e}`); }
  }

  scheduleRemoteVideoWatchdog(peerId, { hasLocalVideo }){
    try {
      const st = this._peers.get(peerId); if (!st) return;
      if (st.videoWatchdogTimer) clearTimeout(st.videoWatchdogTimer);
      if (!hasLocalVideo) return;
      st.videoWatchdogTimer = setTimeout(()=>{
        try {
          const pc = st.pc;
          const remoteVideoTracks = st.stream.getVideoTracks();
            if (remoteVideoTracks.length > 0) return;
            if (pc.signalingState !== 'stable') return;
            if (st.polite) return;
            this._log(`🛠 Watchdog: нет входящего видео от ${peerId.slice(0,8)} → форсируем повторный offer`);
            pc.createOffer().then(of=> pc.setLocalDescription(of).then(()=>{
              sendSignal(this._ws, 'offer', { sdp: of.sdp }, this._userId, peerId);
              this._log(`📤 Sent watchdog offer → ${peerId.slice(0,8)}`);
            })).catch(e=> this._log(`watchdogOffer(${peerId.slice(0,8)}): ${e?.name||e}`));
        } catch {}
      }, 2000);
    } catch {}
  }

  bindPeerMedia(peerId, handlers){
    const st = this._peers.get(peerId); if (!st) return;
    st.handlers = Object.assign({}, st.handlers||{}, handlers||{});
    if (st.stream && (st.stream.getAudioTracks().length || st.stream.getVideoTracks().length)){
      try { st.handlers?.onTrack?.(st.stream); } catch {}
    }
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\peers.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\signaling.js =====
--- SIZE: 6581 bytes ---

// signaling.js — оркестрация сигналинга (offer/answer/candidates, glare)
import { sendSignal } from '../signal.js';

export class SignalingOrchestrator {
  constructor({ logger, ensurePeer, getState, getLocalStream, userIdProvider, wsProvider, updateAllPeerTracks, forceVideoSenderSync, scheduleWatchdog }) {
    this._log = logger || (()=>{});
    this._ensurePeer = ensurePeer; // async (peerId)=> peerState
    this._getState = getState; // ()=> ({ userId, peersMap })
    this._getLocalStream = getLocalStream; // ()=> MediaStream|null
    this._userIdProvider = userIdProvider; // ()=> userId
    this._wsProvider = wsProvider; // ()=> ws
    this._updateAllPeerTracks = updateAllPeerTracks; // ()=> Promise<void>
    this._forceVideoSenderSync = forceVideoSenderSync; // ()=>void
    this._scheduleWatchdog = scheduleWatchdog; // (peerId)=>void
    this._pendingGlare = new Map(); // peerId -> { sdp, ts }
  }

  async handle(msg, mediaBinder){
    const myId = this._userIdProvider();
    if (msg?.fromUserId && myId && msg.fromUserId === myId) return;
    if (msg?.targetUserId && myId && msg.targetUserId !== myId) return;

    const ws = this._wsProvider();
    const peerId = msg.fromUserId;
    const peer = await this._ensurePeer(peerId);
    const pc = peer.pc;

    if (mediaBinder && !peer.handlers) {
      mediaBinder(peerId, { onTrack: ()=>{}, onLevel: ()=>{}, onSinkChange: ()=>{} });
    }

    if (msg.signalType === 'offer') {
      const desc = { type: 'offer', sdp: msg.sdp };
      this._log(`📥 Received OFFER from ${peerId.slice(0,8)}`);
      const offerCollision = peer.makingOffer || pc.signalingState !== 'stable';
      peer.ignoreOffer = !peer.polite && offerCollision;
      if (peer.ignoreOffer){
        this._log(`⏭️ Ignore offer (collision, impolite) from ${peerId.slice(0,8)}`);
        this._pendingGlare.set(peerId, { sdp: msg.sdp, ts: Date.now() });
        setTimeout(()=> this._retryGlare(peerId), 150);
        return;
      }
      try {
        if (offerCollision) await pc.setLocalDescription({ type: 'rollback' });
        await pc.setRemoteDescription(desc);
        peer.remoteSet = true;
        await this._flushCandidates(peerId);
        await this._prepareAudioBeforeAnswer(peerId, pc, peer);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        sendSignal(ws, 'answer', { sdp: answer.sdp }, myId, peerId);
        this._log(`📤 Answered offer → ${peerId.slice(0,8)}`);
        if (this._getLocalStream()) await this._updateAllPeerTracks();
        this._scheduleWatchdog(peerId);
      } catch(e){ this._log(`SRD(offer)[${peerId.slice(0,8)}]: ${e?.name||e}`); }

    } else if (msg.signalType === 'answer') {
      if (pc.signalingState !== 'have-local-offer'){ this._log(`Ignore answer in ${pc.signalingState}`); return; }
      try {
        this._log(`📥 Received ANSWER from ${peerId.slice(0,8)}`);
        await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
        peer.remoteSet = true;
        await this._flushCandidates(peerId);
        if (this._getLocalStream()) await this._updateAllPeerTracks();
        this._scheduleWatchdog(peerId);
      } catch(e){ this._log(`SRD(answer)[${peerId.slice(0,8)}]: ${e?.name||e}`); }

    } else if (msg.signalType === 'ice-candidate' || msg.signalType === 'ice_candidate') {
      this._log(`🧊 ICE from ${peerId.slice(0,8)}`);
      if (!peer.remoteSet) peer.candidates.push(msg.candidate);
      else {
        try { await pc.addIceCandidate(msg.candidate); }
        catch(e){ this._log(`addIce[${peerId.slice(0,8)}]: ${e?.name||e}`); }
      }
    }
  }

  async startOffer(peerId){
    const myId = this._userIdProvider();
    const ws = this._wsProvider();
    const st = await this._ensurePeer(peerId);
    const pc = st.pc;
    if (st.polite){ this._log(`Not initiator for ${peerId.slice(0,8)}`); return; }
    if (pc.signalingState !== 'stable'){ this._log(`Skip offer in ${pc.signalingState}`); return; }
    try {
      st.makingOffer = true;
      await this._prepareAudioForOffer(st, pc);
      this._forceVideoSenderSync();
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      sendSignal(ws, 'offer', { sdp: offer.sdp }, myId, peerId);
      this._log(`📤 Sent offer (manual) → ${peerId.slice(0,8)}`);
    } catch(e){
      this._log(`startOffer(${peerId.slice(0,8)}): ${e?.name||e}`);
    } finally { st.makingOffer = false; }
  }

  async _prepareAudioBeforeAnswer(peerId, pc, peer){
    try {
      let at = this._getLocalStream()?.getAudioTracks?.()[0];
      if (!at){ /* вызывающая сторона сама адаптирует */ }
      let tx = pc.getTransceivers().find(t => (t.receiver?.track?.kind==='audio') || t.mid === '0');
      if (!tx) tx = pc.addTransceiver('audio', { direction: 'sendrecv' });
      tx.direction = 'sendrecv';
      if (at) await tx.sender.replaceTrack(at);
      peer.audioTransceiver = tx;
    } catch(e){ this._log(`prepareAudioBeforeAnswer: ${e?.name||e}`); }
  }
  async _prepareAudioForOffer(st, pc){
    try {
      let at = this._getLocalStream()?.getAudioTracks?.()[0];
      let tx = pc.getTransceivers().find(t => t.sender?.track?.kind==='audio' || t.receiver?.track?.kind==='audio');
      if (!tx) tx = pc.addTransceiver('audio', { direction:'sendrecv'});
      else tx.direction = 'sendrecv';
      if (at) await tx.sender.replaceTrack(at);
      st.audioTransceiver = tx;
    } catch(e){ this._log(`prepareAudioForOffer: ${e?.name||e}`); }
  }

  async _flushCandidates(peerId){
    const st = await this._ensurePeer(peerId);
    while (st.candidates.length){
      const c = st.candidates.shift();
      try { await st.pc.addIceCandidate(c); } catch(e){ this._log(`flush ICE[${peerId.slice(0,8)}]: ${e?.name||e}`); }
    }
  }

  _retryGlare(peerId){
    try {
      const st = this._getState().peersMap.get(peerId) || this._ensurePeer(peerId);
      const pc = st.pc;
      if (pc.signalingState !== 'stable'){ setTimeout(()=> this._retryGlare(peerId), 120); return; }
      const pending = this._pendingGlare.get(peerId); if (!pending) return;
      this._pendingGlare.delete(peerId);
      this._log(`🔄 Retrying glare offer from ${peerId.slice(0,8)}`);
      this.handle({ signalType:'offer', fromUserId: peerId, sdp: pending.sdp, targetUserId: this._userIdProvider() }).catch(()=>{});
    } catch {}
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\signaling.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\strategies\video_adaptation.js =====
--- SIZE: 1815 bytes ---

// video_adaptation.js
// Стратегия адаптации видео: выделена точка расширения для будущих алгоритмов (битрейт, разрешение, фреймрейт).
// Текущая реализация — no-op (заглушка), поскольку в фасаде пока нет активной логики изменения параметров отправки.
// Будущая интеграция: слушать метрики (MetricsManager) и при ухудшении условий снижать encodings / constraints.

export class BaseVideoAdaptationStrategy {
  constructor(ctx){
    this.ctx = ctx; // { getSender, getCameraTrack, logger }
    this._active = true;
  }
  isActive(){ return this._active; }
  dispose(){ this._active = false; }
  // Вызывается после старта камеры или смены трека
  onTrackStarted(track){ /* override */ }
  // Периодический тик (можно вызывать из MetricsManager позже)
  onMetricsTick(sample){ /* override */ }
  // Сигнал деградации сети
  onNetworkDegradation(info){ /* override */ }
  // Восстановление сети
  onNetworkRecovery(info){ /* override */ }
}

// Простейшая стратегия: фиксирует факт наличия трека и может логировать базовое состояние.
export class DefaultVideoAdaptationStrategy extends BaseVideoAdaptationStrategy {
  onTrackStarted(track){
    try { this.ctx?.logger?.('VideoAdaptStrategy: track started '+(track?.label||'')); } catch{}
  }
  onMetricsTick(sample){ /* здесь можно анализировать sample.fps, sample.resolution */ }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc\strategies\video_adaptation.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc_manager.js =====
--- SIZE: 16108 bytes ---

// webrtc_manager.js — новый фасад поверх модульных менеджеров
// Цель: предоставить более компактный API и изолировать внутреннюю реализацию.
// Централизованные импорты из единой точки (webrtc/index.js)
import { 
  MediaManager,
  PeerConnectionManager,
  SignalingOrchestrator,
  CanvasCompositeManager,
  MetricsManager,
  AudioLevelAnalyzer,
  DiagnosticsManager,
  DefaultVideoAdaptationStrategy,
  EventBus
} from './webrtc/index.js';
import { sendSignal } from './signal.js';
import { getIceServers } from './api.js';

export class WebCallClient {
  constructor(opts = {}){
    this._opts = opts;
    this.onLog = opts.onLog || (()=>{});
  // Legacy колбеки (сохраняем ради обратной совместимости)
  this.onPeerState = opts.onPeerState || (()=>{});
  this.onVideoState = opts.onVideoState || (()=>{});
  // EventBus как новая точка подписки
  this.events = new EventBus((m)=> this._log(m));
    this.localVideo = opts.localVideo || null;
    this.outputDeviceId = opts.outputDeviceId || null;

    // state
    this.ws = null; this.userId = null; this.iceConfig = null;
    this.localStream = null; this.preferred = { micId: undefined, camId: undefined };
    this.peers = new Map();
    this._cameraTrack = null; this._screenTrack = null; this._currentVideoKind='none';
    this._cameraSender=null; this._screenSender=null; this._videoSender=null;

    // managers
  this._media = new MediaManager({ logger: m=> this._log(m), onVideoState: (k,t)=> { this._safe(()=> this.onVideoState(k,t)); this.events.emit('video:state', { kind:k, track:t }); } });
    this._peers = new PeerConnectionManager({
      logger: m=> this._log(m),
      iceConfigProvider: async ()=>{ if(!this.iceConfig){ try{ this.iceConfig = await getIceServers(); }catch{ this.iceConfig = { iceServers:[{ urls:'stun:stun.l.google.com:19302'}] }; } } return this.iceConfig; },
  onPeerState: (pid,key,val)=> { this._safe(()=> this.onPeerState(pid,key,val)); this.events.emit('peer:state', { peerId:pid, key, value:val }); },
      isPoliteFn: (a,b)=> String(a)>String(b)
    });
    this._signaling = new SignalingOrchestrator({
      logger: m=> this._log(m),
      ensurePeer: (pid)=> this._ensurePeer(pid),
      getState: ()=> ({ userId: this.userId, peersMap: this.peers }),
      getLocalStream: ()=> this.localStream,
      userIdProvider: ()=> this.userId,
      wsProvider: ()=> this.ws,
      updateAllPeerTracks: ()=> this.updateAllPeerTracks(),
      forceVideoSenderSync: ()=> this._ensureExistingVideoSenders(),
      scheduleWatchdog: (pid)=> this._peers.scheduleRemoteVideoWatchdog?.(pid, { hasLocalVideo:!!(this._cameraTrack || this._screenTrack) })
    });
    this._metrics = new MetricsManager({ logger: m=> this._log(m) });
    this._metrics.bindEnvironment({ getTracks: ()=> ({ cameraTrack: this._cameraTrack?.readyState==='live'?this._cameraTrack:null, screenTrack: this._screenTrack?.readyState==='live'?this._screenTrack:null, kind: this._currentVideoKind }) });
    this._audioLevel = new AudioLevelAnalyzer({ logger: m=> this._log(m) });
    this._diagnostics = new DiagnosticsManager({ logger: m=> this._log(m) });
    this._diagnostics.bindEnvironment({ getLocalStream: ()=> this.localStream, getPeers: ()=> this.peers });
    this._composite = new CanvasCompositeManager({ logger: m=> this._log(m), getTracks: ()=> ({ cam: this._cameraTrack, scr: this._screenTrack }), onCompositeTrack: (track)=> this._attachOrReplaceVideoSender(track) });
    // Стратегия адаптации видео (пока заглушка, но точка расширения)
    this._videoStrategy = (opts.videoStrategy instanceof Function) ? new opts.videoStrategy({
      getSender: ()=> this._videoSender,
      getCameraTrack: ()=> this._cameraTrack,
      logger: (msg)=> this._log(msg)
    }) : new DefaultVideoAdaptationStrategy({
      getSender: ()=> this._videoSender,
      getCameraTrack: ()=> this._cameraTrack,
      logger: (msg)=> this._log(msg)
    });

    this._media.bindEnvironment({
      getOrCreateLocalStream: async ()=>{ if(!this.localStream){ const s = await this._getLocalMedia(); this.localStream = s|| new MediaStream(); if(this.localVideo) this.localVideo.srcObject = this.localStream; } return this.localStream; },
      attachVideoTrack: (track)=> this._attachOrReplaceVideoSender(track),
      updateLocalPreview: ()=> this._updateLocalPreview()
    });
  }

  _safe(fn){ try { fn(); } catch {} }
  _log(m){ this._safe(()=> this.onLog(m)); }

  // Public API (минимальный «поверх» старого)
  async init(ws, userId, devices){
    this.ws = ws; this.userId = userId; devices = devices||{}; if(devices.micId) this.preferred.micId=devices.micId; if(devices.camId) this.preferred.camId=devices.camId;
    if(!this.localStream){ const s = await this._getLocalMedia(); this.localStream = s; if(s && this.localVideo) this.localVideo.srcObject = s; if(this.localStream) await this.updateAllPeerTracks(); }
  // PeerConnectionManager ожидает { userId, ws }
  this._peers.bindSession({ userId: this.userId, ws: this.ws });
    if(!this.userId || !this.ws){ this._log('init warning: userId or ws missing, peers signaling will break'); }
  }

  async handleSignal(msg, mediaBinder){ return this._signaling.handle(msg, mediaBinder); }
  async startOffer(peerId){ return this._signaling.startOffer(peerId); }

  getOutputDeviceId(){ return this.outputDeviceId; }
  setPreferredDevices({ mic, cam, spk }){ if(mic) this.preferred.micId=mic; if(cam) this.preferred.camId=cam; if(spk) this.outputDeviceId=spk; for(const [,st] of this.peers){ this._safe(()=> st.handlers?.onSinkChange?.(this.outputDeviceId)); } }

  async toggleMic(){
    if(this.localStream){ const tr = this.localStream.getAudioTracks()[0]; if(!tr) return false; tr.enabled = !tr.enabled; return tr.enabled; }
    const s = await this._getLocalMedia(); if(!s) return false; this.localStream=s; if(this.localVideo) this.localVideo.srcObject=s; await this.updateAllPeerTracks(); return true;
  }
  async toggleCameraStream(){ return this._media.toggleCamera(this.preferred.camId); }
  async startCamera(){ const track = await this._media.startCamera(this.preferred.camId); if(track){ try{ this._videoStrategy?.onTrackStarted(track); }catch{} this._afterCameraStartForceNegotiation(); } return !!track; }
  async startScreenShare(){ const t = await this._media.startScreenShare(); return !!t; }
  stopCamera(){ this._media.stopCamera(); }
  stopScreenShare(){ this._media.stopScreenShare(); }
  stopVideo(){ this.stopCamera(); this.stopScreenShare(); }
  async toggleScreenShare(){ return this._media.toggleScreenShare(); }
  async switchCamera(deviceId){ return this._switchCamera(deviceId); }
  async switchScreenShareWindow(){ return this._switchScreenShareWindow(); }

  enableComposite(canvas){ return this._composite.enable(canvas); }
  disableComposite(){ return this._composite.disable(); }
  toggleComposite(canvas){ return this._composite.toggle(canvas); }

  async close(){ try{ this.ws?.close(); }catch{}; for(const [,st] of this.peers){ try{ st.pc.onicecandidate=null; st.pc.close(); }catch{}; if(st.level?.raf) cancelAnimationFrame(st.level.raf); clearTimeout(st.iceFailTimer); } this.peers.clear(); if(this.localStream) this.localStream.getTracks().forEach(t=> t.stop()); this.localStream=null; this._cameraTrack=null; this._screenTrack=null; this._cameraSender=null; this._screenSender=null; try{ this.disableComposite(); }catch{}; this._metrics.stopLoop(); try{ this.events.emit('session:closed',{}); this.events.clear(); }catch{} }
  async diagnoseAudio(){ const r = await this._diagnostics.diagnoseAudio(); try{ this.events.emit('diagnostics:audio', { result:r }); }catch{} return r; }
  async diagnoseVideo(){ const r = await this._diagnostics.diagnoseVideo(); try{ this.events.emit('diagnostics:video', { result:r }); }catch{} return r; }

  // Совместимость: привязка media handlers к уже созданному peer
  bindPeerMedia(peerId, handlers){ try { this._peers.bindPeerMedia(peerId, handlers); } catch(e){ this._log('bindPeerMedia error '+(e?.name||e)); } }

  // --- Internal helpers (портированы из старого класса, минимизированы) ---
  async _getLocalMedia(){
    const baseAudio = { echoCancellation:true, noiseSuppression:true, autoGainControl:true, deviceId: this.preferred.micId? { exact:this.preferred.micId }: undefined };
    try { const s = await navigator.mediaDevices.getUserMedia({ audio: baseAudio, video:false }); return s; } catch(e){ this._log('getUserMedia fail '+(e?.name||e)); return null; }
  }
  async _ensurePeer(peerId){
    const rec = await this._peers.ensurePeer(peerId, { onTrackCallback: (pid, stream)=>{ if(!this.peers.has(pid)) this.peers.set(pid, this._peers.get(pid)); const st = this.peers.get(pid); this._safe(()=> st.handlers?.onTrack?.(stream)); }});
    if(!this.peers.has(peerId)) this.peers.set(peerId, rec);
    if(this.localStream) this._addLocalTracks(rec.pc);
    this._ensureExistingVideoSenders();
    return rec;
  }
  async updateAllPeerTracks(){ if(!this.localStream) return; const at = this.localStream.getAudioTracks()[0]; if(!at) return; for(const [pid, st] of this.peers){ const sender = (st.audioTransceiver?.sender) || st.pc.getSenders().find(s=> s.track?.kind==='audio'); if(!sender) continue; try { await sender.replaceTrack(at); } catch{} } }
  _attachOrReplaceVideoSender(track){ try { for(const [pid, peer] of this.peers){ const senders = peer.pc.getSenders().filter(s=> s.track && s.track.kind==='video'); const type = track._wcType || (track.label.toLowerCase().includes('screen') ? 'screen':'camera'); let target = (type==='screen'? this._screenSender : this._cameraSender); if(target && !senders.includes(target)) target=null; if(!target){ let free = peer.pc.getSenders().find(s=> !s.track && s.transport); if(free){ free.replaceTrack(track).catch(()=>{}); target=free; try{ const trPromote = peer.pc.getTransceivers().find(t=> t.sender===free); if(trPromote && trPromote.direction==='recvonly'){ trPromote.direction='sendrecv'; } }catch{} } else { target = peer.pc.addTrack(track, this.localStream); } } else if(target.track !== track){ target.replaceTrack(track).catch(()=>{}); } if(type==='screen') this._screenSender=target; else this._cameraSender=target; this._ensureVideoFlow(pid, peer); this._peers.scheduleRemoteVideoWatchdog?.(pid, { hasLocalVideo:true }); } const firstPeer = this.peers.values().next().value; if(firstPeer){ this._videoSender = firstPeer.pc.getSenders().find(s=> s.track && s.track.kind==='video') || this._videoSender; } }catch{} }
  _attachOrReplaceVideoSender(track){ try { this._log(`[media] attachOrReplaceVideoSender kind=${track.kind} label="${track.label}" id=${track.id}`); for(const [pid, peer] of this.peers){ const senders = peer.pc.getSenders().filter(s=> s.track && s.track.kind==='video'); const type = track._wcType || (track.label.toLowerCase().includes('screen') ? 'screen':'camera'); let target = (type==='screen'? this._screenSender : this._cameraSender); if(target && !senders.includes(target)) target=null; if(!target){ let free = peer.pc.getSenders().find(s=> !s.track && s.transport); if(free){ this._log(`[media] reuse empty sender for ${pid.slice(0,6)} type=${type}`); free.replaceTrack(track).catch(()=>{}); target=free; try{ const trPromote = peer.pc.getTransceivers().find(t=> t.sender===free); if(trPromote && trPromote.direction==='recvonly'){ trPromote.direction='sendrecv'; this._log('[media] promote transceiver to sendrecv'); } }catch{} } else { this._log(`[media] addTrack() for ${pid.slice(0,6)} type=${type}`); target = peer.pc.addTrack(track, this.localStream); } } else if(target.track !== track){ this._log(`[media] replaceTrack on existing sender for ${pid.slice(0,6)} type=${type}`); target.replaceTrack(track).catch(()=>{}); } if(type==='screen') this._screenSender=target; else this._cameraSender=target; this._ensureVideoFlow(pid, peer); this._peers.scheduleRemoteVideoWatchdog?.(pid, { hasLocalVideo:true }); } const firstPeer = this.peers.values().next().value; if(firstPeer){ this._videoSender = firstPeer.pc.getSenders().find(s=> s.track && s.track.kind==='video') || this._videoSender; } }catch(e){ this._log('attachOrReplaceVideoSender error '+(e?.name||e)); } }
  _ensureVideoFlow(peerId, peerState){ setTimeout(()=>{ try { const pc = peerState.pc; const hasVideoSender = pc.getSenders().some(s=> s.track && s.track.kind==='video'); if(!hasVideoSender) return; const sdp = pc.localDescription?.sdp||''; const mVideoCount = (sdp.match(/\nm=video /g)||[]).length; const anyActive = pc.getTransceivers().some(t=> t.sender?.track?.kind==='video' && /send/.test(t.currentDirection||'')); if(hasVideoSender && !anyActive && mVideoCount===0 && pc.signalingState==='stable'){ pc.createOffer().then(of=> pc.setLocalDescription(of).then(()=> sendSignal(this.ws,'offer',{ sdp: of.sdp }, this.userId, peerId))).catch(()=>{}); } } catch{} },220); }
  _updateLocalPreview(){ if(!this.localVideo) return; if(!this.localStream){ this.localVideo.srcObject=null; try{ this.localVideo.load(); }catch{} return; } const showTrack = this._screenTrack || this._cameraTrack; if(!showTrack){ this.localVideo.srcObject = null; try{ this.localVideo.load(); }catch{} return; } const ms = new MediaStream([showTrack]); this.localVideo.srcObject = ms; }
  _ensureExistingVideoSenders(){ try { const tracks=[]; if(this._cameraTrack?.readyState==='live') tracks.push(this._cameraTrack); if(this._screenTrack?.readyState==='live') tracks.push(this._screenTrack); if(!tracks.length) return; tracks.forEach(t=> this._attachOrReplaceVideoSender(t)); } catch {} }
  _afterCameraStartForceNegotiation(){ setTimeout(()=>{ for(const [pid, st] of this.peers){ const pc = st.pc; if(pc.signalingState==='stable'){ const hasVideoSender = pc.getSenders().some(s=> s.track && s.track.kind==='video'); const need = hasVideoSender && !pc.getTransceivers().some(t=> t.sender?.track?.kind==='video' && /send/.test(t.currentDirection||'')); if(need){ pc.createOffer().then(of=> pc.setLocalDescription(of).then(()=> sendSignal(this.ws,'offer',{ sdp: of.sdp }, this.userId, pid))).catch(()=>{}); } } } },500); }
  async _switchCamera(deviceId){ this.preferred.camId=deviceId; if(this._currentVideoKind!=='camera') return false; try{ const gum = await navigator.mediaDevices.getUserMedia({ video:{ deviceId:{ exact:deviceId } }, audio:false }); const newTrack = gum.getVideoTracks()[0]; if(!newTrack) return false; const oldTracks = this.localStream?.getVideoTracks()||[]; if(!this.localStream) this.localStream = await this._getLocalMedia() || new MediaStream(); oldTracks.forEach(t=>{ try{ t.stop(); }catch{}; try{ this.localStream.removeTrack(t); }catch{} }); this.localStream.addTrack(newTrack); this._attachOrReplaceVideoSender(newTrack); if(this.localVideo) this.localVideo.srcObject = this.localStream; return true; } catch { return false; } }
  async _switchScreenShareWindow(){ if(!this._screenTrack) return false; try{ const ds = await navigator.mediaDevices.getDisplayMedia({ video:true, audio:false }); const newTrack = ds.getVideoTracks()[0]; if(!newTrack) return false; newTrack._wcType='screen'; const old = this._screenTrack; this._screenTrack = newTrack; if(this.localStream){ try{ if(old){ old.stop(); this.localStream.removeTrack(old); } }catch{} this.localStream.addTrack(newTrack); } this._attachOrReplaceVideoSender(newTrack); this._updateLocalPreview(); return true; } catch{ return false; } }
  _addLocalTracks(pc){ try { if(!this.localStream) return; const at = this.localStream.getAudioTracks()[0]; if(at){ const has = pc.getSenders().some(s=> s.track && s.track.kind==='audio'); if(!has) pc.addTrack(at, this.localStream); } } catch {}
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\js\webrtc_manager.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\password.html =====
--- SIZE: 3016 bytes ---

<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Смена пароля • WebCall 2.0</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      .pwd-grid{ display:grid; gap:24px; max-width:640px; margin:0 auto; }
      .inline-msg{ font-size:13px; }
      .form-section h2{ margin:0 0 12px; font-size:18px; }
      .actions-row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="container header-inner">
        <div class="brand">
          <span class="logo" aria-hidden>●</span>
          <span class="title">WebCall 2.0</span>
        </div>
        <nav class="actions">
          <div id="currentUserBadge" class="user-badge" style="display:none;">
            <span class="user-badge__icon">👤</span>
            <span class="user-badge__name" id="currentUsername"></span>
          </div>
          <button class="btn ghost theme-dot" id="btnToggleTheme" title="Тема" data-mode="auto">●</button>
          <a class="btn ghost" href="/">Главная</a>
          <a class="btn ghost" href="/static/profile.html">Профиль</a>
          <button class="btn ghost" id="btnLogout" title="Выход">Выйти</button>
        </nav>
      </div>
    </header>
    <main class="container app-main" style="padding-top:20px;">
      <div class="pwd-grid">
        <div class="card form-section">
          <h2>Смена пароля</h2>
          <form id="formPassword" novalidate class="form-grid" style="grid-template-columns:1fr;">
            <label class="row" style="flex-direction:column; align-items:stretch;">
              <span>Текущий пароль</span>
              <input id="old_password" name="old_password" type="password" autocomplete="current-password" />
            </label>
            <label class="row" style="flex-direction:column; align-items:stretch;">
              <span>Новый пароль</span>
              <input id="new_password" name="new_password" type="password" autocomplete="new-password" minlength="6" maxlength="128" />
            </label>
            <label class="row" style="flex-direction:column; align-items:stretch;">
              <span>Повторите новый пароль</span>
              <input id="new_password2" name="new_password2" type="password" autocomplete="new-password" minlength="6" maxlength="128" />
            </label>
            <div class="actions-row" style="margin-top:4px;">
              <button class="btn primary" type="submit" id="btnChangePwd">Изменить пароль</button>
              <span class="inline-msg" id="pwdMsg"></span>
            </div>
          </form>
        </div>
      </div>
    </main>
    <script type="module" src="/static/js/password.js"></script>
  </body>
</html>

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\password.html =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\profile.html =====
--- SIZE: 3127 bytes ---

<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Профиль • WebCall 2.0</title>
    <link rel="stylesheet" href="/static/styles.css" />
    <style>
      /* Локальная минимальная адаптация (если нужно) */
      .profile-grid{ display:grid; gap:24px; max-width:720px; margin:0 auto; }
      .inline-msg{ font-size:13px; }
      .form-section h2{ margin:0 0 12px; font-size:18px; }
      .actions-row{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
      .small-link{ font-size:13px; text-decoration:none; color:var(--primary); }
      .muted-note{ font-size:12px; color:var(--muted); margin-top:4px; }
    </style>
  </head>
  <body>
    <header class="app-header">
      <div class="container header-inner">
        <div class="brand">
          <span class="logo" aria-hidden>●</span>
          <span class="title">WebCall 2.0</span>
        </div>
        <nav class="actions">
          <div id="currentUserBadge" class="user-badge" style="display:none;">
            <span class="user-badge__icon">👤</span>
            <span class="user-badge__name" id="currentUsername"></span>
          </div>
          <button class="btn ghost theme-dot" id="btnToggleTheme" title="Тема" data-mode="auto">●</button>
          <a class="btn ghost" href="/">Главная</a>
          <a class="btn ghost" href="/static/password.html" title="Смена пароля">Пароль</a>
          <button class="btn ghost" id="btnLogout" title="Выход">Выйти</button>
        </nav>
      </div>
    </header>
    <main class="container app-main" style="padding-top:20px;">
      <div class="profile-grid">
        <div class="card form-section">
          <h2>Профиль</h2>
          <form id="formProfile" novalidate class="form-grid" style="grid-template-columns:1fr;">
            <label class="row" style="flex-direction:column; align-items:stretch;">
              <span>Email</span>
              <input id="email" name="email" type="email" autocomplete="email" />
            </label>
            <label class="row" style="flex-direction:column; align-items:stretch;">
              <span>Имя пользователя</span>
              <input id="username" name="username" type="text" autocomplete="username" minlength="3" maxlength="50" />
            </label>
            <div class="actions-row" style="margin-top:4px;">
              <button class="btn primary" type="submit" id="btnSaveProfile">Сохранить</button>
              <span class="inline-msg" id="profileMsg"></span>
            </div>
          </form>
          <div class="muted-note">После изменения имени может потребоваться обновить страницу для обновления бейджа пользователя.</div>
        </div>
      </div>
    </main>
    <script type="module" src="/static/js/profile.js"></script>
  </body>
</html>

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\profile.html =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\styles.css =====
--- SIZE: 39007 bytes ---

/* ======= THEME TOKENS ======= */
:root{
  --bg:#060913;
  --surface:#0a1020;
  --card:#0b1220;
  --text:#e6f0ff;
  --muted:#9aa3b2;

  --primary:#7c3aed;   /* violet */
  --primary-2:#06b6d4; /* cyan */
  --success:#22c55e;
  --danger:#ef4444;
  --warning:#f59e0b;

  --border:#1a2236;
  --radius:14px;
  --ring:rgba(124,58,237,0.35);
  --ring-2:rgba(6,182,212,0.25);

  --shadow-lg: 0 20px 60px rgba(0,0,0,.45);
  --shadow-md: 0 10px 40px rgba(0,0,0,.30);
  --shadow-sm: 0 6px 24px rgba(0,0,0,.2);

  --grad: linear-gradient(100deg,var(--primary),var(--primary-2));
  --grad-soft: linear-gradient(160deg,rgba(124,58,237,.18),rgba(6,182,212,.14));
}

/* Dark mode tokens (если у вас есть переключатель темы – логика уже в JS) */
body.dark{
  /* Зелёно-чёрная неоновая тема */
  --bg:#040907;            /* почти чёрный с зелёным подтоном */
  --surface:#06120d;       /* тёмная поверхность */
  --card:#082017;          /* карточки чуть светлее */
  --text:#e3fcef;          /* мягкий зеленоватый белый */
  --muted:#8aa99a;         /* приглушённый серо-зелёный */
  --primary:#10b981;       /* зелёный (tailwind emerald 500) */
  --primary-2:#34d399;     /* более светлый акцент */
  --border:#123a2b;        /* зеленоватая граница */
  --ring:rgba(16,185,129,0.50);
  --ring-2:rgba(52,211,153,0.30);
  --grad: linear-gradient(110deg,#10b981,#34d399);
  --grad-soft: linear-gradient(160deg,rgba(16,185,129,.18),rgba(52,211,153,.14));
  /* Фоновая подсветка перекрашивается зелёной гаммой */
  background:
    radial-gradient(1100px 520px at 12% -8%, rgba(16,185,129,0.18), transparent),
    radial-gradient(900px 520px at 100% 12%, rgba(52,211,153,0.14), transparent),
    linear-gradient(180deg,#04120c 0%,#061c14 100%);
}

/* Red theme: более радикальная цветовая палитра с красными оттенками */
/* theme-red удалён из активного цикла переключения; блок стилизатора убран */
body.theme-red{
  --bg:#1a0507;
  --surface:#25080c;
  --card:#2d0c10;
  --text:#ffecec;
  --muted:#f19999;
  --primary:#ff3b30;
  --primary-2:#ff7a45;
  --success:#22c55e;
  --danger:#ff4242;
  --warning:#ff9800;
  --border:#3a1116;
  --ring:rgba(255,59,48,0.45);
  --ring-2:rgba(255,122,69,0.30);
  --grad: linear-gradient(120deg,#ff3b30,#ff7a45);
  --grad-soft: linear-gradient(160deg,rgba(255,59,48,.18),rgba(255,122,69,.14));
  background:
    radial-gradient(1200px 600px at 10% -10%, rgba(255,59,48,0.25), transparent),
    radial-gradient(1000px 600px at 100% 10%, rgba(255,122,69,0.20), transparent),
    linear-gradient(180deg,#1a0507 0%,#2d0c10 100%);
}

/* ======= GLOBAL ======= */
html,body{height:100%}
*{box-sizing:border-box}
body{
  margin:0;
  font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--text);
  background:
    radial-gradient(1200px 600px at 10% -10%, rgba(124,58,237,0.20), transparent),
    radial-gradient(1000px 600px at 100% 10%, rgba(6,182,212,0.15), transparent),
    linear-gradient(180deg,#070a14 0%,#0b1220 100%);
  accent-color: var(--primary);
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
  padding-bottom: env(safe-area-inset-bottom, 0); /* Safe area support */
}

/* Мягкая диффузная подсветка фоном при скролле */
body::before{
  content:"";
  position:fixed; inset:-20%;
  background:radial-gradient(60% 40% at 20% 0%, rgba(124,58,237,.10), transparent 60%),
             radial-gradient(60% 40% at 80% 10%, rgba(6,182,212,.08), transparent 60%);
  filter: blur(40px);
  z-index:-1;
  pointer-events:none;
}

/* Futuristic spiderweb canvas */
#fx-web-canvas{z-index:0;}
body,html{background-attachment:fixed}

/* ======= PERMISSIONS BANNER ======= */
#permBanner{display:none;margin-bottom:12px;display:none}
#permBanner .warn{
  background:rgba(255,176,0,0.10);
  border:1px solid color-mix(in srgb, var(--warning) 60%, transparent);
  padding:8px 12px;
  border-radius:10px;
  font-size:13px;
  line-height:1.35;
  display:flex;
  gap:6px;
  align-items:flex-start;
  position:relative;
}
#permBanner .warn::before{
  content:"!";
  font-weight:600;
  color:var(--warning);
  width:18px;height:18px;
  display:inline-flex;align-items:center;justify-content:center;
  background:rgba(255,176,0,0.15);
  border-radius:6px;
  font-size:12px;
}

/* Адаптация для prefers-reduced-motion */
@media (prefers-reduced-motion: reduce){
  *{animation:none !important; transition:none !important}
}

/* Контейнер */
.container{max-width:1200px;margin:0 auto;padding:16px}

/* ======= HEADER ======= */
.app-header{
  position:sticky; top:0; z-index:10;
  backdrop-filter: blur(10px);
  background: color-mix(in srgb, var(--surface) 65%, transparent);
  border-bottom:1px solid var(--border);
}
.header-inner{display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;align-items:center;gap:10px}
.logo{
  display:inline-grid;place-items:center;
  width:26px;height:26px;border-radius:50%;
  background: conic-gradient(from 180deg,var(--primary),var(--primary-2),var(--primary));
  box-shadow: 0 0 24px rgba(124,58,237,.5), inset 0 0 18px rgba(255,255,255,.08);
  animation: spin-slow 14s linear infinite;
}
@keyframes spin-slow { to { transform: rotate(360deg) } }
.title{font-weight:800;letter-spacing:.4px}

/* ===== USER BADGE ===== */
.actions{display:flex;align-items:center;gap:10px}
.user-badge{
  --ub-bg: linear-gradient(160deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 10px 6px 8px;
  border-radius: 40px;
  font-size:13px; font-weight:500;
  background: var(--ub-bg);
  border:1px solid color-mix(in srgb, var(--border) 70%, var(--primary) 30%);
  position:relative;
  line-height:1.1;
  box-shadow: 0 4px 14px rgba(0,0,0,.30), inset 0 0 0 1px rgba(255,255,255,.05);
  backdrop-filter: blur(6px) saturate(140%);
  -webkit-backdrop-filter: blur(6px) saturate(140%);
  letter-spacing:.2px;
  animation: badge-in .35s cubic-bezier(.32,1.4,.32,1);
}
@keyframes badge-in { from { opacity:0; transform: translateY(-4px) scale(.92); } to { opacity:1; transform:none; } }
.user-badge__icon{ font-size:15px; filter: drop-shadow(0 0 6px rgba(124,58,237,.55)); }
.user-badge__name{ max-width:140px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
@media (max-width:640px){ .user-badge__name{ max-width:90px } }

/* ======= LAYOUT ======= */
.app-main{display:flex;flex-direction:column;gap:16px}
.panel{background:transparent;border-radius:var(--radius)}
.grid-2{display:grid;grid-template-columns:1fr 1fr;gap:16px}
/* Utility span for full row */
.span-2{grid-column:1/-1}
/* Выравнивание высоты локального и удалённых контейнеров */
#remoteContainer{display:flex;flex-direction:column}
#remoteContainer .peers-grid{flex:1 1 auto}
@media(max-width:960px){.grid-2{grid-template-columns:1fr}}

/* ======= CARD (стеклянная карта с переливом) ======= */
.card{
  position:relative;
  background: linear-gradient(180deg, rgba(255,255,255,.035), rgba(255,255,255,.015));
  border:1px solid var(--border);
  border-radius:var(--radius);
  padding:16px;
  box-shadow: var(--shadow-md);
  transition: transform .25s ease, box-shadow .25s ease, border-color .25s ease;
}
.card:hover{
  transform: translateY(-2px);
  box-shadow: var(--shadow-lg);
  border-color: color-mix(in srgb, var(--border) 70%, var(--primary) 30%);
}
/* Градиентная окантовка (тонкая) */
.card::before{
  content:"";
  position:absolute; inset:0; border-radius:inherit; pointer-events:none;
  padding:1px;
  background: linear-gradient(140deg, rgba(124,58,237,.45), rgba(6,182,212,.35));
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor; mask-composite: exclude;
}

/* Заголовки карт */
.card h2{margin:0 0 12px 0;font-size:18px;letter-spacing:.2px}

/* ======= FORMS ======= */
.row{display:flex;gap:8px;align-items:center}
label{display:flex;flex-direction:column;gap:6px;font-size:14px;color:var(--muted)}
input, .sel, select{
  background: var(--card);
  border:1px solid var(--border);
  color:var(--text);
  padding:10px 12px;
  border-radius:10px;
  outline:none;
  transition: border-color .2s ease, box-shadow .2s ease, transform .05s ease;
}
input:focus, .sel:focus, select:focus{
  border-color:transparent;
  box-shadow: 0 0 0 .22rem var(--ring), 0 0 0 .44rem var(--ring-2);
}
input:active{ transform: scale(.995) }

.sel, select{
  appearance:none;
  padding-right:36px;
  background-image: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)),
    url("data:image/svg+xml,%3Csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M6 8l4 4 4-4' stroke='%23a7b0c2' stroke-width='1.8' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat:no-repeat, no-repeat;
  background-position: center left, right 10px center;
  background-size: 100% 100%, 20px 20px;
}

/* Сетка формы */
.form-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
.form-grid .row{grid-column:1/-1;display:flex;gap:8px;flex-wrap:wrap}
.form-grid .col{display:flex;gap:8px;flex-wrap:wrap;justify-content:space-between}
@media(max-width:640px){ .form-grid{grid-template-columns:1fr} }

/* ======= BUTTONS ======= */
.btn{
  --btn-bg:#0f172a;
  display:inline-flex;align-items:center;justify-content:center;
  padding:10px 14px;border-radius:12px;
  border:1px solid var(--border); background:var(--btn-bg); color:var(--text);
  font-size:14px; line-height:1;
  cursor:pointer; user-select:none;
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
  position:relative; overflow:hidden;
}
.btn::after{ /* блик */
  content:""; position:absolute; inset:-1px; pointer-events:none;
  background: linear-gradient(120deg, rgba(255,255,255,.12), transparent 40%, transparent 60%, rgba(255,255,255,.10));
  transform: translateX(-100%);
  transition: transform .6s ease;
}
.btn:hover::after{ transform: translateX(0) }

/* Fullscreen button */
.btn-fullscreen {
  font-size: 11px;
  padding: 2px 6px;
  line-height: 1.2;
  background: var(--panel-bg,#1b1f25);
  border: 1px solid var(--border-color,#333);
  color: var(--fg,#ddd);
  cursor: pointer;
  border-radius: 4px;
}
.btn-fullscreen:hover {
  background: var(--accent,#1fa060);
  color:#fff;
  border-color: var(--accent,#1fa060);
}
.fullscreen-active video {
  outline: 3px solid var(--accent,#1fa060);
}

.btn:hover{ border-color:#2a3347; box-shadow:0 0 0 .35rem rgba(124,58,237,0.10) }
.btn:active{ transform: translateY(1px) scale(.99) }
.btn:disabled{opacity:.6;cursor:not-allowed}

.btn.btn-success{
  background: linear-gradient(160deg, color-mix(in srgb, var(--success) 85%, transparent) 0%, color-mix(in srgb, var(--success) 55%, transparent) 100%);
  border-color: color-mix(in srgb, var(--success) 80%, transparent);
  color: #042010;
  box-shadow: 0 8px 26px color-mix(in srgb, var(--success) 55%, transparent);
}
.btn.btn-success:hover{
  border-color: color-mix(in srgb, var(--success) 90%, transparent);
  box-shadow: 0 12px 34px color-mix(in srgb, var(--success) 65%, transparent);
}
.btn.btn-secondary{
  background: color-mix(in srgb, rgba(255,255,255,0.08) 60%, var(--surface));
  border-color: color-mix(in srgb, rgba(255,255,255,0.18) 60%, transparent);
  color: var(--text);
}
.btn.btn-secondary:hover{
  background: color-mix(in srgb, rgba(255,255,255,0.12) 70%, var(--surface));
  border-color: color-mix(in srgb, rgba(255,255,255,0.25) 70%, transparent);
}
.btn.ghost{ background: transparent; border-color: transparent }
.btn.ghost:hover{ background: rgba(255,255,255,0.08) }
.btn.btn-ghost{ background: transparent; border-color: transparent; }
.btn.btn-ghost:hover{ background: rgba(255,255,255,0.08); }

.btn.primary{
  border-color: transparent;
  background: var(--grad);
  box-shadow: 0 8px 28px rgba(124,58,237,.25);
}
.btn.primary:hover{ box-shadow: 0 10px 36px rgba(124,58,237,.35) }

/* Активное состояние для кнопок камеры/экрана */
.btn.btn-media-active{
  border-color: var(--primary);
  background: linear-gradient(160deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
  box-shadow: 0 0 0 .25rem rgba(124,58,237,0.18), inset 0 0 0 1px rgba(255,255,255,.06);
  position: relative;
}
.btn.btn-media-active::before{
  content: "●";
  position:absolute;top:4px;right:6px;font-size:10px;line-height:1;color:var(--primary-2);
  filter: drop-shadow(0 0 4px color-mix(in srgb, var(--primary) 60%, transparent));
}

/* ===== CALL UI ===== */
.call-banner{
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 14px;
  border-radius:12px;
  border:1px solid color-mix(in srgb, var(--border) 70%, rgba(255,255,255,0.08));
  background: color-mix(in srgb, rgba(124,58,237,0.12) 55%, var(--surface));
  box-shadow: 0 14px 34px rgba(0,0,0,.24);
  font-size:13px;
  font-weight:500;
  letter-spacing:.2px;
  transition: border-color .2s ease, box-shadow .2s ease;
}
.call-banner[data-phase="active"]{
  border-color: color-mix(in srgb, var(--success) 40%, transparent);
  box-shadow: 0 16px 36px color-mix(in srgb, var(--success) 28%, transparent);
}
.call-banner[data-phase="ended"]{
  border-color: color-mix(in srgb, var(--warning) 45%, transparent);
  box-shadow: 0 16px 36px color-mix(in srgb, var(--warning) 22%, transparent);
}
.call-banner__icon{ font-size:16px; }
.call-banner__text{ flex:1 1 auto; }

.call-modal{
  position:fixed;
  inset:0;
  z-index:12000;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:24px;
  background: color-mix(in srgb, rgba(4,9,19,0.78) 80%, transparent);
  backdrop-filter: blur(16px);
}
.call-modal.is-hidden{ display:none; }
.call-modal__body{
  width:min(340px, 92vw);
  padding:26px 28px 24px;
  border-radius:18px;
  background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.015));
  border:1px solid color-mix(in srgb, var(--border) 70%, rgba(255,255,255,0.1));
  box-shadow: var(--shadow-lg);
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:14px;
  text-align:center;
}
.call-modal__avatar{
  width:76px;
  height:76px;
  border-radius:50%;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  box-shadow: 0 14px 38px rgba(0,0,0,.35);
  background: var(--grad);
}
.call-modal__avatar--outgoing{ background: linear-gradient(150deg, rgba(6,182,212,.55), rgba(124,58,237,.55)); }
.call-modal__avatar-icon{ font-size:30px; }
.call-modal__title{ font-size:17px; font-weight:600; letter-spacing:.25px; }
.call-modal__name{ font-size:15px; font-weight:500; opacity:.9; margin:0; }
.call-modal__status{ font-size:13px; color: var(--muted); margin:0; }
.call-modal__actions{ display:flex; gap:12px; width:100%; justify-content:center; }
.call-modal__actions--single .btn{ width:100%; }

@media (max-width:480px){
  .call-modal__body{ width:100%; border-radius:16px; padding:24px 22px; }
}

.btn.success{ background: linear-gradient(100deg, var(--success), #16a34a); border-color:transparent }
.btn.danger{ background: linear-gradient(100deg, var(--danger), #dc2626); border-color:transparent }

/* Chat unread badge (используем ::before, чтобы не конфликтовать с .btn::after подсветкой) */
.btn.chat-btn.has-unread{
  /* Чуть увеличим правый верхний отступ, чтобы кружок не накладывался на текст */
  padding-right: 16px;
  padding-top: 14px;
}
.btn.chat-btn.has-unread::before{
  content: "";
  position: absolute;
  top: 2px; right: 2px; /* В самый угол */
  width: 12px; height: 12px;
  background: var(--danger);
  border-radius: 50%;
  box-shadow: 0 0 0 2px var(--bg), 0 0 6px rgba(239,68,68,.8);
  pointer-events: none;
  /* Если захотим показывать число: заменить content: attr(data-unread); и добавить стили ниже */
}

/* XS вариант, если понадобится */
.btn.xs{padding:6px 10px;font-size:12px;border-radius:8px}

/* ======= VIDEO ======= */
.video-wrap{
  position:relative; aspect-ratio:16/9; background:#000;
  border-radius:12px; overflow:hidden; border:1px solid var(--border);
  box-shadow: var(--shadow-sm);
}
video{width:100%;height:100%;object-fit:cover;display:block}

/* PiP overlay для локального и удалённого отображения (камера поверх экрана) */
.video-wrap .pip, .video-stack .pip{
  position:absolute; right:8px; bottom:8px; width:26%; aspect-ratio:16/9; border:1px solid var(--border);
  border-radius:10px; overflow:hidden; box-shadow:0 6px 20px rgba(0,0,0,.55), 0 0 0 .25rem rgba(0,0,0,.35);
  background:#000; z-index:6;
}
.video-wrap .pip video, .video-stack .pip video{ width:100%; height:100%; object-fit:cover; }

/* Стек для двух видео элементов удалённого участника */
.video-stack{ position:relative; width:100%; height:100%; }
.video-stack .peer-main{ width:100%; height:100%; object-fit:cover; }

/* Кнопки внутри локального превью */
.local-video-controls .btn.xs, .local-video-controls .btn.xs.ghost{
  padding:4px 8px; font-size:11px; border-radius:8px; background:rgba(0,0,0,.45); backdrop-filter:blur(6px); border:1px solid rgba(255,255,255,.15);
}
.local-video-controls .btn.xs:hover{ background:rgba(0,0,0,.65); }

/* Мини-индикатор шаринга экрана */
.share-badge{
  position:absolute; left:8px; top:8px; z-index:5;
  background: linear-gradient(140deg, rgba(16,185,129,.20), rgba(16,185,129,.08));
  color: var(--text);
  font-size:12px; font-weight:600; letter-spacing:.3px;
  padding:6px 10px; border-radius:20px;
  border:1px solid color-mix(in srgb, var(--primary) 60%, var(--border));
  display:inline-flex; align-items:center; gap:6px;
  box-shadow: 0 4px 18px rgba(0,0,0,.45), 0 0 0 .35rem rgba(16,185,129,0.18);
  backdrop-filter: blur(6px) saturate(140%);
  -webkit-backdrop-filter: blur(6px) saturate(140%);
  animation: badge-pop .35s cubic-bezier(.32,1.4,.32,1);
}
body.theme-red .share-badge{ background: linear-gradient(140deg, rgba(255,59,48,.25), rgba(255,59,48,.10)); box-shadow:0 4px 18px rgba(0,0,0,.45), 0 0 0 .35rem rgba(255,59,48,0.22); }
@keyframes badge-pop { from { opacity:0; transform: translateY(-4px) scale(.92); } to { opacity:1; transform:none; } }

/* ======= PEERS GRID ======= */
.peers-grid{
  display:grid; grid-template-columns:repeat(auto-fill,minmax(280px,1fr));
  gap:16px;
}

/* ===== Single peer (full focus) ===== */
.peers-grid.layout-single-peer{
  /* Отключаем авто-fill сетку и даём одну колонку на всю ширину */
  display:grid;
  grid-template-columns:1fr !important;
  gap:20px;
  align-items:center;
  justify-content:center;
}
.tile.single-peer{
  width:100%;
  max-width:760px; /* уменьшили стартовый рабочий размер */
  margin:0 auto;
  box-shadow:0 0 0 .25rem rgba(124,58,237,0.08), 0 10px 34px -6px rgba(0,0,0,.55);
  border-color:color-mix(in srgb, var(--primary) 40%, var(--border));
  transition:box-shadow .30s ease, border-color .30s ease, transform .30s ease, max-width .35s ease;
}
/* Ещё более компактный начальный вид до появления первых кадров */
.tile.single-peer.initial-small{ max-width:480px; }
.tile.single-peer:hover{ transform:translateY(-2px); }
.tile.single-peer .media{
  aspect-ratio:16/9; /* Стабильное отношение */
  height:auto;
  background:#000;
}
/* Расширенный режим (кнопка «Развернуть») */
.tile.single-peer.single-peer-expanded{ max-width:none; width:100%; }
.tile.single-peer.single-peer-expanded .media{ aspect-ratio:auto; height:clamp(360px, 78vh, 1000px); }
.tile.single-peer.single-peer-expanded{ box-shadow:0 0 0 .42rem rgba(6,182,212,0.18), 0 20px 60px -6px rgba(0,0,0,.65); }
.tile.single-peer .media .video-stack .peer-main,
.tile.single-peer .media video.peer-main{
  object-fit:cover; /* Заполняем полностью, допускаем обрезку краёв */
  background:#000;
}
.tile.single-peer .pip{
  width:22%;
  max-width:320px;
  box-shadow:0 6px 26px rgba(0,0,0,.65), 0 0 0 .25rem rgba(0,0,0,.35);
}
@media (max-width:900px){
  .tile.single-peer{ max-width:880px; }
  .tile.single-peer.single-peer-expanded .media{ height:clamp(300px, 72vh, 900px); }
  .tile.single-peer .pip{ width:28%; }
}
@media (max-width:640px){
  .tile.single-peer{ max-width:100%; }
  .tile.single-peer .pip{ width:32%; }
  .tile.single-peer.single-peer-expanded .media{ height:clamp(260px, 70vh, 820px); }
}
@media (orientation:portrait) and (min-height:900px){
  .tile.single-peer.single-peer-expanded .media{ height:clamp(420px, 80vh, 1100px); }
}


/* ======= TILE (плитка участника) ======= */
.tile{
  position:relative; border-radius:12px; overflow:hidden;
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
  border:1px solid var(--border);
  animation: tile-in .28s ease both;
  transition: transform .18s ease, box-shadow .18s ease, border-color .2s ease;
}
.tile:hover{
  transform: translateY(-2px);
  box-shadow: 0 0 0 .28rem rgba(6,182,212,.09) inset, var(--shadow-md);
}
@keyframes tile-in{ from{ opacity:0; transform:translateY(6px) } to{ opacity:1; transform:none } }

.tile .media{ aspect-ratio:16/10; background:#0b1220 }
.tile .media video{ width:100%; height:100%; object-fit:cover; }
.tile .hud{
  position:absolute; left:0; right:0; bottom:0;
  padding:10px 10px 12px;
  background: linear-gradient(0deg, rgba(0,0,0,.75), transparent 70%);
  display:flex; flex-direction:column; gap:8px;
}
.tile .hud .name{ font-weight:600; font-size:14px; text-shadow:0 1px 2px rgba(0,0,0,.6) }
.tile .hud .level{
  height:6px; background:rgba(255,255,255,.12);
  border-radius:4px; overflow:hidden;
  border:1px solid rgba(255,255,255,.08);
}
.tile .hud .level-bar{
  width:100%; height:100%;
  background: linear-gradient(90deg, var(--primary-2), var(--primary));
  transform-origin:left; transform: scaleX(0);
  transition: transform .09s linear;
  box-shadow: 0 0 12px rgba(6,182,212,.35);
}

/* Сетевой статус рамкой (из вашей логики data-net) */
.tile[data-net="connecting"]{ border-color: var(--warning) }
.tile[data-net="connected"]{ border-color: var(--success) }
.tile[data-net="failed"]{ border-color: var(--danger) }

/* ======= RANGE (громкость) ======= */
input[type="range"]{
  -webkit-appearance:none; appearance:none; width:120px; height:24px; background:transparent;
}
input[type="range"]::-webkit-slider-runnable-track{
  height:6px; background:rgba(255,255,255,.18);
  border-radius:6px; border:1px solid rgba(255,255,255,.08);
}
input[type="range"]::-moz-range-track{
  height:6px; background:rgba(255,255,255,.18);
  border-radius:6px; border:1px solid rgba(255,255,255,.08);
}
input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance:none; appearance:none;
  width:18px; height:18px; border-radius:50%;
  margin-top:-7px;
  background: var(--grad);
  border:0; box-shadow: 0 4px 14px rgba(124,58,237,.35);
  transition: transform .12s ease;
}
input[type="range"]::-webkit-slider-thumb:hover{ transform: scale(1.06) }
input[type="range"]::-moz-range-thumb{
  width:18px; height:18px; border:0; border-radius:50%;
  background: var(--grad);
  box-shadow: 0 4px 14px rgba(124,58,237,.35);
}

/* ======= CHAT ======= */
.chat-box{
  height:180px; overflow-y:auto;
  border:1px solid var(--border); border-radius:10px;
  padding:10px; margin-bottom:8px; font-size:14px;
  background: linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01));
  box-shadow: inset 0 1px 0 rgba(255,255,255,.03);
}

  /* ======= MOBILE ADAPTATIONS ======= */
  @media (max-width: 760px){
    .grid-2{grid-template-columns:1fr !important}
    .app-main{gap:12px}
    .card{padding:14px}
    .btn{padding:12px 16px;font-size:15px;border-radius:14px}
    input, .sel, select{padding:12px 14px;font-size:15px}
    #friendsCard .list-item, #visitedRooms .list-item{padding:10px 8px}
    #directMessages, #chat{height:auto;max-height:38vh}
    .chat-box{font-size:14px;line-height:1.35}
    .tile video{max-height:32vh}
    .peers-grid{grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:8px}
    body{font-size:15px}
    .app-header .actions .btn{padding:8px 10px}
  }

  @media (max-width:480px){
    #directMessages, #chat{max-height:44vh}
    .btn{font-size:14px;padding:11px 14px}
    input, .sel, select{font-size:14px}
  }
.chat-input{ display:flex; gap:8px }
.chat-input input{
  flex:1;
}
/* Chat lines (bubbles) */
.chat-line{display:flex;flex-direction:column;max-width:80%;margin:4px 0;animation:fade-in .18s ease}
.chat-line .who{font-size:11px;letter-spacing:.3px;opacity:.75;margin:0 4px 3px 4px}
.chat-line .bubble{padding:10px 12px;border-radius:14px;font-size:14px;line-height:1.35;white-space:pre-wrap;word-break:break-word;position:relative;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.03));border:1px solid var(--border);box-shadow:0 4px 14px rgba(0,0,0,.25)}
.chat-line.self{margin-left:auto;align-items:flex-end}
.chat-line.self .bubble{background:var(--grad);color:#fff;border-color:transparent;box-shadow:0 4px 18px rgba(124,58,237,.45)}
.chat-line.other{align-items:flex-start}
.chat-line.other .bubble{background:linear-gradient(160deg,rgba(255,255,255,.08),rgba(255,255,255,.04));}
@keyframes fade-in{from{opacity:0;transform:translateY(4px)}to{opacity:1;transform:none}}

/* ======= BUTTONS GRID (2x3) ======= */
.controls-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;align-items:stretch}
.controls-grid .btn{width:100%}
@media(max-width:640px){.controls-grid{grid-template-columns:repeat(auto-fill,minmax(120px,1fr))}}

/* ======= LOGS ======= */
.logs{
  min-height:120px; max-height:240px; overflow:auto;
  background: #0b1220;
  border:1px solid var(--border);
  border-radius:10px; padding:8px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  font-size:13px; color:#cbd5e1;
}
.log-line{ display:flex; gap:8px }
.log-line .time{ color:#7dd3fc }
.log-line .msg{ flex:1; white-space:pre-wrap; word-break:break-word }

/* ======= SIMPLE LIST ======= */
.list{ display:flex; flex-direction:column; gap:8px }
.list-item{ display:flex; gap:12px; align-items:center; padding:10px; border:1px solid var(--border); border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.01)); flex-wrap:wrap }
.list-item .grow{ flex:1; min-width:0 }
.list-item-actions{ display:flex; gap:8px; flex-wrap:wrap }

/* Кнопка переключения темы в виде цветной точки */
#btnToggleTheme.theme-dot{ width:30px; height:30px; padding:0; font-size:20px; line-height:1; border-radius:50%; background:var(--card); border:1px solid var(--border); color:var(--primary); text-shadow:0 0 8px color-mix(in srgb, var(--primary) 65%, transparent); box-shadow:0 2px 8px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.05); display:inline-flex; align-items:center; justify-content:center; }
#btnToggleTheme.theme-dot:hover{ background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); }
body.dark #btnToggleTheme.theme-dot{ color:var(--primary); text-shadow:0 0 10px rgba(16,185,129,.6) }
body.theme-red #btnToggleTheme.theme-dot{ color:var(--primary); text-shadow:0 0 10px rgba(255,59,48,.65) }

/* Мобильный фикс перекрытия кнопки "Позвонить" и email в списке друзей */
@media (max-width:520px){
  #friendsCard .list-item{ flex-direction:column; align-items:stretch; }
  #friendsCard .list-item .grow{ width:100%; }
  #friendsCard .list-item .list-item-actions{ width:100%; justify-content:flex-start; }
  #friendsCard .list-item .list-item-actions .btn{ flex:1 1 auto; min-width:110px; }
  #friendsCard .list-item .muted.small{ word-break:break-word; }
}
.bold{ font-weight:600 }
.small{ font-size:12px }
.muted{ color: var(--muted) }

/* ======= FRIEND STATUS DOT ======= */
.status-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;vertical-align:middle;box-shadow:0 0 0 2px rgba(0,0,0,.35),0 0 6px rgba(0,0,0,.4);background:#666;position:relative;top:-1px}
.status-dot.online{background:#10b981;box-shadow:0 0 0 2px rgba(0,0,0,.3),0 0 0 4px rgba(16,185,129,0.15),0 0 8px rgba(16,185,129,.8)}
.status-dot.offline{background:#555;opacity:.65}

/* ======= LOCAL VIDEO CARD ======= */
.video-card .video-wrap{ background:#000 }
.video-card .video-wrap::after{
  content:""; position:absolute; inset:0; pointer-events:none;
  background: linear-gradient(0deg, rgba(0,0,0,.55), transparent 60%);
}

/* ======= SCROLLBARS ======= */
.chat-box::-webkit-scrollbar,
.logs::-webkit-scrollbar,
.peers-grid::-webkit-scrollbar{ width:10px; height:10px }
.chat-box::-webkit-scrollbar-thumb,
.logs::-webkit-scrollbar-thumb,
.peers-grid::-webkit-scrollbar-thumb{
  background: linear-gradient(180deg, rgba(255,255,255,.25), rgba(255,255,255,.12));
  border-radius:10px; border:2px solid transparent; background-clip:content-box;
}

/* ======= ACCESSIBILITY ======= */
:focus-visible{
  outline: none;
  box-shadow: 0 0 0 .22rem var(--ring), 0 0 0 .44rem var(--ring-2);
  border-radius: 12px;
}

/* ======= AUTH FIELD ERRORS ======= */
.input-error { border-color: var(--danger) !important; outline:1px solid var(--danger); }
.input-error:focus { box-shadow: 0 0 0 .22rem rgba(239,68,68,0.35), 0 0 0 .44rem rgba(239,68,68,0.18) !important; }

/* ======= IN-CALL LAYOUT ======= */
.app-in-call{ display:block; }
@media (max-width: 720px){
  .controls-grid{ grid-template-columns:repeat(2,1fr); }
  .peers-grid{ grid-template-columns:repeat(auto-fill,minmax(220px,1fr)); }
  .chat-box{ height: 160px; }
}
@media (min-width: 1280px){
  .chat-box{ height: 220px; }
}

@media (max-width: 760px){
  .chat-input{flex-wrap:wrap}
  .chat-input .btn{width:100%}
}

/* ======= INCOMING CALL MODAL ======= */
.wc-modal{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; z-index:200; }
.wc-modal-backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.55); backdrop-filter: blur(6px); }
.wc-modal-dialog{
  position:relative; z-index:1; width:clamp(280px, 90vw, 420px);
  background: linear-gradient(160deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  border:1px solid var(--border);
  border-radius: 22px; padding:28px 26px 24px;
  box-shadow: 0 18px 60px rgba(0,0,0,.55), 0 0 0 .5rem rgba(124,58,237,.10);
  animation: wc-modal-in .32s cubic-bezier(.32,1.4,.32,1) both;
}
@keyframes wc-modal-in { from { opacity:0; transform:translateY(18px) scale(.96);} to { opacity:1; transform:none;} }
.wc-modal-body{ display:flex; gap:18px; align-items:center; margin-bottom:22px; }
.wc-modal-icon{ font-size:44px; filter: drop-shadow(0 4px 14px rgba(124,58,237,.45)); }
.wc-modal-text{ display:flex; flex-direction:column; gap:6px; }
.wc-modal-title{ font-size:18px; font-weight:700; letter-spacing:.3px; }
.wc-modal-sub{ font-size:14px; color:var(--muted); }
.wc-modal-actions{ display:flex; gap:14px; justify-content:flex-end; }
.wc-modal-actions .btn{ flex:1; font-size:15px; padding:14px 16px; }
@media (max-width:520px){
  .wc-modal-dialog{ padding:22px 20px 20px; border-radius:18px; }
  .wc-modal-icon{ font-size:38px; }
  .wc-modal-actions{ flex-direction:column; }
}

/* Swipe подсказки */
.wc-modal-actions .btn{
  position:relative;
  will-change: transform, opacity;
}
.wc-modal-actions .btn.swipe-armed{
  box-shadow: 0 0 0 .25rem rgba(255,255,255,.06), 0 0 0 .55rem rgba(124,58,237,.18);
  outline:1px solid color-mix(in srgb, var(--primary) 55%, transparent);
}
.wc-modal-actions .btn.swipe-armed::before{
  content:""; position:absolute; inset:0; pointer-events:none;
  background:linear-gradient(120deg, rgba(124,58,237,.35), rgba(6,182,212,.30));
  mix-blend-mode:overlay; opacity:.55; border-radius:inherit;
  animation: swipe-pulse 1s ease-in-out infinite alternate;
}
@keyframes swipe-pulse { from { opacity:.35; } to { opacity:.75; } }

/* ======= TOASTS ======= */
.wc-toast{
  min-width: 220px;
  max-width: 360px;
  background: linear-gradient(160deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
  border:1px solid var(--border);
  color: var(--text);
  font-size: 14px;
  padding:12px 14px;
  border-radius:14px;
  box-shadow: var(--shadow-md), 0 0 0 .35rem rgba(124,58,237,0.08);
  position:relative;
  animation: toast-in .35s cubic-bezier(.32,1.4,.32,1) both;
  backdrop-filter: blur(8px);
}
.wc-toast-success{ border-color: color-mix(in srgb, var(--success) 60%, var(--border)); }
.wc-toast-error{ border-color: color-mix(in srgb, var(--danger) 60%, var(--border)); }
@keyframes toast-in { from { opacity:0; transform: translateY(-8px) scale(.95); } to { opacity:1; transform:none; } }
.wc-toast.leaving{ animation: toast-out .32s ease forwards; }
@keyframes toast-out { to { opacity:0; transform: translateY(-6px) scale(.96); } }

/* ======= DEBUG PANEL ======= */
#debugPanel {
  border: 2px solid rgba(124,58,237,0.3);
  background: linear-gradient(160deg, rgba(124,58,237,0.08), rgba(6,182,212,0.04));
}

.debug-status {
  background: rgba(255,255,255,0.03);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 13px;
  line-height: 1.4;
}

.debug-status div {
  margin-bottom: 4px;
}

.debug-status div:last-child {
  margin-bottom: 0;
}

.debug-status span {
  color: var(--primary-2);
  font-weight: 500;
}

#debugFriendsMessages,
#debugCallLog {
  font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
  font-size: 12px;
  line-height: 1.3;
  background: rgba(0,0,0,0.2);
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow-y: auto;
  padding: 6px 8px;
}

#debugFriendsMessages .debug-msg,
#debugCallLog .debug-msg {
  margin-bottom: 2px;
  padding: 2px 4px;
  border-radius: 3px;
}

#debugFriendsMessages .debug-msg.incoming {
  background: rgba(34,197,94,0.1);
  border-left: 2px solid var(--success);
}

#debugFriendsMessages .debug-msg.outgoing {
  background: rgba(239,68,68,0.1);
  border-left: 2px solid var(--danger);
}

#debugCallLog .debug-msg.call-event {
  background: rgba(124,58,237,0.1);
  border-left: 2px solid var(--primary);
}

.debug-timestamp {
  color: var(--muted);
  font-size: 11px;
  margin-right: 6px;
}

/* ======= RESPONSIVE REFINEMENTS (ADDED) ======= */
/* Сетка участников: упорядочим брейки, чтобы не было конфликтов 220px/140px */
@media (max-width: 900px){
  .peers-grid{ grid-template-columns:repeat(auto-fill,minmax(240px,1fr)); }
}
/* Desktop layout adjustments */
@media (min-width:960px){
  #roomCard{ display:flex; flex-direction:column; }
  #roomCard h2{ text-align:center; }
  #roomCard .form-grid{ max-width:860px; margin:0 auto; }
  #roomCard .row{ justify-content:center; }
  #inCallControls{ justify-content:center; }
  #roomCard input#roomId{ max-width:480px; }
}
@media (max-width: 760px){
  /* Уже есть общее уменьшение – подправим peers-grid */
  .peers-grid{ grid-template-columns:repeat(auto-fill,minmax(180px,1fr)); }
}
@media (max-width: 640px){
  .peers-grid{ grid-template-columns:repeat(auto-fill,minmax(160px,1fr)); }
  .tile .media{ aspect-ratio:4/3; }
}
@media (max-width: 520px){
  .peers-grid{ grid-template-columns:repeat(auto-fill,minmax(140px,1fr)); gap:10px; }
  .tile .media{ aspect-ratio:4/3; }
  .tile .hud{ padding:8px 8px 10px; gap:6px; }
  .tile .hud .name{ font-size:13px; }
}
@media (max-width: 430px){
  .peers-grid{ grid-template-columns:repeat(auto-fill,minmax(120px,1fr)); gap:8px; }
  .tile .media{ aspect-ratio:1/1; }
  .tile .hud{ padding:6px 6px 8px; }
  .tile .hud .level{ height:5px; }
  .tile .hud .name{ font-size:12px; }
}

/* Header / actions адаптация */
@media (max-width: 720px){
  .header-inner{ flex-wrap:wrap; row-gap:8px; }
  .app-header .actions{ flex-wrap:wrap; justify-content:flex-end; }
}
@media (max-width: 560px){
  .app-header .actions .btn{ padding:8px 10px; font-size:13px; }
  .user-badge{ padding:5px 9px; }
}
@media (max-width: 430px){
  .title{ font-size:15px; }
  .app-header .actions .btn{ padding:7px 9px; font-size:12px; }
  /* Скрыть текст на кнопке выхода оставив иконку через data-attr, если захотите добавить позже */
  #btnLogout{ white-space:nowrap; }
  #btnLogout::after{ content:""; }
}

/* Уменьшение общих отступов */
@media (max-width: 600px){
  .container{ padding:12px; }
  .card{ padding:14px; }
}
@media (max-width: 430px){
  .container{ padding:10px; }
  .card{ padding:12px; }
}

/* Динамическая высота чатов: предотвращаем наложение на элементы управления */
@media (max-height: 900px){
  .chat-box{ max-height: 260px; }
}
@media (max-height: 780px){
  .chat-box{ max-height: 220px; }
}
@media (max-width: 640px){
  /* На очень узких и невысоких устройствах ограничим относительным vh */
  .chat-box, #directMessages{ max-height: min(44vh, 300px); }
}
@media (max-width: 430px){
  .chat-box, #directMessages{ max-height: min(48vh, 260px); }
}


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\styles.css =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\sw.js =====
--- SIZE: 1458 bytes ---

// sw.js — простой обработчик push
self.addEventListener('install', (e) => {
  self.skipWaiting();
});

self.addEventListener('activate', (e) => {
  self.clients.claim();
});

self.addEventListener('push', (event) => {
  let data = {};
  try{ data = event.data.json(); }catch{}
  const title = data.title || 'Уведомление';
  const body = data.body || '';
  const icon = data.icon || undefined;
  event.waitUntil(self.registration.showNotification(title, { body, icon, data: data.data || {} }));
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  const data = event.notification.data || {};
  const from = data.from;
  const url = '/call';
  event.waitUntil((async () => {
    // Пытаемся фокусировать открытую вкладку
    const winClients = await clients.matchAll({ type: 'window', includeUncontrolled: true });
    if (winClients && winClients.length){
      const client = winClients[0];
      try { await client.focus(); } catch {}
      if (from){
        try { client.postMessage({ type: 'openDirect', userId: from }); } catch {}
      }
      return;
    }
    // Иначе открываем новую вкладку
    const newClient = await clients.openWindow(url);
    if (newClient && from){
      try { newClient.postMessage({ type: 'openDirect', userId: from }); } catch {}
    }
  })());
});

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\static\sw.js =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\friends.py =====
--- SIZE: 15834 bytes ---

from __future__ import annotations

"""WebSocket канал для событий дружбы, личных сообщений и личных звонков.

Форматы входящих (клиент -> сервер):
 - {"type":"ping"}
 - {"type":"call_end","roomId":str,"toUserId":str,"reason"?:str} (когда завершаем активный звонок)

Форматы исходящих (сервер -> клиент):
 - friend_request / friend_accepted / friend_cancelled / friend_removed
 - direct_message / direct_cleared
 - call_invite / call_accept / call_decline / call_cancel / call_end

Авторизация: JWT в query param `token`. В средах dev,test разрешён guest режим.
Политика: одно активное friends WebSocket соединение на пользователя. Предыдущее закрывается с кодом 4000.
"""

import asyncio
import contextlib
import json
import logging
from typing import Dict, Set
from uuid import UUID

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends

from ...infrastructure.config import get_settings
from ...core.ports.repositories import UserRepository
from ..api.deps.containers import get_user_repo, get_token_provider, get_call_invite_service
from ...core.ports.services import TokenProvider, CallInviteService

router = APIRouter()
logger = logging.getLogger(__name__)

_friend_clients: Dict[UUID, Set[WebSocket]] = {}
_ws_to_user: Dict[WebSocket, UUID] = {}

# Локальный кэш pending (дополнительно к сервису) для обратной совместимости
_pending_calls: Dict[str, dict] = {}

try:  # метрики опциональны
    from prometheus_client import Counter, Gauge
    FRIENDS_WS_ACTIVE = Gauge('ws_active_friends', 'Active friends WS connections')
    CALL_EVENTS = Counter('call_signal_events_total', 'Call signaling events', ['event'])
except Exception:  # pragma: no cover
    FRIENDS_WS_ACTIVE = None
    CALL_EVENTS = None


async def _register(user_id: UUID, ws: WebSocket) -> None:
    existing = _friend_clients.get(user_id)
    if existing:
        for old in list(existing):
            try:
                logger.info("WS_REPLACE user=%s old_ws=%s new_ws=%s", user_id, id(old), id(ws))
                try:
                    await old.close(code=4000)
                except Exception as e:  # pragma: no cover
                    logger.warning("WS_CLOSE_OLD_FAILED user=%s err=%s", user_id, e)
            finally:
                _unregister(old)
    _friend_clients.setdefault(user_id, set()).add(ws)
    _ws_to_user[ws] = user_id
    logger.info("WS_REGISTER user=%s ws=%s active=%s", user_id, id(ws), len(_friend_clients.get(user_id, set())))


def _unregister(ws: WebSocket) -> None:
    uid = _ws_to_user.pop(ws, None)
    if uid is not None:
        s = _friend_clients.get(uid)
        if s and ws in s:
            s.discard(ws)
            if not s:
                _friend_clients.pop(uid, None)
        logger.info("WS_UNREGISTER user=%s ws=%s", uid, id(ws))


async def broadcast_user(user_id: UUID, payload: dict):
    for ws in list(_friend_clients.get(user_id, set())):
        try:
            await ws.send_json(payload)
            try:
                logger.info("WS_SEND user=%s ws=%s type=%s", user_id, id(ws), payload.get('type'))
            except Exception:
                pass
        except Exception as e:  # pragma: no cover
            try:
                logger.warning("WS_SEND_FAIL user=%s ws=%s type=%s err=%s", user_id, id(ws), payload.get('type'), e)
            except Exception:
                pass


async def broadcast_users(user_ids: Set[UUID] | list[UUID], payload: dict):
    for uid in user_ids:
        await broadcast_user(uid, payload)


async def broadcast_all(payload: dict, exclude: UUID | None = None):
    """Рассылка всем активным пользователям (используем для presence)."""
    for uid, sockets in list(_friend_clients.items()):
        if exclude is not None and uid == exclude:
            continue
        for ws in list(sockets):
            try:
                await ws.send_json(payload)
            except Exception:  # pragma: no cover
                with contextlib.suppress(Exception):
                    sockets.discard(ws)
        if not sockets:
            _friend_clients.pop(uid, None)


@router.websocket('/ws/friends')
async def ws_friends(
    websocket: WebSocket,
    tokens: TokenProvider = Depends(get_token_provider),  # type: ignore[arg-type]
    users: UserRepository = Depends(get_user_repo),  # noqa: F841
    call_invites: CallInviteService = Depends(get_call_invite_service),  # type: ignore[arg-type]
):
    settings = get_settings()
    token = websocket.query_params.get('token')
    await websocket.accept()
    allow_unauth = settings.APP_ENV in {'dev', 'test'}
    user_id: UUID | None = None

    if token:
        try:
            payload = tokens.decode_token(token)
            sub = payload.get('sub')
            if sub:
                user_id = UUID(sub)
        except Exception:
            if not allow_unauth:
                await websocket.close(code=4401, reason='Unauthorized')
                return
    else:
        if not allow_unauth:
            await websocket.close(code=4401, reason='Unauthorized')
            return

    if user_id is not None:
        await _register(user_id, websocket)
        if FRIENDS_WS_ACTIVE:
            with contextlib.suppress(Exception):
                FRIENDS_WS_ACTIVE.inc()
        # Presence snapshot (отправляем только подключившемуся)
        try:
            snapshot_ids = [str(uid) for uid in _friend_clients.keys()]
            await websocket.send_json({'type': 'presence_snapshot', 'userIds': snapshot_ids})
        except Exception:
            logger.warning("PRESENCE_SNAPSHOT_FAIL user=%s", user_id)
        # Broadcast join другим
        try:
            await broadcast_all({'type': 'presence_join', 'userId': str(user_id)}, exclude=user_id)
        except Exception:
            logger.warning("PRESENCE_JOIN_BROADCAST_FAIL user=%s", user_id)
        # Ретрансляция ожидающих инвайтов через сервис + fallback локального кэша
        replayed_rooms = set()
        with contextlib.suppress(Exception):
            pending = await call_invites.list_pending_for(user_id)
            for p in pending:
                created_at = p.get('createdAt') or p.get('ts')
                await websocket.send_json({
                    'type': 'call_invite',
                    'fromUserId': p['fromUserId'],
                    'toUserId': p['toUserId'],
                    'roomId': p['roomId'],
                    'fromUsername': p.get('fromUsername'),
                    'fromEmail': p.get('fromEmail'),
                    'createdAt': created_at,
                    'pendingReplay': True,
                })
                replayed_rooms.add(p['roomId'])
        # Fallback: используем _pending_calls если по каким-то причинам сервис статуса не сохранил
        with contextlib.suppress(Exception):
            import time as _t
            now_ms = int(_t.time()*1000)
            MAX_AGE_MS = 40000
            stale = []
            for rid, data in list(_pending_calls.items()):
                ts = int(data.get('ts') or 0)
                if not ts or (now_ms - ts) > MAX_AGE_MS:
                    stale.append(rid)
                    continue
                if rid in replayed_rooms:
                    continue
                if str(user_id) not in (data.get('fromUserId'), data.get('toUserId')):
                    continue
                await websocket.send_json({
                    'type': 'call_invite',
                    'fromUserId': data.get('fromUserId'),
                    'toUserId': data.get('toUserId'),
                    'roomId': rid,
                    'fromUsername': data.get('fromUsername'),
                    'fromEmail': data.get('fromEmail'),
                    'createdAt': ts,
                    'pendingReplay': True,
                })
            for rid in stale:
                _pending_calls.pop(rid, None)

    try:
        while True:
            try:
                msg = await websocket.receive_text()
            except WebSocketDisconnect:
                break
            except Exception:
                break
            with contextlib.suppress(Exception):
                data = json.loads(msg)
                if isinstance(data, dict):
                    t = data.get('type')
                    if t == 'ping':
                        await websocket.send_json({'type': 'pong'})
                    elif t == 'call_end' and user_id is not None:
                        room_id = data.get('roomId')
                        other_raw = data.get('toUserId')
                        reason = data.get('reason') or 'hangup'
                        if room_id and other_raw:
                            try:
                                other_uid = UUID(other_raw)
                            except Exception:
                                continue
                            payload = {
                                'type': 'call_end',
                                'fromUserId': str(user_id),
                                'toUserId': str(other_uid),
                                'roomId': room_id,
                                'reason': reason,
                            }
                            await broadcast_users({user_id, other_uid}, payload)
                            if CALL_EVENTS:
                                with contextlib.suppress(Exception):
                                    CALL_EVENTS.labels('end').inc()
    finally:
        _unregister(websocket)
        if FRIENDS_WS_ACTIVE:
            with contextlib.suppress(Exception):
                FRIENDS_WS_ACTIVE.dec()
        # Если после отключения у пользователя больше нет соединений – посылаем presence_leave
        try:
            # user_id может быть None если не аутентифицирован
            if user_id is not None and user_id not in _friend_clients:
                await broadcast_all({'type': 'presence_leave', 'userId': str(user_id)}, exclude=user_id)
        except Exception:
            logger.warning("PRESENCE_LEAVE_BROADCAST_FAIL user=%s", user_id)


# === Friend events ===

async def publish_friend_request(from_user_id: UUID, to_user_id: UUID, from_username: str | None):
    await broadcast_user(to_user_id, {
        'type': 'friend_request',
        'fromUserId': str(from_user_id),
        'username': from_username,
    })


async def publish_friend_accepted(user_a: UUID, user_b: UUID, username_a: str | None, username_b: str | None):
    await broadcast_user(user_a, {
        'type': 'friend_accepted',
        'userId': str(user_b),
        'username': username_b,
    })
    await broadcast_user(user_b, {
        'type': 'friend_accepted',
        'userId': str(user_a),
        'username': username_a,
    })


async def publish_friend_cancelled(requester: UUID, other: UUID):
    await broadcast_users({requester, other}, {
        'type': 'friend_cancelled',
        'userId': str(other),
    })


async def publish_friend_removed(user_a: UUID, user_b: UUID):
    await broadcast_users({user_a, user_b}, {
        'type': 'friend_removed',
        'userId': str(user_a),
    })


async def publish_direct_message(from_user: UUID, to_user: UUID, message_id: UUID, content: str, sent_at):
    # content теперь plaintext (сервер сам хранит ciphertext). Клиенту не нужно расшифровывать.
    payload = {
        'type': 'direct_message',
        'fromUserId': str(from_user),
        'toUserId': str(to_user),
        'content': content,
        'messageId': str(message_id),
        'sentAt': sent_at.isoformat(),
    }
    await broadcast_users({from_user, to_user}, payload)


async def publish_direct_cleared(user_a: UUID, user_b: UUID):
    payload = {
        'type': 'direct_cleared',
        'userIds': [str(user_a), str(user_b)],
    }
    await broadcast_users({user_a, user_b}, payload)


# === Call signaling events ===

def _inc_call_metric(name: str):  # helper
    if CALL_EVENTS:
        with contextlib.suppress(Exception):
            CALL_EVENTS.labels(name).inc()


async def publish_call_invite(from_user: UUID, to_user: UUID, room_id: str, from_username: str | None = None, from_email: str | None = None):
    import time
    ts = int(time.time()*1000)
    _pending_calls[room_id] = {
        'fromUserId': str(from_user),
        'toUserId': str(to_user),
        'fromUsername': (str(from_username) if from_username is not None else None),
        'fromEmail': (str(from_email) if from_email is not None else None),
        'roomId': room_id,
        'ts': ts,
    }
    payload = {
        'type': 'call_invite',
        'fromUserId': str(from_user),
        'toUserId': str(to_user),
        'roomId': room_id,
        'fromUsername': (str(from_username) if from_username is not None else None),
        'fromEmail': (str(from_email) if from_email is not None else None),
        'createdAt': ts,
    }
    # Диагностика: сколько активных WS у отправителя и получателя на момент рассылки
    try:
        from_count = len(_friend_clients.get(from_user, set()))
        to_count = len(_friend_clients.get(to_user, set()))
        logger.info(
            "CALL_INVITE_SEND from=%s(to_ws=%s) to=%s(to_ws=%s) room=%s", from_user, from_count, to_user, to_count, room_id
        )
    except Exception:
        logger.info("CALL_INVITE_SEND from=%s to=%s room=%s", from_user, to_user, room_id)
    _inc_call_metric('invite')
    await broadcast_users({from_user, to_user}, payload)


async def publish_call_accept(from_user: UUID, to_user: UUID, room_id: str):
    _pending_calls.pop(room_id, None)
    payload = {
        'type': 'call_accept',
        'fromUserId': str(from_user),
        'toUserId': str(to_user),
        'roomId': room_id,
    }
    logger.info("CALL_ACCEPT_SEND from=%s to=%s room=%s", from_user, to_user, room_id)
    _inc_call_metric('accept')
    await broadcast_users({from_user, to_user}, payload)


async def publish_call_decline(from_user: UUID, to_user: UUID, room_id: str):
    _pending_calls.pop(room_id, None)
    payload = {
        'type': 'call_decline',
        'fromUserId': str(from_user),
        'toUserId': str(to_user),
        'roomId': room_id,
    }
    logger.info("CALL_DECLINE_SEND from=%s to=%s room=%s", from_user, to_user, room_id)
    _inc_call_metric('decline')
    await broadcast_users({from_user, to_user}, payload)


async def publish_call_cancel(from_user: UUID, to_user: UUID, room_id: str):
    _pending_calls.pop(room_id, None)
    payload = {
        'type': 'call_cancel',
        'fromUserId': str(from_user),
        'toUserId': str(to_user),
        'roomId': room_id,
    }
    logger.info("CALL_CANCEL_SEND from=%s to=%s room=%s", from_user, to_user, room_id)
    _inc_call_metric('cancel')
    await broadcast_users({from_user, to_user}, payload)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\friends.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\rooms.py =====
--- SIZE: 53492 bytes ---

from __future__ import annotations

import os, asyncio, contextlib, time, re, json
from typing import Any
from collections import defaultdict
from uuid import UUID, uuid5, NAMESPACE_URL
from datetime import datetime

from fastapi import APIRouter, Depends, WebSocket, WebSocketDisconnect
from ...infrastructure.config import get_settings
from ...infrastructure.services.summary import get_summary_collector, SummaryCollector, SummaryResult
from ...infrastructure.services.voice_transcript import get_voice_collector
from ...infrastructure.services.ai_provider import get_ai_provider, get_user_system_prompt
from ...infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator
from ...infrastructure.services.telegram import send_message as tg_send_message
from ...infrastructure.services.telegram_dispatcher import get_dispatcher
from sqlalchemy.ext.asyncio import AsyncSession
from ...infrastructure.db.session import get_db_session
from ...infrastructure.services.telegram_link import get_confirmed_chat_id

from ...core.domain.models import Signal
from ...core.ports.services import SignalBus, TokenProvider
from ...core.ports.repositories import UserRepository, ParticipantRepository, RoomRepository
from ..api.deps.containers import get_signal_bus, get_token_provider, get_user_repo, get_participant_repo, get_room_repo
from ...infrastructure.messaging.redis_bus import RedisSignalBus  # for type-check to enable Redis chat broadcast

router = APIRouter()

# In-process registry of room connections for chat broadcast (dev/test)
_room_clients: dict[UUID, set[WebSocket]] = defaultdict(set)
_ws_conn: dict[WebSocket, UUID] = {}
_room_members: dict[UUID, set[UUID]] = defaultdict(set)
_display_names: dict[UUID, str] = {}
# Однократная финализация summary по комнате (manual trigger)
_room_summary_finalized: set[UUID] = set()
# Множество AI агентов по комнатам (для поддержки нескольких персональных агентов)
_room_agents: dict[UUID, set[UUID]] = defaultdict(set)
# Кэш готового summary (одно на комнату)
_room_summary_cache: dict[UUID, SummaryResult] = {}
# Кому уже доставлено summary (персонально)
_room_summary_served: dict[UUID, set[UUID]] = defaultdict(set)
# Владелец агента: conn_id агента -> user_id владельца
_agent_owner: dict[UUID, UUID] = {}
# Локи генерации per комната
_room_summary_locks: dict[UUID, asyncio.Lock] = defaultdict(asyncio.Lock)
# Персональные manual summary кэши: (room,user) -> SummaryResult и обслуженные отправки
_user_manual_summary_cache: dict[tuple[UUID, UUID], SummaryResult] = {}
_user_manual_summary_served: set[tuple[UUID, UUID]] = set()
_room_participant_users: dict[UUID, set[UUID]] = defaultdict(set)
# Архив последних сообщений комнаты (для персональных запросов после группового destructive summarize)
_room_messages_archive: dict[UUID, list] = {}
# Персистентный процессовый лог всех чат сообщений (не destructive)
_room_message_log: dict[UUID, list] = defaultdict(list)
# Время старта персонального агента для пользователя в комнате (ms epoch)
_room_agent_start: dict[tuple[UUID, UUID], int] = {}


async def _generate_and_send_summary(room_uuid: UUID, original_room_id: str, reason: str, *,
                                     ai_provider, collector, voice_coll, session: AsyncSession | None = None,
                                     initiator_user_id: UUID | None = None) -> None:  # type: ignore[no-untyped-def]
    """Собирает summary (voice > chat) и отправляет в Telegram. Используется только по ручному триггеру.

    reason: строка причины (manual, debug, etc.)
    """
    # TODO: покрыть интеграционным тестом (websocket):
    # 1) отправить несколько chat сообщений;
    # 2) имитировать наличие voice транскрипта в voice_coll;
    # 3) отправить agent_summary и проверить одноразовую отправку.
    settings = get_settings()
    # Персональный режим: если инициатор указан — генерируем snapshot-based summary индивидуально
    if initiator_user_id: 
        # Feature flag: отключить новую архитектуру, установить USE_SUMMARY_V2=0
        use_v2 = os.getenv("USE_SUMMARY_V2", "1").lower() not in {"0", "false", "no"}
        if use_v2:
            orchestrator = get_summary_orchestrator()
            print(f"[summary] Personal summary start room={original_room_id} user={initiator_user_id} reason={reason} use_v2=1")
            # Диагностика: текущие internal counters оркестратора (редко, только при старте генерации)
            with contextlib.suppress(Exception):
                ctrs = orchestrator.get_counters()
                print(f"[summary] Orchestrator counters snapshot room={original_room_id} user={initiator_user_id} counters={ctrs}")
            # Оппортунистическое прикрепление ТОЛЬКО персонального транскрипта (без fallback на общий ключ)
            with contextlib.suppress(Exception):
                v_cur = await voice_coll.get_transcript(f"{room_uuid}:{initiator_user_id}")
                if v_cur and getattr(v_cur, 'text', None):
                    raw_txt = v_cur.text.strip()
                    if raw_txt and not raw_txt.startswith('(no audio'):
                        # Извлекаем captureTs если уже есть мета
                        capture_ts = None
                        if raw_txt.startswith('[meta ') and 'captureTs=' in raw_txt:
                            m = re.search(r'captureTs=(\d+)', raw_txt)
                            if m:
                                with contextlib.suppress(Exception):
                                    capture_ts = int(m.group(1))
                        if capture_ts is None:
                            capture_ts = int(time.time()*1000)
                            raw_txt = f"[meta captureTs={capture_ts}] " + raw_txt
                        start_ms = _room_agent_start.get((room_uuid, initiator_user_id))
                        fresh = start_ms is None or capture_ts >= (start_ms - 150)
                        if fresh:
                            orchestrator.add_voice_transcript(str(room_uuid), raw_txt, user_id=str(initiator_user_id))
                            print(f"[summary] opportunistic_attach accepted room={original_room_id} user={initiator_user_id} captureTs={capture_ts} start_ms={start_ms}")
                        else:
                            print(f"[summary] opportunistic_attach rejected(stale) room={original_room_id} user={initiator_user_id} captureTs={capture_ts} start_ms={start_ms}")
            # Первая попытка построить персональное summary
            cutoff_ms = int(__import__('time').time()*1000)
            personal = await orchestrator.build_personal_summary(room_id=str(room_uuid), user_id=str(initiator_user_id), ai_provider=ai_provider, db_session=session, cutoff_ms=cutoff_ms)
            try:
                print(f"[summary] Personal summary first-build room={original_room_id} user={initiator_user_id} msg_count={personal.message_count} used_voice={getattr(personal,'used_voice', False)} text_len={len(getattr(personal,'summary_text','') or '')}")
            except Exception:
                pass
            # Polling если пусто (возможна гонка: транскрипт ещё в пути / задержка ASR)
            if personal.message_count == 0:
                # Дополнительное ожидание только если нет ни одного сообщения и не использован voice
                max_wait_ms = 6000
                step_ms = 500
                waited = 0
                while waited < max_wait_ms and personal.message_count == 0 and not getattr(personal, 'used_voice', False):
                    await asyncio.sleep(step_ms / 1000)
                    waited += step_ms
                    personal2 = await orchestrator.build_personal_summary(room_id=str(room_uuid), user_id=str(initiator_user_id), ai_provider=ai_provider, db_session=session, cutoff_ms=cutoff_ms)
                    try:
                        print(f"[summary] Personal summary retry room={original_room_id} user={initiator_user_id} waited={waited} msg_count={personal2.message_count} used_voice={getattr(personal2,'used_voice', False)}")
                    except Exception:
                        pass
                    if personal2.message_count > 0:
                        personal = personal2
                        print(f"[summary] Personal summary filled after wait={waited}ms room={original_room_id} user={initiator_user_id}")
                        break
                    if getattr(personal2, 'used_voice', False) and personal2.message_count == 0:
                        # Аномалия: voice использован, но count 0 — логируем и выходим из цикла
                        print(f"[summary] Anomaly: used_voice true but msg_count=0 room={original_room_id} user={initiator_user_id} waited={waited}")
                        personal = personal2
                        break
                else:
                    if personal.message_count == 0:
                        # Финальная попытка ре-прикрепить voice напрямую (если появился вне окна)
                        try:
                            v_cur2 = None
                            with contextlib.suppress(Exception):
                                v_cur2 = await voice_coll.get_transcript(f"{room_uuid}:{initiator_user_id}")
                            if v_cur2 and getattr(v_cur2, 'text', None) and len(v_cur2.text.strip()) > 10 and not v_cur2.text.startswith('(no audio'):
                                orchestrator.add_voice_transcript(str(room_uuid), v_cur2.text.strip(), user_id=str(initiator_user_id))
                                personal3 = await orchestrator.build_personal_summary(room_id=str(room_uuid), user_id=str(initiator_user_id), ai_provider=ai_provider, db_session=session, cutoff_ms=cutoff_ms)
                                if personal3.message_count > 0:
                                    personal = personal3
                                    print(f"[summary] Personal summary recovered after final voice attach room={original_room_id} user={initiator_user_id}")
                        except Exception:
                            pass
            # Очистим использованный персональный транскрипт если мы что-то реально собрали
            if personal.message_count > 0:
                with contextlib.suppress(Exception):
                    await voice_coll.pop_transcript(f"{room_uuid}:{initiator_user_id}")
            # Подготовка и отправка в Telegram с расширенным логированием причин пропуска
            try:
                used_voice = getattr(personal, 'used_voice', False)
                print(f"[summary] Personal summary pre-telegram room={original_room_id} user={initiator_user_id} msg_count={personal.message_count} used_voice={used_voice} summary_len={len(personal.summary_text or '') if hasattr(personal,'summary_text') else 'n/a'}")
            except Exception:
                pass
            # Если по какой-то причине message_count=0, но есть осмысленный текст > 40 символов - отправим как есть (голос мог не засчитаться в count)
            if personal.message_count == 0 and getattr(personal, 'summary_text', None) and len(getattr(personal,'summary_text')) > 40:
                try:
                    print(f"[summary] Personal summary force-send override room={original_room_id} user={initiator_user_id} text_len={len(personal.summary_text)}")
                except Exception:
                    pass
            if not settings.TELEGRAM_BOT_TOKEN:
                print(f"[summary] Telegram skip: no TELEGRAM_BOT_TOKEN room={original_room_id} user={initiator_user_id}")
            elif session is None:
                print(f"[summary] Telegram skip: no DB session room={original_room_id} user={initiator_user_id}")
            else:
                print(f"[summary] Telegram dispatch entering room={original_room_id} user={initiator_user_id} msg_count={personal.message_count}")
                try:
                    chat_id = await get_confirmed_chat_id(session, initiator_user_id)
                except Exception as e:
                    chat_id = None
                    print(f"[summary] Telegram error: get_confirmed_chat_id failed room={original_room_id} user={initiator_user_id} err={e}")
                if not chat_id:
                    # Попробуем fallback к глобальному TELEGRAM_CHAT_ID (устаревшее, но как спасение)
                    if settings.TELEGRAM_CHAT_ID:
                        chat_id = settings.TELEGRAM_CHAT_ID
                        print(f"[summary] Telegram fallback to global chat_id room={original_room_id} user={initiator_user_id}")
                    else:
                        print(f"[summary] Telegram skip: no confirmed chat_id room={original_room_id} user={initiator_user_id}")
                        chat_id = None
                else:
                    if personal.message_count == 0:
                        body = (
                            "Персональное резюме пока пусто: сообщений ещё нет или продолжается обработка голоса. "
                            "Попробуйте запросить ещё раз через несколько секунд."
                        )
                    else:
                        body = personal.summary_text
                    print(f"[summary] Telegram preparing body_len={len(body)} room={original_room_id} user={initiator_user_id}")
                    # Participant breakdown форматирование (если присутствует)
                    participants_block = ""
                    try:
                        parts = getattr(personal, 'participants', None)
                        print(f"[summary] Telegram participants_count={len(parts) if parts else 0} room={original_room_id} user={initiator_user_id}")
                        if parts:
                            lines = []
                            for p in parts[:5]:  # ограничим до 5 участников
                                sample_tail = p.sample_messages[-2:] if p.sample_messages else []
                                sample_txt = "; ".join(sample_tail)
                                who = p.participant_name or p.participant_id or "anon"
                                line = f"- {who}: {p.message_count} msg. {sample_txt}".strip()
                                # Усечение строки если длинная
                                if len(line) > 180:
                                    line = line[:177] + "…"
                                lines.append(line)
                            participants_block = "\n\nУчастники:\n" + "\n".join(lines)
                    except Exception as e:
                        print(f"[summary] Participants format error room={original_room_id} user={initiator_user_id} err={e}")
                        participants_block = ""
                    text = (
                        f"Room {personal.room_id} персональное summary (trigger={reason}). Сообщений: {personal.message_count}.\n--- Summary ---\n{body}{participants_block}"
                    )
                    # Telegram API всё равно обрежет до ~4096; подрежем чуть раньше (4000) чтобы не потерять окончание
                    if len(text) > 4000:
                        text = text[:3990] + "…(truncated)"
                    # Отправку делегируем диспетчеру (асинхронная очередь + ретраи)
                    dispatch_text = text  # уже ограничен по длине
                    try:
                        dispatcher = get_dispatcher()
                        reason_with_room = f"{reason}:room:{room_uuid}" if room_uuid else reason
                        queued = await dispatcher.queue_summary(str(initiator_user_id), dispatch_text, reason=reason_with_room)
                        print(f"[summary] Personal summary (v2) queued_for_dispatch queued={queued} user={initiator_user_id} room={original_room_id} reason={reason_with_room} empty={personal.message_count==0}")
                    except Exception as e:
                        print(f"[summary] Dispatcher queue exception room={original_room_id} user={initiator_user_id} err={e}")
            return
        else:
            # Fallback: старая логика snapshot + summarize_messages (без orchestrator)
            from ...infrastructure.services.summary import summarize_messages as _sm
            # Снимок сообщений + voice если готов
            v_cur = None
            with contextlib.suppress(Exception):
                v_cur = await voice_coll.get_transcript(str(room_uuid)) or await voice_coll.get_transcript(original_room_id)
            msgs = []
            with contextlib.suppress(Exception):
                msgs = await collector.get_messages_snapshot(str(room_uuid))  # type: ignore[attr-defined]
            merged = list(msgs)
            if v_cur and getattr(v_cur, 'text', None) and v_cur.text.strip() and not v_cur.text.startswith('(no audio'):
                try:
                    from ...infrastructure.services.summary import ChatMessage as _CM
                    import time as _t
                    merged.append(_CM(room_id=str(room_uuid), author_id=None, author_name='voice', content=v_cur.text.strip(), ts=int(_t.time()*1000)))
                except Exception:
                    pass
            legacy_result = None
            if merged:
                with contextlib.suppress(Exception):
                    legacy_result = await _sm(merged, ai_provider)
            if settings.TELEGRAM_BOT_TOKEN and session is not None:
                with contextlib.suppress(Exception):
                    chat_id = await get_confirmed_chat_id(session, initiator_user_id)
                    if chat_id:
                        if legacy_result:
                            text = (
                                f"Room {legacy_result.room_id} персональное summary (legacy, trigger={reason}). Сообщений: {legacy_result.message_count}.\n--- Summary ---\n{legacy_result.summary_text}"
                            )
                        else:
                            text = (
                                f"Room {room_uuid} персональное summary (legacy, trigger={reason}). Сообщений нет."\
                                " Возможно, данных ещё недостаточно."
                            )
                        await tg_send_message(text, chat_ids=[chat_id], session=session)
            return

    # Групповой режим (без initiator): старый кэш + лок
    lock = _room_summary_locks[room_uuid]
    async with lock:
        cached = _room_summary_cache.get(room_uuid)
        if cached is not None:
            targets: set[UUID] = set()
            for aid in _room_agents.get(room_uuid, set()):
                owner = _agent_owner.get(aid)
                if owner:
                    targets.add(owner)
            if not targets:
                # fallback: все участники комнаты (user_ids)
                participants = _room_participant_users.get(room_uuid, set())
                if participants:
                    targets.update(participants)
                    print(f"[summary] Group targets fallback to participants count={len(participants)} room={original_room_id}")
                else:
                    print(f"[summary] Cached summary exists room={original_room_id} but no group targets/participants")
                    return
            served = _room_summary_served[room_uuid]
            pending = [u for u in targets if u not in served]
            if not pending:
                print(f"[summary] Cached summary already served to all group targets room={original_room_id}")
                return
            if settings.TELEGRAM_BOT_TOKEN:
                for uid in pending:
                    try:
                        chat_id = None
                        if session is not None:
                            chat_id = await get_confirmed_chat_id(session, uid)
                        if not chat_id:
                            print(f"[summary] Skip send user={uid} room={original_room_id}: no chat_id")
                            continue
                        text = (
                            f"Room {cached.room_id} завершена (trigger={reason}, cached). Сообщений: {cached.message_count}.\n--- Summary ---\n{cached.summary_text}"
                        )
                        await tg_send_message(text, chat_ids=[chat_id], session=session)
                        served.add(uid)
                        print(f"[summary] Cached summary delivered user={uid} room={original_room_id}")
                    except Exception as e:
                        print(f"[summary] Cached summary send failed user={uid} room={original_room_id} err={e}")
            return
    # settings уже инициализирован выше
    v = None
    # Ожидаем до ~6с появления транскрипта (poll каждые 300мс)
    for attempt in range(20):
        with contextlib.suppress(Exception):
            v = await voice_coll.get_transcript(str(room_uuid)) or await voice_coll.get_transcript(original_room_id)
        if v:  # готов
            break
        await asyncio.sleep(0.3)
    # Если получили – извлекаем (pop) чтобы не использовать повторно
    if v:
        with contextlib.suppress(Exception):
            v = await voice_coll.pop_transcript(str(room_uuid)) or await voice_coll.pop_transcript(original_room_id)
    from ...infrastructure.services.summary import SummaryCollector
    summary = None
    # Получаем кастомный system prompt (только если пользователь инициатор известен)
    custom_prompt: str | None = None
    if initiator_user_id and session is not None:
        with contextlib.suppress(Exception):
            custom_prompt = await get_user_system_prompt(session, initiator_user_id)

    from ...infrastructure.services.summary import summarize_messages as _sm
    if v and v.text and not v.text.startswith('(no audio'):
        print(f"[summary] Using voice transcript for room {original_room_id} chars={len(v.text)} reason={reason}")
        import re, time as _t
        # Разбиваем транскрипт на предложения, формируем временный список ChatMessage без очистки collector
        sentences: list[str] = []
        text_v = v.text or ''
        if text_v.strip():
            norm = re.sub(r"\s+", " ", text_v.strip())
            parts = re.split(r'(?<=[.!?])\s+', norm)
            sentences = [p.strip() for p in parts if p.strip()]
        if not sentences and text_v.strip():
            sentences = [text_v.strip()]
        voice_msgs = []
        try:
            from ...infrastructure.services.summary import ChatMessage as _CM
            now_ms = int(_t.time()*1000)
            for s in sentences:
                voice_msgs.append(_CM(room_id=str(room_uuid), author_id=None, author_name='voice', content=s, ts=now_ms))
        except Exception:
            pass
        # Берём snapshot текущего collector и добавляем voice предложения (не destructive)
        base_snap = []
        with contextlib.suppress(Exception):
            base_snap = await collector.get_messages_snapshot(str(room_uuid))  # type: ignore[attr-defined]
        merged = list(base_snap) + voice_msgs
        if merged:
            summary = await _sm(merged, ai_provider, system_prompt=custom_prompt)
    else:
        print(f"[summary] Voice transcript missing or empty for room {original_room_id}; fallback to chat. reason={reason}")
        # Чат snapshot без очистки
        try:
            snap_chat = await collector.get_messages_snapshot(str(room_uuid))  # type: ignore[attr-defined]
            if snap_chat:
                summary = await _sm(snap_chat, ai_provider, system_prompt=custom_prompt)
        except Exception as e:
            print(f"[summary] Chat snapshot summarize failed room={original_room_id} err={e}")
    # Диагностика: текущее число сообщений (collector пока не очищен)
    pre_count = None
    with contextlib.suppress(Exception):
        pre_count = await collector.message_count(str(room_uuid))  # type: ignore[attr-defined]
    # Если пока summary нет, попробуем второй шанс: объединить voice (если есть) + чат snapshot
    if summary is None:
        try:
            base_snap2 = await collector.get_messages_snapshot(str(room_uuid))  # type: ignore[attr-defined]
            merged2 = base_snap2
            if v and v.text and not v.text.startswith('(no audio'):
                # Добавим неразбитый текст если вдруг разбиение не сработало
                from ...infrastructure.services.summary import ChatMessage as _CM
                import time as _t
                merged2 = list(base_snap2)
                merged2.append(_CM(room_id=str(room_uuid), author_id=None, author_name='voice', content=v.text.strip(), ts=int(_t.time()*1000)))
            if merged2:
                summary = await _sm(merged2, ai_provider, system_prompt=custom_prompt)
                print(f"[summary] Second-chance merge snapshot used room={original_room_id} count={len(merged2)}")
        except Exception as e:
            print(f"[summary] Second-chance summarize failed room={original_room_id} err={e}")
    if summary:
        # Сохраняем архив если его ещё нет (берём актуальный snapshot)
        if room_uuid not in _room_messages_archive:
            with contextlib.suppress(Exception):
                snap_archive = await collector.get_messages_snapshot(str(room_uuid))  # type: ignore[attr-defined]
                if snap_archive:
                    _room_messages_archive[room_uuid] = list(snap_archive)
        # Кладём в кэш
        _room_summary_cache[room_uuid] = summary
        # Формируем набор целевых пользователей: инициатор или владельцы всех агентов
        targets: set[UUID] = set()
        if initiator_user_id:
            targets.add(initiator_user_id)
        else:
            for aid in _room_agents.get(room_uuid, set()):
                owner = _agent_owner.get(aid)
                if owner:
                    targets.add(owner)
        sent_any = False
        if settings.TELEGRAM_BOT_TOKEN and targets:
            for uid in targets:
                if uid in _room_summary_served[room_uuid]:
                    continue
                try:
                    chat_id = None
                    if session is not None:
                        chat_id = await get_confirmed_chat_id(session, uid)
                    if not chat_id:
                        print(f"[summary] Skip send personal user={initiator_user_id} room={original_room_id}: no chat_id")
                        continue
                    text = (
                        f"Room {summary.room_id} завершена (trigger={reason}). Источник: {'voice' if (v and v.text and not v.text.startswith('(no audio')) else 'chat'}. Сообщений: {summary.message_count}.\n--- Summary ---\n{summary.summary_text}"
                    )
                    await tg_send_message(text, chat_ids=[chat_id], session=session)
                    _room_summary_served[room_uuid].add(uid)
                    sent_any = True
                    print(f"[summary] Telegram sent user={uid} room={original_room_id} trigger={reason}")
                except Exception as e:
                    print(f"[summary] Telegram send failed user={uid} room={original_room_id} err={e}")
        if sent_any:
            _room_summary_finalized.add(room_uuid)
    else:
        # Fallback: даже если нет сообщений, отправим минимальное уведомление, чтобы пользователь понял что завершение состоялось
        print(f"[summary] Nothing to summarize room={original_room_id} trigger={reason} pre_count={pre_count}; sending minimal fallback.")
        if settings.TELEGRAM_BOT_TOKEN:
            try:
                minimal = (
                    f"Room {original_room_id} завершена (trigger={reason}). Сообщений не было или они не были зафиксированы."
                )
                chat_ids: list[str] | None = None
                if initiator_user_id and session is not None:
                    single = await get_confirmed_chat_id(session, initiator_user_id)
                    if single:
                        chat_ids = [single]
                await tg_send_message(minimal, chat_ids=chat_ids, session=session)
                print(f"[summary] Minimal fallback Telegram sent for room {original_room_id} trigger={reason}")
            except Exception as e:
                print(f"[summary] Minimal fallback Telegram send failed: {e}")
        # Финализируем чтобы не спамить при повторных попытках
        _room_summary_finalized.add(room_uuid)


@router.websocket("/ws/rooms/{room_id}")
async def ws_room(
    websocket: WebSocket,
    room_id: str,
    bus: SignalBus = Depends(get_signal_bus),
    tokens: TokenProvider = Depends(get_token_provider),
    users: UserRepository = Depends(get_user_repo),
    participants: ParticipantRepository = Depends(get_participant_repo),
    rooms: RoomRepository = Depends(get_room_repo),
        session: AsyncSession = Depends(get_db_session),
):  # type: ignore[override]
    settings = get_settings()
    token = websocket.query_params.get("token")
    is_agent = websocket.query_params.get("agent") in {"1", "true", "yes"}
    allow_unauth = settings.APP_ENV in {"dev", "test"}
    # Принимаем соединение сразу, чтобы при ошибке аутентификации клиент получил корректный close frame,
    # иначе браузер покажет 1006 (abnormal closure)
    await websocket.accept()
    if token:
        try:
            tokens.decode_token(token)
        except Exception:
            if not allow_unauth:
                await websocket.close(code=4401, reason="Unauthorized")
                return
    else:
        if not allow_unauth:
            await websocket.close(code=4401, reason="Unauthorized")
            return
    # Поддержка человекочитаемых room_id: если не UUID, маппим в стабильный UUID v5
    try:
        room_uuid = UUID(room_id)
    except Exception:
        room_uuid = uuid5(NAMESPACE_URL, f"webcall:{room_id}")

    async def sender():
        async for signal in bus.subscribe(room_uuid):
            await websocket.send_json(
                {
                    "type": "signal",
                    "fromUserId": str(signal.sender_id),
                    "signalType": signal.type.value,
                    "sdp": signal.sdp,
                    "candidate": signal.candidate,
                    # передаём target для клиентской фильтрации (если задан)
                    "targetUserId": str(signal.target_id) if getattr(signal, "target_id", None) else None,
                }
            )

    send_task = asyncio.create_task(sender())
    # If Redis is used, also subscribe to chat channel to receive messages from other processes
    chat_task: asyncio.Task | None = None
    chat_channel = f"room:{room_uuid}:chat"
    if isinstance(bus, RedisSignalBus):
        async def chat_listener() -> None:
            pubsub = bus.redis.pubsub()
            await pubsub.subscribe(chat_channel)
            try:
                async for msg in pubsub.listen():
                    if msg.get("type") != "message":
                        continue
                    try:
                        data = json.loads(msg["data"])  # type: ignore[arg-type]
                    except Exception:
                        continue
                    await websocket.send_json({
                        "type": "chat",
                        "authorId": data.get("authorId"),
                        "authorName": data.get("authorName"),
                        "content": data.get("content")
                    })
            finally:
                with contextlib.suppress(Exception):
                    await pubsub.unsubscribe(chat_channel)
                    await pubsub.close()

        chat_task = asyncio.create_task(chat_listener())
    # register connection in room for chat broadcast
    _room_clients[room_uuid].add(websocket)

    collector = get_summary_collector()
    ai_provider = None
    voice_coll = get_voice_collector()
    with contextlib.suppress(Exception):  # AI провайдер не критичен
        ai_provider = get_ai_provider()

    try:
        while True:
            msg = await websocket.receive_text()
            data: dict[str, Any] = json.loads(msg)
            if data.get("type") == "ping":
                # heartbeat
                await websocket.send_json({"type": "pong"})
                continue
            if data.get("type") == "signal":
                raw_t = str(data.get("signalType") or "").strip()
                # Normalize to hyphen style to match SignalType values
                norm_t = raw_t.replace(" ", "").replace("_", "-").lower()
                if norm_t == "icecandidate":
                    norm_t = "ice-candidate"
                try:
                    s = Signal.create(
                        type=norm_t,
                        sender_id=UUID(data.get("fromUserId")),
                        room_id=room_uuid,
                        sdp=data.get("sdp"),
                        candidate=data.get("candidate"),
                        target_id=UUID(data["targetUserId"]) if data.get("targetUserId") else None,
                    )
                except Exception as e:
                    # Do not drop WS on bad input; report error back
                    await websocket.send_json({
                        "type": "error",
                        "message": f"Invalid signalType '{raw_t}': {e.__class__.__name__}"
                    })
                    continue
                try:
                    await bus.publish(room_uuid, s)
                except Exception as e:
                    await websocket.send_json({
                        "type": "error",
                        "message": f"Publish error: {e.__class__.__name__}"
                    })
            elif data.get("type") == "join":
                # Register user presence
                try:
                    conn_id = UUID(data.get("fromUserId"))
                except Exception:
                    # if invalid id, skip presence for this socket
                    continue

                # Если это AI агент – используем детерминированный UUID зависящий от комнаты и пользователя (если есть)
                if is_agent:
                    temp_account_uid: UUID | None = None
                    if token:
                        with contextlib.suppress(Exception):
                            payload = tokens.decode_token(token)
                            uid_str = payload.get("sub")
                            temp_account_uid = UUID(uid_str) if uid_str else None
                    if temp_account_uid:
                        conn_id = uuid5(NAMESPACE_URL, f"webcall:agent:{room_uuid}:{temp_account_uid}")
                    else:
                        conn_id = uuid5(NAMESPACE_URL, f"webcall:agent:{room_uuid}")  # fallback общий
                    data["username"] = data.get("username") or "AI AGENT"

                # Try to attach real username from token subject
                real_name: str | None = None
                account_uid: UUID | None = None
                if token:
                    with contextlib.suppress(Exception):
                        payload = tokens.decode_token(token)
                        # subject is a UUID of user id
                        uid_str = payload.get("sub")
                        uid = UUID(uid_str) if uid_str else None
                        if uid:
                            account_uid = uid
                            user = await users.get_by_id(uid)
                            if user:
                                real_name = user.username

                _ws_conn[websocket] = conn_id
                _room_members[room_uuid].add(conn_id)
                if account_uid:
                    _room_participant_users[room_uuid].add(account_uid)
                uname_base = (data.get("username") or real_name or ("AI AGENT" if is_agent else str(conn_id)[:8]))
                if is_agent and real_name:
                    uname = f"AI-{real_name}"[:32]
                else:
                    uname = uname_base
                _display_names[conn_id] = uname
                if is_agent:
                    _room_agents[room_uuid].add(conn_id)
                    if account_uid is not None:
                        _agent_owner[conn_id] = account_uid
                        # Фиксируем точку старта персонального окна для владельца агента (ms epoch)
                        import time as _t
                        _room_agent_start[(room_uuid, account_uid)] = int(_t.time()*1000)
                        # Регистрируем окно для новой архитектуры orchestrator
                        try:
                            orchestrator = get_summary_orchestrator()
                            await orchestrator.start_user_window(str(room_uuid), str(account_uid))
                        except Exception:
                            pass
                # broadcast presence list to room (with id->name map)
                members = [str(u) for u in sorted(_room_members[room_uuid], key=str)]
                names = { str(uid): _display_names.get(uid, str(uid)[:8]) for uid in _room_members[room_uuid] }
                agent_ids = [str(a) for a in sorted(_room_agents.get(room_uuid, set()), key=str)]
                for ws in list(_room_clients.get(room_uuid, set())):
                    with contextlib.suppress(Exception):
                        await ws.send_json({"type": "presence", "users": members, "userNames": names, "agentIds": agent_ids})

                # Persist visit in DB for authenticated users
                if account_uid is not None:
                    try:
                        # Skip persisting ephemeral call rooms (used for WebRTC calls).
                        # These rooms have a 'call-' prefix in the original path and
                        # should not be stored in visited history or created as
                        # long-lived room records.
                        if (room_id or "").startswith("call-"):
                            # Do not create room meta or participant entries for call rooms
                            # Keep in-memory presence information but skip DB work.
                            continue
                        # Ensure room exists in DB. If not, auto-create with deterministic id
                        room_meta = await rooms.get(room_uuid)
                        if room_meta is None:
                            from ...core.domain.models import Room, Participant, Role
                            from ...core.domain.values import RoomName
                            # Derive a human-friendly name from provided path param
                            safe_name = (room_id or str(room_uuid))[:100]
                            # Create room with fixed UUID = room_uuid so WS and DB align
                            new_room = Room(id=room_uuid, name=RoomName(safe_name), owner_id=account_uid, is_private=False, created_at=datetime.utcnow())
                            try:
                                await rooms.add(new_room)
                            except Exception:
                                # ignore race conditions or duplicates
                                pass
                            # refresh meta
                            room_meta = await rooms.get(room_uuid)

                        if room_meta is not None:
                            # Check if there's already an active participation
                            active = await participants.get_active(room_uuid, account_uid)
                            if not active:
                                from ...core.domain.models import Participant, Role
                                p = Participant.join(user_id=account_uid, room_id=room_uuid, role=Role.member)
                                await participants.add(p)
                    except Exception:
                        # не роняем WS из‑за ошибки БД
                        pass
            elif data.get("type") == "leave":
                # Graceful close to avoid 1005/1006 on client
                with contextlib.suppress(Exception):
                    await websocket.close(code=1000, reason="Client left")
                break
            elif data.get("type") == "chat":
                # Broadcast chat to all participants in room (including sender)
                content = data.get("content")
                author_id = data.get("fromUserId")
                author_name: str | None = _display_names.get(UUID(author_id)) if author_id else None

                # Сбор для последующей выжимки
                with contextlib.suppress(Exception):
                    await collector.add_message(str(room_uuid), author_id, author_name, content or "")
                    # Добавляем в персистентный лог
                    try:
                        from ...infrastructure.services.summary import ChatMessage as _CM
                        import time as _t
                        ts_now = int(_t.time()*1000)
                        _room_message_log[room_uuid].append(_CM(room_id=str(room_uuid), author_id=author_id, author_name=author_name, content=(content or "").strip(), ts=ts_now))
                        # Ограничим лог (хвост) до 2000 сообщений чтобы не рос бесконечно
                        if len(_room_message_log[room_uuid]) > 2000:
                            overflow = len(_room_message_log[room_uuid]) - 2000
                            if overflow > 0:
                                del _room_message_log[room_uuid][0:overflow]
                    except Exception:
                        pass
                    # summary_v2 лог
                    try:
                        orchestrator = get_summary_orchestrator()
                        orchestrator.add_chat(str(room_uuid), author_id, author_name, content or "")
                    except Exception:
                        pass

                if isinstance(bus, RedisSignalBus):
                    # Publish to Redis channel so all processes deliver the message
                    await bus.redis.publish(chat_channel, json.dumps({
                        "fromUserId": author_id,
                        "authorName": author_name,
                        "content": content
                    }))
                else:
                    # In-process fallback (dev/test)
                    payload = {"type": "chat", "fromUserId": author_id, "authorName": author_name, "content": content}
                    dead: list[WebSocket] = []
                    for ws in list(_room_clients.get(room_uuid, set())):
                        try:
                            await ws.send_json(payload)
                        except Exception:
                            dead.append(ws)
                    # cleanup dead connections
                    for ws in dead:
                        with contextlib.suppress(KeyError):
                            _room_clients[room_uuid].remove(ws)
            elif data.get("type") == "agent_summary":
                # Ручной триггер от клиента (второй клик на кнопку AI Agent)
                await websocket.send_json({"type": "agent_summary_ack", "status": "processing"})
                try:
                    before_voice = None
                    with contextlib.suppress(Exception):
                        before_voice = await voice_coll.get_transcript(str(room_uuid)) or await voice_coll.get_transcript(room_id)
                        # user id инициатора попытки (если есть токен и нашли пользователя)
                        initiator_user_id = None
                        with contextlib.suppress(Exception):
                            if token:
                                payload = tokens.decode_token(token)
                                initiator_user_id = UUID(payload.get("sub")) if payload.get("sub") else None
                        await _generate_and_send_summary(room_uuid, room_id, "manual", ai_provider=ai_provider, collector=collector, voice_coll=voice_coll, session=session, initiator_user_id=initiator_user_id)
                    after_voice = None
                    with contextlib.suppress(Exception):
                        after_voice = await voice_coll.get_transcript(str(room_uuid)) or await voice_coll.get_transcript(room_id)
                    src = 'voice' if (before_voice or after_voice) else 'chat'
                    finalized = room_uuid in _room_summary_finalized
                    await websocket.send_json({"type": "agent_summary_ack", "status": "done" if finalized else "empty", "source": src, "finalized": finalized})
                except Exception as e:  # pragma: no cover
                    await websocket.send_json({"type": "agent_summary_ack", "status": "error", "error": str(e)})
                continue
            else:
                await websocket.send_json({"type": "error", "message": "Unknown message"})
    except WebSocketDisconnect:
        pass
    finally:
        send_task.cancel()
        if chat_task:
            chat_task.cancel()
        # В Python 3.11 CancelledError наследуется от BaseException — подавляем явно
        with contextlib.suppress(asyncio.CancelledError):
            await send_task
        if chat_task:
            with contextlib.suppress(asyncio.CancelledError):
                await chat_task
        # unregister connection
        with contextlib.suppress(KeyError):
            _room_clients[room_uuid].remove(websocket)
        # presence cleanup and broadcast
        uid = _ws_conn.pop(websocket, None)
        if uid is not None:
            with contextlib.suppress(KeyError):
                _room_members[room_uuid].remove(uid)
            if uid not in _room_members.get(room_uuid, set()):
                with contextlib.suppress(KeyError):
                    _display_names.pop(uid)
            # cleanup участника (по владельцу агента мы mapping не знаем — оставляем если другие соединения есть)
            # (упрощение: не удаляем из _room_participant_users до конца комнаты)
            # Если это агент — удаляем из структуры агентов
            with contextlib.suppress(Exception):
                if uid in _room_agents.get(room_uuid, set()):
                    _room_agents[room_uuid].remove(uid)
                    if not _room_agents[room_uuid]:
                        _room_agents.pop(room_uuid, None)
                    # Завершаем окно пользователя (если известен владелец)
                    try:
                        owner = _agent_owner.get(uid)
                        if owner:
                            orch = get_summary_orchestrator()
                            orch.end_user_window(str(room_uuid), str(owner))
                    except Exception:
                        pass
                # owner mapping
                if uid in _agent_owner:
                    _agent_owner.pop(uid, None)
            
            members = [str(u) for u in sorted(_room_members[room_uuid], key=str)]
            names = { str(mid): _display_names.get(UUID(mid), mid[:8]) if isinstance(mid, str) else _display_names.get(mid, str(mid)[:8]) for mid in _room_members[room_uuid] }
            agent_ids = [str(a) for a in sorted(_room_agents.get(room_uuid, set()), key=str)]
            for ws in list(_room_clients.get(room_uuid, set())):
                with contextlib.suppress(Exception):
                    await ws.send_json({"type": "presence", "users": members, "userNames": names, "agentIds": agent_ids})

        # try to mark DB participation left_at for authenticated user
        if token:
            with contextlib.suppress(Exception):
                payload = tokens.decode_token(token)
                uid_str = payload.get("sub")
                account_uid = UUID(uid_str) if uid_str else None
                if account_uid is not None:
                    try:
                        # Update only if room exists (consistency with join)
                        room_meta = await rooms.get(room_uuid)
                        if room_meta is not None:
                            active = await participants.get_active(room_uuid, account_uid)
                            if active and not active.left_at:
                                active.left_at = datetime.utcnow()
                                await participants.update(active)
                    except Exception:
                        pass

        # Fallback: если все участники вышли и остался неотправленный транскрипт — попробуем авто summary (auto-orphan)
        try:
            remaining = len(_room_members.get(room_uuid, set()))
            if remaining == 0 and room_uuid not in _room_summary_finalized:
                # Проверяем есть ли транскрипт
                try:
                    vcheck = await voice_coll.get_transcript(str(room_uuid)) or await voice_coll.get_transcript(room_id)
                except Exception:
                    vcheck = None  # type: ignore
                if vcheck:
                    print(f"[summary] Orphan auto trigger room={room_id}")
                    await _generate_and_send_summary(room_uuid, room_id, 'auto-orphan', ai_provider=ai_provider, collector=collector, voice_coll=voice_coll)
        except Exception:
            pass

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\rooms.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\voice_capture.py =====
--- SIZE: 15787 bytes ---

from __future__ import annotations

import contextlib
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends
from ..api.deps.containers import get_token_provider
from ...core.ports.services import TokenProvider
from ...infrastructure.config import get_settings
from ...infrastructure.services.voice_transcript import get_voice_collector, transcribe_chunks
from ...infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator
from uuid import UUID, uuid5, NAMESPACE_URL
import logging

logger = logging.getLogger(__name__)

router = APIRouter()


@router.websocket('/ws/voice_capture/{room_id}')
async def ws_voice_capture(ws: WebSocket, room_id: str, tokens: TokenProvider = Depends(get_token_provider)):
    settings = get_settings()
    if not settings.VOICE_CAPTURE_ENABLED:
        await ws.close(code=4403, reason='Voice capture disabled')
        return
    token = ws.query_params.get('token')
    user_id: str | None = None
    allow_unauth = settings.APP_ENV in {'dev','test'}
    await ws.accept()
    if token:
        try:
            payload = tokens.decode_token(token)
            user_id = payload.get('sub') if isinstance(payload, dict) else None
        except Exception:
            if not allow_unauth:
                await ws.close(code=4401, reason='Unauthorized')
                return
    else:
        if not allow_unauth:
            await ws.close(code=4401, reason='Unauthorized')
            return

    coll = get_voice_collector()
    # Преобразуем room_id в канонический UUID (так же как в rooms.py), чтобы ключи совпадали
    try:
        canonical_uuid = UUID(room_id)
    except Exception:
        canonical_uuid = uuid5(NAMESPACE_URL, f"webcall:{room_id}")
    base_room_key = str(canonical_uuid)
    # Персональный ключ для хранения чанков: room + ':' + user (если присутствует)
    if user_id:
        canonical_key = f"{base_room_key}:{user_id}"
    else:
        canonical_key = base_room_key
    # Сессионные параметры (client → server)
    started = False
    session_id: int | None = None  # порядковый номер сессии (клиентский)
    client_start_ts: int | None = None  # ts из control frame start (клиент)
    start_control_ts: int | None = None  # когда получили start (control или implicit)
    first_chunk_ts: int | None = None
    last_chunk_ts: int | None = None
    total_bytes = 0
    control_start_count = 0
    control_stop_count = 0
    binary_frames = 0
    ignored_early_stops = 0
    loop_iterations = 0
    import time as _t
    accept_ts = int(_t.time()*1000)
    GRACE_AFTER_STOP_MS = 1800  # максимум ждём после stop первый бинарный чанк
    NO_AUDIO_WARN_MS = 2500     # после старта если нет бинарных — шлём предупреждение
    last_warn_sent = False
    stop_requested_ts: int | None = None
    import asyncio
    try:
        while True:
            # Если был stop и ещё нет чанков — ждём ограниченный grace
            if stop_requested_ts and total_bytes == 0:
                now_ms = int(_t.time()*1000)
                if now_ms - stop_requested_ts > GRACE_AFTER_STOP_MS:
                    logger.debug("VOICE_CAPTURE grace timeout after stop room=%s", room_id)
                    break
            # Таймаут чтения чтобы можно было слать no-audio уведомление
            try:
                msg = await asyncio.wait_for(ws.receive(), timeout=1.0)
            except asyncio.TimeoutError:
                # периодический тик
                now_ms = int(_t.time()*1000)
                if started and first_chunk_ts is None and not last_warn_sent and start_control_ts and (now_ms - start_control_ts) > NO_AUDIO_WARN_MS:
                    # Отправим диагностическое сообщение клиенту
                    with contextlib.suppress(Exception):
                        await ws.send_json({"type": "no-audio", "message": "Нет аудиоданных: проверьте доступ к микрофону"})
                    last_warn_sent = True
                    logger.debug("VOICE_CAPTURE warn no-audio room=%s user=%s", room_id, user_id)
                continue
            except RuntimeError:
                # Клиент уже отключился (disconnect получен) — выходим из цикла без stacktrace
                logger.debug("VOICE_CAPTURE receive after disconnect room=%s user=%s", room_id, user_id)
                break
            loop_iterations += 1
            if 'text' in msg and msg['text'] is not None:
                # control frame
                import json
                try:
                    data = json.loads(msg['text'])
                except Exception:
                    continue
                t = data.get('type')
                if t == 'start':
                    started = True
                    import time as _t
                    start_control_ts = int(_t.time()*1000)
                    control_start_count += 1
                    session_id = data.get('session') if isinstance(data.get('session'), int) else None
                    client_start_ts = data.get('ts') if isinstance(data.get('ts'), int) else None
                    logger.debug("VOICE_CAPTURE control start room=%s user=%s session_id=%s client_ts=%s", room_id, user_id, session_id, client_start_ts)
                elif t == 'stop':
                    # Защита: если ещё нет чанков и старт был совсем недавно — игнорируем одиночный stop (например клиент мгновенно пересоздал MediaRecorder)
                    import time as _t
                    now_ms = int(_t.time()*1000)
                    if total_bytes == 0 and started and start_control_ts and (now_ms - start_control_ts) < 800:
                        ignored_early_stops += 1
                        logger.debug("VOICE_CAPTURE ignore early stop (no chunks) room=%s delta_ms=%s", room_id, now_ms - start_control_ts)
                        continue
                    control_stop_count += 1
                    logger.debug("VOICE_CAPTURE control stop room=%s user=%s bytes=%s", room_id, user_id, total_bytes)
                    # Не выходим сразу: ждём grace, если ещё нет чанков
                    if total_bytes == 0:
                        stop_requested_ts = now_ms
                        continue
                    break
            elif 'bytes' in msg and msg['bytes'] is not None:
                if not started:
                    # Автоматический имплицитный старт если клиент не отправил control frame
                    started = True
                    import time as _t
                    start_control_ts = int(_t.time()*1000)
                    logger.debug("VOICE_CAPTURE implicit start room=%s user=%s (binary before explicit start) session_id=%s", room_id, user_id, session_id)
                chunk = msg['bytes']
                total_bytes += len(chunk)
                binary_frames += 1
                if first_chunk_ts is None:
                    import time as _t
                    first_chunk_ts = int(_t.time()*1000)
                    logger.debug("VOICE_CAPTURE first chunk room=%s user=%s size=%s", room_id, user_id, len(chunk))
                import time as _t
                last_chunk_ts = int(_t.time()*1000)
                if total_bytes > settings.VOICE_MAX_TOTAL_MB * 1024 * 1024:
                    # превышение лимита
                    break
                await coll.add_chunk(canonical_key, chunk)
    except WebSocketDisconnect:
        logger.debug("VOICE_CAPTURE disconnect room=%s started=%s bytes=%s", room_id, started, total_bytes)
    finally:
        # Финализируем: транскрипция и сохранение. Если нет чанков — пропускаем.
        with contextlib.suppress(Exception):
            chunks = await coll.get_and_clear_chunks(canonical_key)
            finalize_ts = int(__import__('time').time()*1000)
            text: str
            had_chunks = bool(chunks)
            if had_chunks:
                logger.info("VOICE_CAPTURE finalize room=%s chunks=%s bytes=%s", room_id, len(chunks), sum(len(c.data) for c in chunks))
                raw_text = await transcribe_chunks(canonical_key, chunks)
                cleaned = (raw_text or '').strip()
                try:
                    preview = cleaned[:120].replace('\n',' ')
                    logger.info("VOICE_CAPTURE transcript room=%s preview=%r", room_id, preview)
                except Exception:
                    pass
                # Авто-триггер персонального summary (v2) если есть user_id и включён флаг USE_SUMMARY_V2
                try:
                    import os, asyncio as _aio
                    use_v2 = os.getenv("USE_SUMMARY_V2", "1").lower() not in {"0","false","no"}
                    if user_id and use_v2 and cleaned and not cleaned.startswith('(no audio') and not cleaned.startswith('(asr '):
                        # Отложим чуть, чтобы orchestrator успел прикрепить сегмент
                        async def _delayed_trigger():
                            try:
                                from .rooms import _generate_and_send_summary  # type: ignore
                                from ...infrastructure.services.summary import get_summary_collector
                                from ...infrastructure.services.voice_transcript import get_voice_collector as _gvc
                                from ...infrastructure.services.ai_provider import get_ai_provider as _gap
                                from sqlalchemy.ext.asyncio import AsyncSession
                                # Попытка получить активный db session невозможна отсюда напрямую — авто-режим без session
                                await _aio.sleep(0.4)
                                try:
                                    coll2 = get_summary_collector()
                                except Exception:
                                    coll2 = None
                                try:
                                    vc2 = _gvc()
                                except Exception:
                                    vc2 = None
                                ai_p = _gap()
                                # Определяем канонический UUID как в rooms.py
                                try:
                                    canonical_uuid2 = UUID(room_id)
                                except Exception:
                                    canonical_uuid2 = uuid5(NAMESPACE_URL, f"webcall:{room_id}")
                                # initiator_user_id как UUID
                                u_uuid = None
                                try:
                                    u_uuid = UUID(user_id)
                                except Exception:
                                    pass
                                if u_uuid:
                                    # Попытка открыть краткий DB session чтобы разрешить chat_id при авто-отправке
                                    try:
                                        from ...infrastructure.db.session import AsyncSessionLocal
                                        async with AsyncSessionLocal() as auto_session:  # type: ignore
                                            await _generate_and_send_summary(canonical_uuid2, room_id, "auto-voice", ai_provider=_gap(), collector=coll2, voice_coll=vc2, session=auto_session, initiator_user_id=u_uuid)
                                    except Exception:
                                        # fallback без сессии (только глобальный TELEGRAM_CHAT_ID сработает)
                                        await _generate_and_send_summary(canonical_uuid2, room_id, "auto-voice", ai_provider=_gap(), collector=coll2, voice_coll=vc2, session=None, initiator_user_id=u_uuid)
                            except Exception:
                                logger.debug("VOICE_CAPTURE auto-summary trigger failed room=%s", room_id, exc_info=True)
                        _ = _aio.create_task(_delayed_trigger())
                except Exception:
                    logger.debug("VOICE_CAPTURE auto-summary scheduling failed room=%s", room_id, exc_info=True)
            else:
                cleaned = "(no audio chunks)"
                try:
                    now_ms = finalize_ts
                    delta_start = (now_ms - start_control_ts) if start_control_ts else None
                    logger.info(
                        "VOICE_CAPTURE finalize empty room=%s reason=no_chunks delta_start=%s started=%s ctrl_start=%s ctrl_stop=%s bin_frames=%s ignored_stops=%s loops=%s lifetime_ms=%s grace_after_stop_ms=%s warn_sent=%s",
                        room_id,
                        delta_start,
                        started,
                        control_start_count,
                        control_stop_count,
                        binary_frames,
                        ignored_early_stops,
                        loop_iterations,
                        now_ms - accept_ts,
                        (now_ms - stop_requested_ts) if stop_requested_ts else None,
                        last_warn_sent,
                    )
                except Exception:
                    logger.info("VOICE_CAPTURE finalize empty room=%s reason=no_chunks", room_id)
            # Формируем мету (всегда)
            meta_parts = [f"captureTs={finalize_ts}"]
            if session_id is not None:
                meta_parts.append(f"session={session_id}")
            if client_start_ts is not None:
                meta_parts.append(f"clientTs={client_start_ts}")
            if start_control_ts is not None:
                meta_parts.append(f"startCtrlTs={start_control_ts}")
            meta_prefix = "[meta " + " ".join(meta_parts) + "] "
            text = meta_prefix + cleaned
            # Сохраняем ТОЛЬКО персонально если есть user_id, иначе под room (групповая логика) — мета уже есть
            store_key = canonical_key
            await coll.store_transcript(store_key, text)
            # Немедленно прикрепляем в orchestrator если есть содержательный текст
            try:
                if user_id and cleaned and not cleaned.startswith('(no audio') and not cleaned.startswith('(asr '):
                    orch = get_summary_orchestrator()
                    orch.add_voice_transcript(base_room_key, text, user_id=user_id)
            except Exception:
                logger.debug("VOICE_CAPTURE orchestrator attach failed room=%s", room_id, exc_info=True)
        with contextlib.suppress(Exception):
            await ws.close(code=1000)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\presentation\ws\voice_capture.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\check_users.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\check_users.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\create_superuser.py =====
--- SIZE: 721 bytes ---

import asyncio
from uuid import UUID

from app.infrastructure.db.session import AsyncSessionLocal
from app.infrastructure.db.repositories.users import PgUserRepository
from app.infrastructure.security.password_hasher import BcryptPasswordHasher


async def main():
    async with AsyncSessionLocal() as session:  # type: ignore[misc]
        users = PgUserRepository(session)
        hasher = BcryptPasswordHasher()
        # minimal example: ensure user exists
        from app.core.domain.models import User

        u = User.create("admin@example.com", "admin", hasher.hash("admin"))
        await users.add(u)
        print("Created:", u.id)


if __name__ == "__main__":
    asyncio.run(main())

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\create_superuser.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\reset_password.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\reset_password.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\verify_password.py =====
--- SIZE: 0 bytes ---


===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\verify_password.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\wait_for_db.py =====
--- SIZE: 1483 bytes ---

# app/scripts/wait_for_db.py
from __future__ import annotations

import asyncio
import os
import sys

import asyncpg


def _to_asyncpg_dsn(url: str) -> str:
    """
    Convert SQLAlchemy async URL (postgresql+asyncpg://...) to asyncpg-compatible DSN.
    """
    if url.startswith("postgresql+asyncpg://"):
        return "postgresql://" + url[len("postgresql+asyncpg://") :]
    return url


async def main() -> None:
    # Берём URL из окружения (как в .env). Фолбэк — только для локалки.
    env_url = os.getenv(
        "DATABASE_URL",
        "postgresql+asyncpg://webcall:secret@postgres:5432/webcall",
    )
    dsn = _to_asyncpg_dsn(env_url)

    # Подождём до 60 сек, печатая причину (чтобы было видно в логах почему ждём)
    last_err: Exception | None = None
    for attempt in range(60):
        try:
            conn = await asyncpg.connect(dsn)
            await conn.close()
            print("db ready")
            return
        except Exception as e:
            last_err = e
            print(f"[wait_for_db] attempt {attempt+1}/60: {e!r}")
            await asyncio.sleep(1)

    print("[wait_for_db] database is not ready, aborting", file=sys.stderr)
    if last_err:
        print(f"[wait_for_db] last error: {last_err!r}", file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\scripts\wait_for_db.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\conftest.py =====
--- SIZE: 7875 bytes ---

"""Минимальный тестовый bootstrap.

Цели:
 - Быстрый старт без Alembic (множество head ревизий ломает upgrade)
 - In‑memory SQLite (shared) + create_all из текущих ORM моделей
 - Быстрый PasswordHasher чтобы не тратить время на bcrypt
"""

import asyncio
import os
import sys
from types import SimpleNamespace
from uuid import UUID, uuid4
from typing import Optional

import pytest
from httpx import AsyncClient, ASGITransport

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

os.environ.setdefault('JWT_SECRET', 'test-jwt-secret')
os.environ.setdefault('REGISTRATION_SECRET', 'test-registration')
os.environ.setdefault('DATABASE_URL', 'sqlite+aiosqlite:///file:memdb1?mode=memory&cache=shared')
os.environ.setdefault('REDIS_URL', 'redis://localhost:6379/0')

from app.infrastructure.config import get_settings  # noqa: E402
get_settings.cache_clear()  # type: ignore[attr-defined]
_ = get_settings()

from app.bootstrap.asgi import app  # noqa: E402
from app.presentation.api.deps.containers import get_password_hasher, get_user_repo  # noqa: E402
from app.presentation.api.deps import rate_limit as rate_module  # noqa: E402
from app.core.ports.repositories import UserRepository  # noqa: E402
from app.core.domain.models import User  # noqa: E402
from app.core.domain.values import Email, PasswordHash, Username  # noqa: E402
from app.core.errors import ConflictError  # noqa: E402


class _FastHasher:
    _suffix = '$fakehash'

    def hash(self, password: str) -> str:
        # Вернём стабильный "хеш" достаточно длинный, чтобы пройти валидацию PasswordHash
        return 'h$' + password + self._suffix

    def verify(self, password: str, password_hash: str) -> bool:
        return password_hash == self.hash(password)


class _MemUserRepo(UserRepository):  # type: ignore[misc]
    def __init__(self):
        self._by_id: dict[UUID, User] = {}

    async def get_by_email(self, email: str) -> Optional[User]:  # type: ignore[override]
        for u in self._by_id.values():
            if str(u.email) == email:
                return u
        return None

    async def get_by_username(self, username: str) -> Optional[User]:  # type: ignore[override]
        for u in self._by_id.values():
            if str(u.username) == username:
                return u
        return None

    async def get_by_id(self, user_id: UUID) -> Optional[User]:  # type: ignore[override]
        return self._by_id.get(user_id)

    async def add(self, user: User) -> None:  # type: ignore[override]
        self._by_id[user.id] = user

    async def search(self, query: str, limit: int = 10) -> list[User]:  # type: ignore[override]
        q = query.lower()
        return [u for u in self._by_id.values() if q in str(u.username).lower() or q in str(u.email).lower()][:limit]

    async def update_profile(
        self,
        user_id: UUID,
        *,
        email: str | None = None,
        username: str | None = None,
    ) -> User | None:  # type: ignore[override]
        user = self._by_id.get(user_id)
        if not user:
            return None
        new_email = Email(email) if email is not None else user.email
        new_username = Username(username) if username is not None else user.username
        # проверка конфликтов
        for uid, existing in self._by_id.items():
            if uid == user_id:
                continue
            if email is not None and str(existing.email) == str(new_email):
                raise ConflictError('email taken')
            if username is not None and str(existing.username) == str(new_username):
                raise ConflictError('username taken')
        updated = User(
            id=user.id,
            email=new_email,
            username=new_username,
            password_hash=user.password_hash,
            created_at=user.created_at,
            public_key=user.public_key,
        )
        self._by_id[user_id] = updated
        return updated

    async def update_password(self, user_id: UUID, password_hash: str) -> bool:  # type: ignore[override]
        user = self._by_id.get(user_id)
        if not user:
            return False
        updated = User(
            id=user.id,
            email=user.email,
            username=user.username,
            password_hash=PasswordHash(password_hash),
            created_at=user.created_at,
            public_key=user.public_key,
        )
        self._by_id[user_id] = updated
        return True


_mem_repo = _MemUserRepo()
_test_hasher = _FastHasher()
app.dependency_overrides[get_password_hasher] = lambda: _test_hasher
app.dependency_overrides[get_user_repo] = lambda: _mem_repo


# Создание схемы (для остальных репозиториев, если тесты их коснутся)
async def _init_schema():
    from app.infrastructure.db.session import ENGINE  # noqa: E402
    from app.infrastructure.db.base import Base  # noqa: E402
    from app.infrastructure import db as _models_import  # noqa: F401,E402
    async with ENGINE.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


asyncio.run(_init_schema())


@pytest.fixture(scope='session')
def anyio_backend():
    return 'asyncio'


@pytest.fixture()
async def client():
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as ac:
        yield ac


@pytest.fixture()
async def async_client(client):
    # Некоторые тесты ожидают фикстуру async_client — сделаем алиас поверх client
    yield client


@pytest.fixture(autouse=True)
def reset_rate_limits():
    rate_module._login_limiter.events.clear()
    rate_module._register_limiter.events.clear()
    rate_module._room_create_limiter.events.clear()
    yield
    rate_module._login_limiter.events.clear()
    rate_module._register_limiter.events.clear()
    rate_module._room_create_limiter.events.clear()


def _unique_credentials(prefix: str = "user") -> tuple[str, str, str]:
    suffix = uuid4().hex[:8]
    email = f"{prefix}-{suffix}@example.com"
    username = f"{prefix}_{suffix}"
    password = f"pass{suffix}"
    return email, username, password


async def _ensure_registered(client: AsyncClient, email: str, username: str, password: str) -> None:
    secret = os.getenv('REGISTRATION_SECRET', 'test-registration')
    resp = await client.post(
        '/api/v1/auth/register',
        json={'email': email, 'username': username, 'password': password, 'secret': secret},
    )
    if resp.status_code not in (200, 201, 409):
        raise AssertionError(f"registration failed: {resp.status_code} {resp.text}")


@pytest.fixture()
async def registered_user_token(async_client: AsyncClient) -> str:
    email, username, password = _unique_credentials('primary')
    await _ensure_registered(async_client, email, username, password)
    login = await async_client.post('/api/v1/auth/login', json={'email': email, 'password': password})
    assert login.status_code == 200, login.text
    data = login.json()
    token = data.get('access_token')
    assert token, data
    return token


@pytest.fixture()
async def second_user(async_client: AsyncClient) -> SimpleNamespace:
    email, username, password = _unique_credentials('secondary')
    await _ensure_registered(async_client, email, username, password)
    return SimpleNamespace(email=email, username=username, password=password)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\conftest.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_auth.py =====
--- SIZE: 88 bytes ---

import pytest


@pytest.mark.asyncio
async def test_dummy_auth():
    assert True

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_auth.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_direct_crypto.py =====
--- SIZE: 649 bytes ---

import pytest
from uuid import uuid4

from app.infrastructure.services.direct_crypto import encrypt_direct, decrypt_direct


def test_encrypt_decrypt_roundtrip():
    a = uuid4()
    b = uuid4()
    text = "Hello, secret"
    ct = encrypt_direct(a, b, text)
    assert ct != text
    pt = decrypt_direct(a, b, ct)
    assert pt == text


def test_decrypt_with_wrong_pair_fails():
    a = uuid4()
    b = uuid4()
    c = uuid4()
    text = "Another secret"
    ct = encrypt_direct(a, b, text)
    # decrypt with a different participant (c) should raise
    with pytest.raises(Exception):
        _ = decrypt_direct(a, c, ct)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_direct_crypto.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_friends_push.py =====
--- SIZE: 1435 bytes ---

import os
import uuid
import pytest
from httpx import AsyncClient


async def _register_and_login(client: AsyncClient, email: str, username: str, password: str, secret: str) -> str:
    r = await client.post('/api/v1/auth/register', json={"email": email, "username": username, "password": password, "secret": secret})
    assert r.status_code in (200, 201, 409)
    r = await client.post('/api/v1/auth/login', json={"email": email, "password": password})
    assert r.status_code == 200
    return r.json()["access_token"]


@pytest.mark.anyio
@pytest.mark.skipif('DATABASE_URL' not in os.environ, reason='DATABASE_URL not configured')
async def test_friend_request_flow(client: AsyncClient, monkeypatch):
    secret = os.getenv('REGISTRATION_SECRET', 'testsecret')
    t1 = await _register_and_login(client, 'a@example.com', 'usera', 'pass123', secret)
    t2 = await _register_and_login(client, 'b@example.com', 'userb', 'pass123', secret)

    # get user2 id via /api? not exposed; skip and assume backend allows by username — this is an example only
    # For now, just ensure endpoints exist
    assert (await client.get('/api/v1/friends/', headers={"Authorization": f"Bearer {t1}"})).status_code in (200, 401, 403)


@pytest.mark.anyio
async def test_push_subscribe_endpoint_exists(client: AsyncClient):
    r = await client.get('/api/v1/push/vapid-public')
    assert r.status_code in (200, 404)

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_friends_push.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_profile.py =====
--- SIZE: 1230 bytes ---

import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_update_profile_success(async_client: AsyncClient, registered_user_token):
    headers = { 'Authorization': f'Bearer {registered_user_token}' }
    r = await async_client.patch('/api/v1/auth/me', json={'username':'newname123'}, headers=headers)
    assert r.status_code == 200, r.text
    data = r.json()
    assert data['username'] == 'newname123'

@pytest.mark.asyncio
async def test_update_profile_conflict(async_client: AsyncClient, registered_user_token, second_user):
    # Попытка установить username второго пользователя
    headers = { 'Authorization': f'Bearer {registered_user_token}' }
    r = await async_client.patch('/api/v1/auth/me', json={'username': second_user.username}, headers=headers)
    assert r.status_code == 409

@pytest.mark.asyncio
async def test_change_password_wrong_old(async_client: AsyncClient, registered_user_token):
    headers = { 'Authorization': f'Bearer {registered_user_token}' }
    r = await async_client.post('/api/v1/auth/me/password', json={'old_password':'WRONG','new_password':'newpass123'}, headers=headers)
    assert r.status_code == 400

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_profile.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_registration_secret.py =====
--- SIZE: 2007 bytes ---

import os
import pytest
from httpx import AsyncClient
from fastapi import status

from app.bootstrap.asgi import app  # use absolute import; asgi instantiates application


@pytest.mark.asyncio
@pytest.mark.skipif('DATABASE_URL' not in os.environ, reason='DATABASE_URL not configured')
async def test_register_forbidden_without_or_wrong_secret(monkeypatch):
    monkeypatch.setenv('REGISTRATION_SECRET', 'abc123')
    from app.infrastructure.config import get_settings
    get_settings.cache_clear()  # type: ignore[attr-defined]
    assert get_settings().REGISTRATION_SECRET == 'abc123'

    async with AsyncClient(app=app, base_url='http://test') as ac:
        # missing secret
        r1 = await ac.post('/api/v1/auth/register', json={
            'email': 'mw1@example.com', 'username': 'mw1', 'password': 'password'
        })
        assert r1.status_code == status.HTTP_422_UNPROCESSABLE_ENTITY or r1.status_code == status.HTTP_403_FORBIDDEN
        # wrong secret
        r2 = await ac.post('/api/v1/auth/register', json={
            'email': 'mw2@example.com', 'username': 'mw2', 'password': 'password', 'secret': 'wrong'
        })
        assert r2.status_code == status.HTTP_403_FORBIDDEN
        assert 'secret' in r2.text.lower()


@pytest.mark.asyncio
@pytest.mark.skipif('DATABASE_URL' not in os.environ, reason='DATABASE_URL not configured')
async def test_register_success_with_secret(monkeypatch):
    monkeypatch.setenv('REGISTRATION_SECRET', 'abc123')
    from app.infrastructure.config import get_settings

    get_settings.cache_clear()  # type: ignore[attr-defined]

    async with AsyncClient(app=app, base_url='http://test') as ac:
        r = await ac.post('/api/v1/auth/register', json={
            'email': 'user2@example.com', 'username': 'user2', 'password': 'password', 'secret': 'abc123'
        })
        assert r.status_code == status.HTTP_201_CREATED, r.text
        data = r.json()
    assert data['username'] == 'user2'

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_registration_secret.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_rooms.py =====
--- SIZE: 89 bytes ---

import pytest


@pytest.mark.asyncio
async def test_dummy_rooms():
    assert True

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_rooms.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_ws_basic.py =====
--- SIZE: 710 bytes ---

import pytest
from starlette.testclient import TestClient
from app.bootstrap.asgi import app
import os


@pytest.mark.asyncio
async def test_ws_basic(monkeypatch):
    # Гарантируем режим test чтобы ws endpoint разрешал соединение без токена
    monkeypatch.setenv("APP_ENV", "test")
    from app.infrastructure.config import get_settings
    get_settings.cache_clear()  # type: ignore[attr-defined]
    client = TestClient(app)
    with client.websocket_connect("/ws/rooms/00000000-0000-0000-0000-000000000001") as ws:
        ws.send_json({"type": "chat", "content": "hi"})
        msg = ws.receive_json()
        assert msg["type"] == "chat"

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests\test_ws_basic.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests_e2e\test_signaling_smoke.py =====
--- SIZE: 4318 bytes ---

from __future__ import annotations

import asyncio
import json
import os
import uuid
import pytest
import websockets
import httpx

BASE = os.getenv("BASE_URL", "http://localhost:8000")
WS_BASE = BASE.replace("http", "ws")
REGISTER_SECRET = os.getenv("REG_SECRET", "devsecret")  # для локального запуска

pytestmark = pytest.mark.signaling

async def register(email: str, username: str, password: str) -> str:
    async with httpx.AsyncClient(timeout=10) as client:
        r = await client.post(f"{BASE}/api/v1/auth/register", json={
            "email": email,
            "username": username,
            "password": password,
            "secret": REGISTER_SECRET,
        })
        if r.status_code not in (200, 201):
            # Возможно уже существует — пробуем логин
            r = await client.post(f"{BASE}/api/v1/auth/login", json={
                "email": email,
                "password": password,
            })
        r.raise_for_status()
        data = r.json()
        return data["access_token"] if "access_token" in data else data.get("token")

async def ws_friends(token: str):
    url = f"{WS_BASE}/ws/friends?token={token}"
    return await websockets.connect(url, ping_interval=None)  # noqa: S113 (test code)

@pytest.mark.asyncio
async def test_invite_accept_flow():
    # Skip if server is not running (e.g. unit test run without external uvicorn)
    try:
        async with httpx.AsyncClient(timeout=2) as client:
            pong = await client.get(f"{BASE}/healthz")
            if pong.status_code != 200:
                pytest.skip("health endpoint not 200")
    except Exception:
        pytest.skip("signaling backend not available on BASE_URL")
    email_a = f"a_{uuid.uuid4().hex[:6]}@test.local"
    email_b = f"b_{uuid.uuid4().hex[:6]}@test.local"
    token_a, token_b = await asyncio.gather(
        register(email_a, "alice", "pass1234"),
        register(email_b, "bob", "pass1234"),
    )

    ws_a, ws_b = await asyncio.gather(ws_friends(token_a), ws_friends(token_b))

    room_id = f"call-{uuid.uuid4().hex[:8]}"

    # Отправляем notify-call (имитация исходящего приглашения)
    async with httpx.AsyncClient(timeout=10) as client:
        r = await client.post(
            f"{BASE}/api/v1/push/notify-call", json={"to_user_id": json.loads(await ws_b.recv()).get('userId', '') or ''}, headers={"Authorization": f"Bearer {token_a}"}
        )  # Эта строка может быть адаптирована — зависит от реальной схемы получения ID.

    # Упрощённо: слушаем несколько сообщений и ищем call_invite
    invite_msg = None
    for _ in range(10):
        raw = await asyncio.wait_for(ws_b.recv(), timeout=5)
        msg = json.loads(raw)
        if msg.get("type") == "call_invite":
            invite_msg = msg
            break
    assert invite_msg, "Did not receive call_invite"

    # Закрываем
    await ws_a.close()
    await ws_b.close()

# Нагрузочный простой тест (опционально можно отдельно запускать)
@pytest.mark.asyncio
async def test_room_presence_load():
    try:
        async with httpx.AsyncClient(timeout=2) as client:
            pong = await client.get(f"{BASE}/healthz")
            if pong.status_code != 200:
                pytest.skip("health endpoint not 200")
    except Exception:
        pytest.skip("signaling backend not available on BASE_URL")
    # Этот тест можно пометить как xfail/slow при необходимости.
    token = await register(f"load_{uuid.uuid4().hex[:6]}@test.local", "load", "pass1234")
    room = f"load-{uuid.uuid4().hex[:6]}"
    N = 5  # увеличить до 30-50 в реальной нагрузке
    url = f"{WS_BASE}/ws/rooms/{room}?token={token}"
    conns = []
    for _ in range(N):
        ws = await websockets.connect(url, ping_interval=None)  # noqa: S113
        conns.append(ws)
    # Ждём немного присутствий
    await asyncio.sleep(2)
    for ws in conns:
        await ws.close()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\app\tests_e2e\test_signaling_smoke.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml =====
--- SIZE: 3867 bytes ---

services:
  api:
    build:
      context: .
      dockerfile: docker/api.Dockerfile
    env_file:
      - .env
    environment:
      # Включаем AI summary и разбивку по участникам (можно переопределить в .env)
      AI_SUMMARY_ENABLED: "1"
      AI_SUMMARY_PARTICIPANT_BREAKDOWN: "1"
    ports:
      - "8000:8000" # для локальной проверки, Nginx ходит на 127.0.0.1:8000
    depends_on:
      - postgres
      - redis
      - coturn
    command: ["sh", "-lc", "python app/scripts/wait_for_db.py && alembic upgrade head && uvicorn app.bootstrap.asgi:app --host 0.0.0.0 --port 8000"]
    # NOTE: In production we intentionally DO NOT mount the host source into the container
    # because it would overwrite files that were copied into the image during build (including bundle.js).
    # For local development you can add a volume mapping manually (e.g. - ./:/app) in your compose override.

  postgres:
    image: postgres:16
    environment:
      POSTGRES_USER: webcall
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
      POSTGRES_DB: webcall
    ports:
      - "127.0.0.1:5432:5432"
    volumes:
      - pgdata:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "127.0.0.1:6379:6379"
    volumes:
      - redisdata:/data

  coturn:
    image: coturn/coturn:latest
    restart: unless-stopped
    environment:
      - TURN_REALM=${TURN_REALM}
      - TURN_USERNAME=${TURN_USERNAME}
      - TURN_PASSWORD=${TURN_PASSWORD}
      - TURN_PUBLIC_IP=${TURN_PUBLIC_IP}
      - TURN_CLI_PASSWORD=${TURN_CLI_PASSWORD:-changeme}
    # Передаём параметры явно: coturn не интерполирует переменные в конфиге
    command: ["/bin/sh","-c","turnserver -c /etc/coturn/turnserver.conf --log-file=stdout -n --realm=$TURN_REALM --user=$TURN_USERNAME:$TURN_PASSWORD ${TURN_PUBLIC_IP:+--external-ip=$TURN_PUBLIC_IP} --cli-password=$TURN_CLI_PASSWORD"]
    ports:
      - "3478:3478/udp"
      - "3478:3478/tcp"
      - "49152-49200:49152-49200/udp"
      # - "9641:9641" # (опционально) Prometheus metrics if enabled
    volumes:
      - ./docker/turnserver.conf:/etc/coturn/turnserver.conf:ro
      # - ./certs:/certs:ro  # (опционально) TLS certs for TURN

  prometheus:
    image: prom/prometheus:v2.53.0
    restart: unless-stopped
    depends_on:
      - api
    command:
      - --config.file=/etc/prometheus/prometheus.yml
      # Уменьшаем retention по времени и ограничиваем размер БД, чтобы не съесть весь диск на малом VPS
      - --storage.tsdb.retention.time=3d
      - --storage.tsdb.retention.size=512MB
      # (Опционально можно ещё добавить: --query.lookback-delta=30m для снижения нагрузки)
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      # Выделяем отдельный именованный volume для данных Prometheus (по умолчанию /prometheus)
      - prometheus-data:/prometheus
    ports:
      - "127.0.0.1:9090:9090"

  grafana:
    image: grafana/grafana:11.2.0
    restart: unless-stopped
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_ADMIN_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
    depends_on:
      - prometheus
    ports:
      - "3000:3000"
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana/datasources:/etc/grafana/provisioning/datasources:ro
      - ./monitoring/grafana/dashboards:/etc/grafana/provisioning/dashboards:ro

volumes:
  pgdata:
  redisdata:
  grafana-data:
  prometheus-data:

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker-compose.yml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.Dockerfile =====
--- SIZE: 1789 bytes ---

# syntax=docker/dockerfile:1
## Build frontend in a node stage, then copy into python image
FROM node:20-alpine AS nodebuilder
WORKDIR /build
# copy dependency manifests
COPY package.json package-lock.json ./
# install dependencies deterministically
RUN apk add --no-cache libc6-compat \
    && npm ci --silent
# copy frontend sources (only the static JS folder to keep context small)
COPY app/presentation/static/js ./app/presentation/static/js
# debug list sources (can be removed later)
RUN find app/presentation/static/js -maxdepth 2 -type f -print
# build bundles (script defined in package.json)
RUN npm run build

FROM python:3.11-slim AS base

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=on \
    PYTHONPATH=/app

WORKDIR /app

# System deps
RUN apt-get update && apt-get install -y --no-install-recommends build-essential libpq-dev curl && rm -rf /var/lib/apt/lists/*

# Install Poetry
ENV POETRY_HOME=/opt/poetry \
    POETRY_VERSION=1.8.3
ENV PATH="$POETRY_HOME/bin:$PATH"
RUN curl -sSL https://install.python-poetry.org | python3 - && poetry --version

# Copy only dependency manifest first (README не обязателен на этом слое)
COPY pyproject.toml ./
RUN poetry config virtualenvs.create false \
    && poetry install --no-interaction --no-ansi --with dev

COPY . .

# Copy built frontend bundle from node stage (if present) into static folder
COPY --from=nodebuilder /build/app/presentation/static/js/bundle.js ./app/presentation/static/js/bundle.js
COPY --from=nodebuilder /build/app/presentation/static/js/api.bundle.js ./app/presentation/static/js/api.bundle.js

EXPOSE 8000

CMD ["uvicorn", "app.bootstrap.asgi:app", "--host", "0.0.0.0", "--port", "8000"]

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.Dockerfile =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.prod.Dockerfile =====
--- SIZE: 2671 bytes ---

# syntax=docker/dockerfile:1
# Multi-stage production Dockerfile

#############################
# Frontend build (JS bundles)
#############################
FROM node:20-alpine AS frontend
WORKDIR /src
COPY package.json package-lock.json ./
RUN npm ci --silent
COPY app/presentation/static/js ./app/presentation/static/js
RUN npm run build

#############################
# Python deps build layer
#############################
FROM python:3.11-slim AS pydeps
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1 PIP_DISABLE_PIP_VERSION_CHECK=on
WORKDIR /app
# System build deps only for wheels compilation
RUN apt-get update && apt-get install -y --no-install-recommends build-essential libpq-dev curl \
    && rm -rf /var/lib/apt/lists/*
COPY pyproject.toml ./
# Use pip instead of poetry export (simpler) – could also: poetry export -f requirements.txt
RUN pip install --no-cache-dir poetry==1.8.3 \
    && poetry export -f requirements.txt --without-hashes -o requirements.txt \
    && pip install --no-cache-dir -r requirements.txt \
    && mkdir /install && cp -r /usr/local/lib/python3.11/site-packages /install/site-packages && cp -r /usr/local/bin /install/bin

#############################
# Final runtime image
#############################
FROM python:3.11-slim AS runtime
ENV PYTHONDONTWRITEBYTECODE=1 PYTHONUNBUFFERED=1 PYTHONPATH=/app
WORKDIR /app
# Minimal runtime system libs
RUN apt-get update && apt-get install -y --no-install-recommends libpq5 curl \
    && rm -rf /var/lib/apt/lists/* \
    && groupadd -r app && useradd -r -g app app
# Copy installed deps
COPY --from=pydeps /install/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=pydeps /install/bin /usr/local/bin
# Copy application code (only what is needed)
COPY app ./app
COPY alembic ./alembic
COPY alembic.ini ./
COPY pyproject.toml ./
COPY monitoring ./monitoring
COPY docker ./docker
# Copy built frontend bundles
COPY --from=frontend /src/app/presentation/static/js/bundle.js ./app/presentation/static/js/bundle.js
COPY --from=frontend /src/app/presentation/static/js/api.bundle.js ./app/presentation/static/js/api.bundle.js
# Create non-root ownership
RUN chown -R app:app /app
USER app
EXPOSE 8000
# Healthcheck (simple)
HEALTHCHECK --interval=30s --timeout=5s --retries=3 CMD curl -fsS http://localhost:8000/healthz || exit 1
# Run with multiple workers via gunicorn
# WEB_CONCURRENCY can be tuned (e.g. 2-4) depending on CPU
ENV WEB_CONCURRENCY=2
CMD gunicorn app.bootstrap.asgi:app -k uvicorn.workers.UvicornWorker -w ${WEB_CONCURRENCY} -b 0.0.0.0:8000 --graceful-timeout 30 --timeout 60 --log-level info

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\api.prod.Dockerfile =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\turnserver.conf =====
--- SIZE: 935 bytes ---

# turnserver.conf (generated quick config)
listening-port=3478
lt-cred-mech
fingerprint

# Min/max relay ports (match docker-compose published range)
min-port=49152
max-port=49200

# Certificates (optional; if mounted). Comment out if not using TLS yet.
# cert=/certs/turn_server_cert.pem
# pkey=/certs/turn_server_pkey.pem

# Prometheus metrics (coturn >= 4.6 supports)
prometheus
# By default export on 9641 (can be scraped via host network mapping if added in compose)

# Enable verbose logging only when debugging
# verbose

# CLI password задаётся через командную строку контейнера (docker-compose) и не фиксируется в конфиге

no-tlsv1
no-tlsv1_1

# Disallow loopback peers
no-loopback-peers
# Disallow loopback relay
no-loopback-relays

# Deny peers (example)
# denied-peer-ip=10.0.0.0-10.255.255.255

# Exit if no configuration issue

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\docker\turnserver.conf =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\monitoring\grafana\dashboards\webcall-overview.json =====
--- SIZE: 1255 bytes ---

{
  "dashboard": {
    "id": null,
    "uid": "webcall-overview",
    "title": "WebCall Overview",
    "tags": ["webcall"],
    "timezone": "browser",
    "schemaVersion": 39,
    "version": 1,
    "refresh": "30s",
    "panels": [
      {
        "type": "graph",
        "title": "HTTP Requests /s",
        "targets": [
          {"expr": "rate(app_requests_total[5m])", "legendFormat": "{{method}} {{status}}"}
        ],
        "id": 1
      },
      {
        "type": "graph",
        "title": "Request latency p95 (ms)",
        "targets": [
          {"expr": "histogram_quantile(0.95, sum(rate(app_request_latency_ms_bucket[5m])) by (le, method, path))", "legendFormat": "{{method}} {{path}}"}
        ],
        "id": 2
      },
      {
        "type": "graph",
        "title": "Active WS Connections",
        "targets": [
          {"expr": "sum(ws_active) by (channel)", "legendFormat": "{{channel}}"}
        ],
        "id": 3
      },
      {
        "type": "graph",
        "title": "Call signaling events rate",
        "targets": [
          {"expr": "rate(call_signal_events_total[5m])", "legendFormat": "{{event}}"}
        ],
        "id": 4
      }
    ]
  },
  "overwrite": true
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\monitoring\grafana\dashboards\webcall-overview.json =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\monitoring\grafana\datasources\prometheus.yml =====
--- SIZE: 169 bytes ---

apiVersion: 1

datasources:
  - name: Prometheus
    type: prometheus
    access: proxy
    url: http://prometheus:9090
    isDefault: true
    editable: false

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\monitoring\grafana\datasources\prometheus.yml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\monitoring\prometheus.yml =====
--- SIZE: 189 bytes ---

global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'webcall_api'
    metrics_path: /metrics
    static_configs:
      - targets: ['api:8000']

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\monitoring\prometheus.yml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\package-lock.json =====
--- SIZE: 73408 bytes ---

{
  "name": "webcall-static-build",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "webcall-static-build",
      "version": "1.0.0",
      "devDependencies": {
        "@types/node": "^20.0.0",
        "esbuild": "^0.22.0",
        "jsdom": "^27.0.0",
        "vitest": "^2.0.0"
      }
    },
    "node_modules/@asamuzakjp/css-color": {
      "version": "4.0.4",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/css-color/-/css-color-4.0.4.tgz",
      "integrity": "sha512-cKjSKvWGmAziQWbCouOsFwb14mp1betm8Y7Fn+yglDMUUu3r9DCbJ9iJbeFDenLMqFbIMC0pQP8K+B8LAxX3OQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@csstools/css-calc": "^2.1.4",
        "@csstools/css-color-parser": "^3.0.10",
        "@csstools/css-parser-algorithms": "^3.0.5",
        "@csstools/css-tokenizer": "^3.0.4",
        "lru-cache": "^11.1.0"
      }
    },
    "node_modules/@asamuzakjp/dom-selector": {
      "version": "6.5.5",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/dom-selector/-/dom-selector-6.5.5.tgz",
      "integrity": "sha512-kI2MX9pmImjxWT8nxDZY+MuN6r1jJGe7WxizEbsAEPB/zxfW5wYLIiPG1v3UKgEOOP8EsDkp0ZL99oRFAdPM8g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/nwsapi": "^2.3.9",
        "bidi-js": "^1.0.3",
        "css-tree": "^3.1.0",
        "is-potential-custom-element-name": "^1.0.1"
      }
    },
    "node_modules/@asamuzakjp/nwsapi": {
      "version": "2.3.9",
      "resolved": "https://registry.npmjs.org/@asamuzakjp/nwsapi/-/nwsapi-2.3.9.tgz",
      "integrity": "sha512-n8GuYSrI9bF7FFZ/SjhwevlHc8xaVlb/7HmHelnc/PZXBD2ZR49NnN9sMMuDdEGPeeRQ5d0hqlSlEpgCX3Wl0Q==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@csstools/color-helpers": {
      "version": "5.1.0",
      "resolved": "https://registry.npmjs.org/@csstools/color-helpers/-/color-helpers-5.1.0.tgz",
      "integrity": "sha512-S11EXWJyy0Mz5SYvRmY8nJYTFFd1LCNV+7cXyAgQtOOuzb4EsgfqDufL+9esx72/eLhsRdGZwaldu/h+E4t4BA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT-0",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@csstools/css-calc": {
      "version": "2.1.4",
      "resolved": "https://registry.npmjs.org/@csstools/css-calc/-/css-calc-2.1.4.tgz",
      "integrity": "sha512-3N8oaj+0juUw/1H3YwmDDJXCgTB1gKU6Hc/bB502u9zR0q2vd786XJH9QfrKIEgFlZmhZiq6epXl4rHqhzsIgQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "@csstools/css-parser-algorithms": "^3.0.5",
        "@csstools/css-tokenizer": "^3.0.4"
      }
    },
    "node_modules/@csstools/css-color-parser": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/@csstools/css-color-parser/-/css-color-parser-3.1.0.tgz",
      "integrity": "sha512-nbtKwh3a6xNVIp/VRuXV64yTKnb1IjTAEEh3irzS+HkKjAOYLTGNb9pmVNntZ8iVBHcWDA2Dof0QtPgFI1BaTA==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "@csstools/color-helpers": "^5.1.0",
        "@csstools/css-calc": "^2.1.4"
      },
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "@csstools/css-parser-algorithms": "^3.0.5",
        "@csstools/css-tokenizer": "^3.0.4"
      }
    },
    "node_modules/@csstools/css-parser-algorithms": {
      "version": "3.0.5",
      "resolved": "https://registry.npmjs.org/@csstools/css-parser-algorithms/-/css-parser-algorithms-3.0.5.tgz",
      "integrity": "sha512-DaDeUkXZKjdGhgYaHNJTV9pV7Y9B3b644jCLs9Upc3VeNGg6LWARAT6O+Q+/COo+2gg/bM5rhpMAtf70WqfBdQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "@csstools/css-tokenizer": "^3.0.4"
      }
    },
    "node_modules/@csstools/css-syntax-patches-for-csstree": {
      "version": "1.0.14",
      "resolved": "https://registry.npmjs.org/@csstools/css-syntax-patches-for-csstree/-/css-syntax-patches-for-csstree-1.0.14.tgz",
      "integrity": "sha512-zSlIxa20WvMojjpCSy8WrNpcZ61RqfTfX3XTaOeVlGJrt/8HF3YbzgFZa01yTbT4GWQLwfTcC3EB8i3XnB647Q==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT-0",
      "engines": {
        "node": ">=18"
      },
      "peerDependencies": {
        "postcss": "^8.4"
      }
    },
    "node_modules/@csstools/css-tokenizer": {
      "version": "3.0.4",
      "resolved": "https://registry.npmjs.org/@csstools/css-tokenizer/-/css-tokenizer-3.0.4.tgz",
      "integrity": "sha512-Vd/9EVDiu6PPJt9yAh6roZP6El1xHrdvIVGjyBsHR0RYwNHgL7FJPyIIW4fANJNG6FtyZfvlRPpFI4ZM/lubvw==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/csstools"
        },
        {
          "type": "opencollective",
          "url": "https://opencollective.com/csstools"
        }
      ],
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@esbuild/win32-x64": {
      "version": "0.22.0",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/@jridgewell/sourcemap-codec": {
      "version": "1.5.5",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@rollup/rollup-win32-x64-msvc": {
      "version": "4.51.0",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/@types/estree": {
      "version": "1.0.8",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/@types/node": {
      "version": "20.19.17",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "undici-types": "~6.21.0"
      }
    },
    "node_modules/@vitest/expect": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "2.1.9",
        "@vitest/utils": "2.1.9",
        "chai": "^5.1.2",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/mocker": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/spy": "2.1.9",
        "estree-walker": "^3.0.3",
        "magic-string": "^0.30.12"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "msw": "^2.4.9",
        "vite": "^5.0.0"
      },
      "peerDependenciesMeta": {
        "msw": {
          "optional": true
        },
        "vite": {
          "optional": true
        }
      }
    },
    "node_modules/@vitest/pretty-format": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/runner": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/utils": "2.1.9",
        "pathe": "^1.1.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/snapshot": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "2.1.9",
        "magic-string": "^0.30.12",
        "pathe": "^1.1.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/spy": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tinyspy": "^3.0.2"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/@vitest/utils": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/pretty-format": "2.1.9",
        "loupe": "^3.1.2",
        "tinyrainbow": "^1.2.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/agent-base": {
      "version": "7.1.4",
      "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-7.1.4.tgz",
      "integrity": "sha512-MnA+YT8fwfJPgBx3m60MNqakm30XOkyIoH1y6huTQvC0PwZG7ki8NacLBcrPbNoo8vEZy7Jpuk7+jMO+CUovTQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/assertion-error": {
      "version": "2.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/bidi-js": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/bidi-js/-/bidi-js-1.0.3.tgz",
      "integrity": "sha512-RKshQI1R3YQ+n9YJz2QQ147P66ELpa1FQEg20Dk8oW9t2KgLbpDLLp9aGZ7y8WHSshDknG0bknqGw5/tyCs5tw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "require-from-string": "^2.0.2"
      }
    },
    "node_modules/cac": {
      "version": "6.7.14",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/chai": {
      "version": "5.3.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "assertion-error": "^2.0.1",
        "check-error": "^2.1.1",
        "deep-eql": "^5.0.1",
        "loupe": "^3.1.0",
        "pathval": "^2.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/chai/node_modules/deep-eql": {
      "version": "5.0.2",
      "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-5.0.2.tgz",
      "integrity": "sha512-h5k/5U50IJJFpzfL6nO9jaaumfjO/f2NjK/oYB2Djzm4p9L+3T9qWpZqZ2hAbLPuuYq9wrU08WQyBTL5GbPk5Q==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/check-error": {
      "version": "2.1.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 16"
      }
    },
    "node_modules/css-tree": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/css-tree/-/css-tree-3.1.0.tgz",
      "integrity": "sha512-0eW44TGN5SQXU1mWSkKwFstI/22X2bG1nYzZTYMAWjylYURhse752YgbE4Cx46AC+bAvI+/dYTPRk1LqSUnu6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "mdn-data": "2.12.2",
        "source-map-js": "^1.0.1"
      },
      "engines": {
        "node": "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      }
    },
    "node_modules/cssstyle": {
      "version": "5.3.0",
      "resolved": "https://registry.npmjs.org/cssstyle/-/cssstyle-5.3.0.tgz",
      "integrity": "sha512-RveJPnk3m7aarYQ2bJ6iw+Urh55S6FzUiqtBq+TihnTDP4cI8y/TYDqGOyqgnG1J1a6BxJXZsV9JFSTulm9Z7g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/css-color": "^4.0.3",
        "@csstools/css-syntax-patches-for-csstree": "^1.0.14",
        "css-tree": "^3.1.0"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/data-urls": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/data-urls/-/data-urls-6.0.0.tgz",
      "integrity": "sha512-BnBS08aLUM+DKamupXs3w2tJJoqU+AkaE/+6vQxi/G/DPmIZFJJp9Dkb1kM03AZx8ADehDUZgsNxju3mPXZYIA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "whatwg-mimetype": "^4.0.0",
        "whatwg-url": "^15.0.0"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/debug": {
      "version": "4.4.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/decimal.js": {
      "version": "10.6.0",
      "resolved": "https://registry.npmjs.org/decimal.js/-/decimal.js-10.6.0.tgz",
      "integrity": "sha512-YpgQiITW3JXGntzdUmyUR1V812Hn8T1YVXhCu+wO3OpS4eU9l4YdD3qjyiKdV6mvV29zapkMeD390UVEf2lkUg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/entities": {
      "version": "6.0.1",
      "resolved": "https://registry.npmjs.org/entities/-/entities-6.0.1.tgz",
      "integrity": "sha512-aN97NXWF6AWBTahfVOIrB/NShkzi5H7F9r1s9mD3cDj4Ko5f2qhhVoYMibXF7GlLveb/D2ioWay8lxI97Ven3g==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=0.12"
      },
      "funding": {
        "url": "https://github.com/fb55/entities?sponsor=1"
      }
    },
    "node_modules/es-module-lexer": {
      "version": "1.7.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/esbuild": {
      "version": "0.22.0",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=18"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.22.0",
        "@esbuild/android-arm": "0.22.0",
        "@esbuild/android-arm64": "0.22.0",
        "@esbuild/android-x64": "0.22.0",
        "@esbuild/darwin-arm64": "0.22.0",
        "@esbuild/darwin-x64": "0.22.0",
        "@esbuild/freebsd-arm64": "0.22.0",
        "@esbuild/freebsd-x64": "0.22.0",
        "@esbuild/linux-arm": "0.22.0",
        "@esbuild/linux-arm64": "0.22.0",
        "@esbuild/linux-ia32": "0.22.0",
        "@esbuild/linux-loong64": "0.22.0",
        "@esbuild/linux-mips64el": "0.22.0",
        "@esbuild/linux-ppc64": "0.22.0",
        "@esbuild/linux-riscv64": "0.22.0",
        "@esbuild/linux-s390x": "0.22.0",
        "@esbuild/linux-x64": "0.22.0",
        "@esbuild/netbsd-x64": "0.22.0",
        "@esbuild/openbsd-arm64": "0.22.0",
        "@esbuild/openbsd-x64": "0.22.0",
        "@esbuild/sunos-x64": "0.22.0",
        "@esbuild/win32-arm64": "0.22.0",
        "@esbuild/win32-ia32": "0.22.0",
        "@esbuild/win32-x64": "0.22.0"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/aix-ppc64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.22.0.tgz",
      "integrity": "sha512-uvQR2crZ/zgzSHDvdygHyNI+ze9zwS8mqz0YtGXotSqvEE0UkYE9s+FZKQNTt1VtT719mfP3vHrUdCpxBNQZhQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/android-arm": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.22.0.tgz",
      "integrity": "sha512-PBnyP+r8vJE4ifxsWys9l+Mc2UY/yYZOpX82eoyGISXXb3dRr0M21v+s4fgRKWMFPMSf/iyowqPW/u7ScSUkjQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/android-arm64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.22.0.tgz",
      "integrity": "sha512-UKhPb3o2gAB/bfXcl58ZXTn1q2oVu1rEu/bKrCtmm+Nj5MKUbrOwR5WAixE2v+lk0amWuwPvhnPpBRLIGiq7ig==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/android-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.22.0.tgz",
      "integrity": "sha512-IjTYtvIrjhR41Ijy2dDPgYjQHWG/x/A4KXYbs1fiU3efpRdoxMChK3oEZV6GPzVEzJqxFgcuBaiX1kwEvWUxSw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.22.0.tgz",
      "integrity": "sha512-mqt+Go4y9wRvEz81bhKd9RpHsQR1LwU8Xm6jZRUV/xpM7cIQFbFH6wBCLPTNsdELBvfoHeumud7X78jQQJv2TA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/darwin-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.22.0.tgz",
      "integrity": "sha512-vTaTQ9OgYc3VTaWtOE5pSuDT6H3d/qSRFRfSBbnxFfzAvYoB3pqKXA0LEbi/oT8GUOEAutspfRMqPj2ezdFaMw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/freebsd-arm64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.22.0.tgz",
      "integrity": "sha512-0e1ZgoobJzaGnR4reD7I9rYZ7ttqdh1KPvJWnquUoDJhL0rYwdneeLailBzd2/4g/U5p4e5TIHEWa68NF2hFpQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/freebsd-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.22.0.tgz",
      "integrity": "sha512-BFgyYwlCwRWyPQJtkzqq2p6pJbiiWgp0P9PNf7a5FQ1itKY4czPuOMAlFVItirSmEpRPCeImuwePNScZS0pL5Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-arm": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.22.0.tgz",
      "integrity": "sha512-KEMWiA9aGuPUD4BH5yjlhElLgaRXe+Eri6gKBoDazoPBTo1BXc/e6IW5FcJO9DoL19FBeCxgONyh95hLDNepIg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-arm64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.22.0.tgz",
      "integrity": "sha512-V/K2rctCUgC0PCXpN7AqT4hoazXKgIYugFGu/myk2+pfe6jTW2guz/TBwq4cZ7ESqusR/IzkcQaBkcjquuBWsw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-ia32": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.22.0.tgz",
      "integrity": "sha512-r2ZZqkOMOrpUhzNwxI7uLAHIDwkfeqmTnrv1cjpL/rjllPWszgqmprd/om9oviKXUBpMqHbXmppvjAYgISb26Q==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-loong64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.22.0.tgz",
      "integrity": "sha512-qaowLrV/YOMAL2RfKQ4C/VaDzAuLDuylM2sd/LH+4OFirMl6CuDpRlCq4u49ZBaVV8pkI/Y+hTdiibvQRhojCA==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-mips64el": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.22.0.tgz",
      "integrity": "sha512-hgrezzjQTRxjkQ5k08J6rtZN5PNnkWx/Rz6Kmj9gnsdCAX1I4Dn4ZPqvFRkXo55Q3pnVQJBwbdtrTO7tMGtyVA==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-ppc64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.22.0.tgz",
      "integrity": "sha512-ewxg6FLLUio883XgSjfULEmDl3VPv/TYNnRprVAS3QeGFLdCYdx1tIudBcd7n9jIdk82v1Ajov4jx87qW7h9+g==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-riscv64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.22.0.tgz",
      "integrity": "sha512-Az5XbgSJC2lE8XK8pdcutsf9RgdafWdTpUK/+6uaDdfkviw/B4JCwAfh1qVeRWwOohwdsl4ywZrWBNWxwrPLFg==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-s390x": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.22.0.tgz",
      "integrity": "sha512-8j4a2ChT9+V34NNNY9c/gMldutaJFmfMacTPq4KfNKwv2fitBCLYjee7c+Vxaha2nUhPK7cXcZpJtJ3+Y7ZdVQ==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/linux-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.22.0.tgz",
      "integrity": "sha512-JUQyOnpbAkkRFOk/AhsEemz5TfWN4FJZxVObUlnlNCbe7QBl61ZNfM4cwBXayQA6laMJMUcqLHaYQHAB6YQ95Q==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/netbsd-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.22.0.tgz",
      "integrity": "sha512-11PoCoHXo4HFNbLsXuMB6bpMPWGDiw7xETji6COdJss4SQZLvcgNoeSqWtATRm10Jj1uEHiaIk4N0PiN6x4Fcg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/openbsd-arm64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-arm64/-/openbsd-arm64-0.22.0.tgz",
      "integrity": "sha512-Ezlhu/YyITmXwKSB+Zu/QqD7cxrjrpiw85cc0Rbd3AWr2wsgp+dWbWOE8MqHaLW9NKMZvuL0DhbJbvzR7F6Zvg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/openbsd-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.22.0.tgz",
      "integrity": "sha512-ufjdW5tFJGUjlH9j/5cCE9lrwRffyZh+T4vYvoDKoYsC6IXbwaFeV/ENxeNXcxotF0P8CDzoICXVSbJaGBhkrw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/sunos-x64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.22.0.tgz",
      "integrity": "sha512-zY6ly/AoSmKnmNTowDJsK5ehra153/5ZhqxNLfq9NRsTTltetr+yHHcQ4RW7QDqw4JC8A1uC1YmeSfK9NRcK1w==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/win32-arm64": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.22.0.tgz",
      "integrity": "sha512-Kml5F7tv/1Maam0pbbCrvkk9vj046dPej30kFzlhXnhuCtYYBP6FGy/cLbc5yUT1lkZznGLf2OvuvmLjscO5rw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/esbuild/node_modules/@esbuild/win32-ia32": {
      "version": "0.22.0",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.22.0.tgz",
      "integrity": "sha512-IOgwn+mYTM3RrcydP4Og5IpXh+ftN8oF+HELTXSmbWBlujuci4Qa3DTeO+LEErceisI7KUSfEIiX+WOUlpELkw==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/estree-walker": {
      "version": "3.0.3",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "^1.0.0"
      }
    },
    "node_modules/expect-type": {
      "version": "1.2.2",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=12.0.0"
      }
    },
    "node_modules/html-encoding-sniffer": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-4.0.0.tgz",
      "integrity": "sha512-Y22oTqIU4uuPgEemfz7NDJz6OeKf12Lsu+QC+s3BVpda64lTiMYCyGwg5ki4vFxkMwQdeZDl2adZoqUgdFuTgQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "whatwg-encoding": "^3.1.1"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/http-proxy-agent": {
      "version": "7.0.2",
      "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-7.0.2.tgz",
      "integrity": "sha512-T1gkAiYYDWYx3V5Bmyu7HcfcvL7mUrTWiM6yOfa3PIphViJ/gFPbvidQ+veqSOHci/PxBcDabeUNCzpOODJZig==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.0",
        "debug": "^4.3.4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/https-proxy-agent": {
      "version": "7.0.6",
      "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-7.0.6.tgz",
      "integrity": "sha512-vK9P5/iUfdl95AI+JVyUuIcVtd4ofvtrOr3HNtM2yxC9bnMbEdp3x01OhQNnjb8IJYi38VlTE3mBXwcfvywuSw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "agent-base": "^7.1.2",
        "debug": "4"
      },
      "engines": {
        "node": ">= 14"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
      "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3.0.0"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-potential-custom-element-name": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/is-potential-custom-element-name/-/is-potential-custom-element-name-1.0.1.tgz",
      "integrity": "sha512-bCYeRA2rVibKZd+s2625gGnGF/t7DSqDs4dP7CrLA1m7jKWz6pps0LpYLJN8Q64HtmPKJ1hrN3nzPNKFEKOUiQ==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/jsdom": {
      "version": "27.0.0",
      "resolved": "https://registry.npmjs.org/jsdom/-/jsdom-27.0.0.tgz",
      "integrity": "sha512-lIHeR1qlIRrIN5VMccd8tI2Sgw6ieYXSVktcSHaNe3Z5nE/tcPQYQWOq00wxMvYOsz+73eAkNenVvmPC6bba9A==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@asamuzakjp/dom-selector": "^6.5.4",
        "cssstyle": "^5.3.0",
        "data-urls": "^6.0.0",
        "decimal.js": "^10.5.0",
        "html-encoding-sniffer": "^4.0.0",
        "http-proxy-agent": "^7.0.2",
        "https-proxy-agent": "^7.0.6",
        "is-potential-custom-element-name": "^1.0.1",
        "parse5": "^7.3.0",
        "rrweb-cssom": "^0.8.0",
        "saxes": "^6.0.0",
        "symbol-tree": "^3.2.4",
        "tough-cookie": "^6.0.0",
        "w3c-xmlserializer": "^5.0.0",
        "webidl-conversions": "^8.0.0",
        "whatwg-encoding": "^3.1.1",
        "whatwg-mimetype": "^4.0.0",
        "whatwg-url": "^15.0.0",
        "ws": "^8.18.2",
        "xml-name-validator": "^5.0.0"
      },
      "engines": {
        "node": ">=20"
      },
      "peerDependencies": {
        "canvas": "^3.0.0"
      },
      "peerDependenciesMeta": {
        "canvas": {
          "optional": true
        }
      }
    },
    "node_modules/loupe": {
      "version": "3.2.1",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/lru-cache": {
      "version": "11.2.1",
      "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-11.2.1.tgz",
      "integrity": "sha512-r8LA6i4LP4EeWOhqBaZZjDWwehd1xUJPCJd9Sv300H0ZmcUER4+JPh7bqqZeqs1o5pgtgvXm+d9UGrB5zZGDiQ==",
      "dev": true,
      "license": "ISC",
      "engines": {
        "node": "20 || >=22"
      }
    },
    "node_modules/magic-string": {
      "version": "0.30.19",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@jridgewell/sourcemap-codec": "^1.5.5"
      }
    },
    "node_modules/mdn-data": {
      "version": "2.12.2",
      "resolved": "https://registry.npmjs.org/mdn-data/-/mdn-data-2.12.2.tgz",
      "integrity": "sha512-IEn+pegP1aManZuckezWCO+XZQDplx1366JoVhTpMpBB1sPey/SbveZQUosKiKiGYjg1wH4pMlNgXbCiYgihQA==",
      "dev": true,
      "license": "CC0-1.0"
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/nanoid": {
      "version": "3.3.11",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "bin": {
        "nanoid": "bin/nanoid.cjs"
      },
      "engines": {
        "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
      }
    },
    "node_modules/parse5": {
      "version": "7.3.0",
      "resolved": "https://registry.npmjs.org/parse5/-/parse5-7.3.0.tgz",
      "integrity": "sha512-IInvU7fabl34qmi9gY8XOVxhYyMyuH2xUNpb2q8/Y+7552KlejkRvqvD19nMoUW/uQGGbqNpA6Tufu5FL5BZgw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "entities": "^6.0.0"
      },
      "funding": {
        "url": "https://github.com/inikulin/parse5?sponsor=1"
      }
    },
    "node_modules/pathe": {
      "version": "1.1.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/pathval": {
      "version": "2.0.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">= 14.16"
      }
    },
    "node_modules/picocolors": {
      "version": "1.1.1",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/postcss": {
      "version": "8.5.6",
      "dev": true,
      "funding": [
        {
          "type": "opencollective",
          "url": "https://opencollective.com/postcss/"
        },
        {
          "type": "tidelift",
          "url": "https://tidelift.com/funding/github/npm/postcss"
        },
        {
          "type": "github",
          "url": "https://github.com/sponsors/ai"
        }
      ],
      "license": "MIT",
      "dependencies": {
        "nanoid": "^3.3.11",
        "picocolors": "^1.1.1",
        "source-map-js": "^1.2.1"
      },
      "engines": {
        "node": "^10 || ^12 || >=14"
      }
    },
    "node_modules/punycode": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/punycode/-/punycode-2.3.1.tgz",
      "integrity": "sha512-vYt7UD1U9Wg6138shLtLOvdAu+8DsC/ilFtEVHcH+wydcSpNE20AfSOduf6MkRFahL5FY7X1oU7nKVZFtfq8Fg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=6"
      }
    },
    "node_modules/require-from-string": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/rollup": {
      "version": "4.51.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@types/estree": "1.0.8"
      },
      "bin": {
        "rollup": "dist/bin/rollup"
      },
      "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
      },
      "optionalDependencies": {
        "@rollup/rollup-android-arm-eabi": "4.51.0",
        "@rollup/rollup-android-arm64": "4.51.0",
        "@rollup/rollup-darwin-arm64": "4.51.0",
        "@rollup/rollup-darwin-x64": "4.51.0",
        "@rollup/rollup-freebsd-arm64": "4.51.0",
        "@rollup/rollup-freebsd-x64": "4.51.0",
        "@rollup/rollup-linux-arm-gnueabihf": "4.51.0",
        "@rollup/rollup-linux-arm-musleabihf": "4.51.0",
        "@rollup/rollup-linux-arm64-gnu": "4.51.0",
        "@rollup/rollup-linux-arm64-musl": "4.51.0",
        "@rollup/rollup-linux-loong64-gnu": "4.51.0",
        "@rollup/rollup-linux-ppc64-gnu": "4.51.0",
        "@rollup/rollup-linux-riscv64-gnu": "4.51.0",
        "@rollup/rollup-linux-riscv64-musl": "4.51.0",
        "@rollup/rollup-linux-s390x-gnu": "4.51.0",
        "@rollup/rollup-linux-x64-gnu": "4.51.0",
        "@rollup/rollup-linux-x64-musl": "4.51.0",
        "@rollup/rollup-openharmony-arm64": "4.51.0",
        "@rollup/rollup-win32-arm64-msvc": "4.51.0",
        "@rollup/rollup-win32-ia32-msvc": "4.51.0",
        "@rollup/rollup-win32-x64-msvc": "4.51.0",
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/rollup/node_modules/@rollup/rollup-android-arm-eabi": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm-eabi/-/rollup-android-arm-eabi-4.51.0.tgz",
      "integrity": "sha512-VyfldO8T/C5vAXBGIobrAnUE+VJNVLw5z9h4NgSDq/AJZWt/fXqdW+0PJbk+M74xz7yMDRiHtlsuDV7ew6K20w==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-android-arm64": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-android-arm64/-/rollup-android-arm64-4.51.0.tgz",
      "integrity": "sha512-Z3ujzDZgsEVSokgIhmOAReh9SGT2qloJJX2Xo1Q3nPU1EhCXrV0PbpR3r7DWRgozqnjrPZQkLe5cgBPIYp70Vg==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-darwin-arm64": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-arm64/-/rollup-darwin-arm64-4.51.0.tgz",
      "integrity": "sha512-T3gskHgArUdR6TCN69li5VELVAZK+iQ4iwMoSMNYixoj+56EC9lTj35rcxhXzIJt40YfBkvDy3GS+t5zh7zM6g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-darwin-x64": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-darwin-x64/-/rollup-darwin-x64-4.51.0.tgz",
      "integrity": "sha512-Hh7n/fh0g5UjH6ATDF56Qdf5bzdLZKIbhp5KftjMYG546Ocjeyg15dxphCpH1FFY2PJ2G6MiOVL4jMq5VLTyrQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-freebsd-arm64": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-arm64/-/rollup-freebsd-arm64-4.51.0.tgz",
      "integrity": "sha512-0EddADb6FBvfqYoxwVom3hAbAvpSVUbZqmR1wmjk0MSZ06hn/UxxGHKRqEQDMkts7XiZjejVB+TLF28cDTU+gA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-freebsd-x64": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-freebsd-x64/-/rollup-freebsd-x64-4.51.0.tgz",
      "integrity": "sha512-MpqaEDLo3JuVPF+wWV4mK7V8akL76WCz8ndfz1aVB7RhvXFO3k7yT7eu8OEuog4VTSyNu5ibvN9n6lgjq/qLEQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-arm-gnueabihf": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-gnueabihf/-/rollup-linux-arm-gnueabihf-4.51.0.tgz",
      "integrity": "sha512-WEWAGFNFFpvSWAIT3MYvxTkYHv/cJl9yWKpjhheg7ONfB0hetZt/uwBnM3GZqSHrk5bXCDYTFXg3jQyk/j7eXQ==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-arm-musleabihf": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm-musleabihf/-/rollup-linux-arm-musleabihf-4.51.0.tgz",
      "integrity": "sha512-9bxtxj8QoAp++LOq5PGDGkEEOpCDk9rOEHUcXadnijedDH8IXrBt6PnBa4Y6NblvGWdoxvXZYghZLaliTCmAng==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-arm64-gnu": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-gnu/-/rollup-linux-arm64-gnu-4.51.0.tgz",
      "integrity": "sha512-DdqA+fARqIsfqDYkKo2nrWMp0kvu/wPJ2G8lZ4DjYhn+8QhrjVuzmsh7tTkhULwjvHTN59nWVzAixmOi6rqjNA==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-arm64-musl": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-arm64-musl/-/rollup-linux-arm64-musl-4.51.0.tgz",
      "integrity": "sha512-2XVRNzcUJE1UJua8P4a1GXS5jafFWE+pQ6zhUbZzptOu/70p1F6+0FTi6aGPd6jNtnJqGMjtBCXancC2dhYlWw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-loong64-gnu": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-loong64-gnu/-/rollup-linux-loong64-gnu-4.51.0.tgz",
      "integrity": "sha512-R8QhY0kLIPCAVXWi2yftDSpn7Jtejey/WhMoBESSfwGec5SKdFVupjxFlKoQ7clVRuaDpiQf7wNx3EBZf4Ey6g==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-ppc64-gnu": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-ppc64-gnu/-/rollup-linux-ppc64-gnu-4.51.0.tgz",
      "integrity": "sha512-I498RPfxx9cMv1KTHQ9tg2Ku1utuQm+T5B+Xro+WNu3FzAFSKp4awKfgMoZwjoPgNbaFGINaOM25cQW6WuBhiQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-riscv64-gnu": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-gnu/-/rollup-linux-riscv64-gnu-4.51.0.tgz",
      "integrity": "sha512-o8COudsb8lvtdm9ixg9aKjfX5aeoc2x9KGE7WjtrmQFquoCRZ9jtzGlonujE4WhvXFepTraWzT4RcwyDDeHXjA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-riscv64-musl": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-riscv64-musl/-/rollup-linux-riscv64-musl-4.51.0.tgz",
      "integrity": "sha512-0shJPgSXMdYzOQzpM5BJN2euXY1f8uV8mS6AnrbMcH2KrkNsbpMxWB1wp8UEdiJ1NtyBkCk3U/HfX5mEONBq6w==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-s390x-gnu": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-s390x-gnu/-/rollup-linux-s390x-gnu-4.51.0.tgz",
      "integrity": "sha512-L7pV+ny7865jamSCQwyozBYjFRUKaTsPqDz7ClOtJCDu4paf2uAa0mrcHwSt4XxZP2ogFZS9uuitH3NXdeBEJA==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-x64-gnu": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-gnu/-/rollup-linux-x64-gnu-4.51.0.tgz",
      "integrity": "sha512-4YHhP+Rv3T3+H3TPbUvWOw5tuSwhrVhkHHZhk4hC9VXeAOKR26/IsUAT4FsB4mT+kfIdxxb1BezQDEg/voPO8A==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-linux-x64-musl": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-linux-x64-musl/-/rollup-linux-x64-musl-4.51.0.tgz",
      "integrity": "sha512-P7U7U03+E5w7WgJtvSseNLOX1UhknVPmEaqgUENFWfNxNBa1OhExT6qYGmyF8gepcxWSaSfJsAV5UwhWrYefdQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-openharmony-arm64": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-openharmony-arm64/-/rollup-openharmony-arm64-4.51.0.tgz",
      "integrity": "sha512-FuD8g3u9W6RPwdO1R45hZFORwa1g9YXEMesAKP/sOi7mDqxjbni8S3zAXJiDcRfGfGBqpRYVuH54Gu3FTuSoEw==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openharmony"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-win32-arm64-msvc": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-arm64-msvc/-/rollup-win32-arm64-msvc-4.51.0.tgz",
      "integrity": "sha512-zST+FdMCX3QAYfmZX3dp/Fy8qLUetfE17QN5ZmmFGPrhl86qvRr+E9u2bk7fzkIXsfQR30Z7ZRS7WMryPPn4rQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/rollup/node_modules/@rollup/rollup-win32-ia32-msvc": {
      "version": "4.51.0",
      "resolved": "https://registry.npmjs.org/@rollup/rollup-win32-ia32-msvc/-/rollup-win32-ia32-msvc-4.51.0.tgz",
      "integrity": "sha512-U+qhoCVAZmTHCmUKxdQxw1jwAFNFXmOpMME7Npt5GTb1W/7itfgAgNluVOvyeuSeqW+dEQLFuNZF3YZPO8XkMg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ]
    },
    "node_modules/rollup/node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/rrweb-cssom": {
      "version": "0.8.0",
      "resolved": "https://registry.npmjs.org/rrweb-cssom/-/rrweb-cssom-0.8.0.tgz",
      "integrity": "sha512-guoltQEx+9aMf2gDZ0s62EcV8lsXR+0w8915TC3ITdn2YueuNjdAYh/levpU9nFaoChh9RUS5ZdQMrKfVEN9tw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/saxes": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/saxes/-/saxes-6.0.0.tgz",
      "integrity": "sha512-xAg7SOnEhrm5zI3puOOKyy1OMcMlIJZYNJY7xLBwSze0UjhPLnWfj2GF2EpT0jmzaJKIWKHLsaSSajf35bcYnA==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "xmlchars": "^2.2.0"
      },
      "engines": {
        "node": ">=v12.22.7"
      }
    },
    "node_modules/siginfo": {
      "version": "2.0.0",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/source-map-js": {
      "version": "1.2.1",
      "dev": true,
      "license": "BSD-3-Clause",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/stackback": {
      "version": "0.0.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/std-env": {
      "version": "3.9.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/symbol-tree": {
      "version": "3.2.4",
      "resolved": "https://registry.npmjs.org/symbol-tree/-/symbol-tree-3.2.4.tgz",
      "integrity": "sha512-9QNk5KwDF+Bvz+PyObkmSYjI5ksVUYtjW7AU22r2NKcfLJcXp96hkDWU3+XndOsUb+AQ9QhfzfCT2O+CNWT5Tw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinybench": {
      "version": "2.9.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinyexec": {
      "version": "0.3.2",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tinypool": {
      "version": "1.1.1",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      }
    },
    "node_modules/tinyrainbow": {
      "version": "1.2.0",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tinyspy": {
      "version": "3.0.2",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=14.0.0"
      }
    },
    "node_modules/tldts": {
      "version": "7.0.14",
      "resolved": "https://registry.npmjs.org/tldts/-/tldts-7.0.14.tgz",
      "integrity": "sha512-lMNHE4aSI3LlkMUMicTmAG3tkkitjOQGDTFboPJwAg2kJXKP1ryWEyqujktg5qhrFZOkk5YFzgkxg3jErE+i5w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tldts-core": "^7.0.14"
      },
      "bin": {
        "tldts": "bin/cli.js"
      }
    },
    "node_modules/tldts-core": {
      "version": "7.0.14",
      "resolved": "https://registry.npmjs.org/tldts-core/-/tldts-core-7.0.14.tgz",
      "integrity": "sha512-viZGNK6+NdluOJWwTO9olaugx0bkKhscIdriQQ+lNNhwitIKvb+SvhbYgnCz6j9p7dX3cJntt4agQAKMXLjJ5g==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/tough-cookie": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tough-cookie/-/tough-cookie-6.0.0.tgz",
      "integrity": "sha512-kXuRi1mtaKMrsLUxz3sQYvVl37B0Ns6MzfrtV5DvJceE9bPyspOqk9xxv7XbZWcfLWbFmm997vl83qUWVJA64w==",
      "dev": true,
      "license": "BSD-3-Clause",
      "dependencies": {
        "tldts": "^7.0.5"
      },
      "engines": {
        "node": ">=16"
      }
    },
    "node_modules/tr46": {
      "version": "6.0.0",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-6.0.0.tgz",
      "integrity": "sha512-bLVMLPtstlZ4iMQHpFHTR7GAGj2jxi8Dg0s2h2MafAE4uSWF98FC/3MomU51iQAMf8/qDUbKWf5GxuvvVcXEhw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "punycode": "^2.3.1"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/undici-types": {
      "version": "6.21.0",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/vite": {
      "version": "5.4.20",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "esbuild": "^0.21.3",
        "postcss": "^8.4.43",
        "rollup": "^4.20.0"
      },
      "bin": {
        "vite": "bin/vite.js"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://github.com/vitejs/vite?sponsor=1"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.3"
      },
      "peerDependencies": {
        "@types/node": "^18.0.0 || >=20.0.0",
        "less": "*",
        "lightningcss": "^1.21.0",
        "sass": "*",
        "sass-embedded": "*",
        "stylus": "*",
        "sugarss": "*",
        "terser": "^5.4.0"
      },
      "peerDependenciesMeta": {
        "@types/node": {
          "optional": true
        },
        "less": {
          "optional": true
        },
        "lightningcss": {
          "optional": true
        },
        "sass": {
          "optional": true
        },
        "sass-embedded": {
          "optional": true
        },
        "stylus": {
          "optional": true
        },
        "sugarss": {
          "optional": true
        },
        "terser": {
          "optional": true
        }
      }
    },
    "node_modules/vite-node": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "cac": "^6.7.14",
        "debug": "^4.3.7",
        "es-module-lexer": "^1.5.4",
        "pathe": "^1.1.2",
        "vite": "^5.0.0"
      },
      "bin": {
        "vite-node": "vite-node.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      }
    },
    "node_modules/vite/node_modules/@esbuild/win32-x64": {
      "version": "0.21.5",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild": {
      "version": "0.21.5",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "bin": {
        "esbuild": "bin/esbuild"
      },
      "engines": {
        "node": ">=12"
      },
      "optionalDependencies": {
        "@esbuild/aix-ppc64": "0.21.5",
        "@esbuild/android-arm": "0.21.5",
        "@esbuild/android-arm64": "0.21.5",
        "@esbuild/android-x64": "0.21.5",
        "@esbuild/darwin-arm64": "0.21.5",
        "@esbuild/darwin-x64": "0.21.5",
        "@esbuild/freebsd-arm64": "0.21.5",
        "@esbuild/freebsd-x64": "0.21.5",
        "@esbuild/linux-arm": "0.21.5",
        "@esbuild/linux-arm64": "0.21.5",
        "@esbuild/linux-ia32": "0.21.5",
        "@esbuild/linux-loong64": "0.21.5",
        "@esbuild/linux-mips64el": "0.21.5",
        "@esbuild/linux-ppc64": "0.21.5",
        "@esbuild/linux-riscv64": "0.21.5",
        "@esbuild/linux-s390x": "0.21.5",
        "@esbuild/linux-x64": "0.21.5",
        "@esbuild/netbsd-x64": "0.21.5",
        "@esbuild/openbsd-x64": "0.21.5",
        "@esbuild/sunos-x64": "0.21.5",
        "@esbuild/win32-arm64": "0.21.5",
        "@esbuild/win32-ia32": "0.21.5",
        "@esbuild/win32-x64": "0.21.5"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/aix-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/aix-ppc64/-/aix-ppc64-0.21.5.tgz",
      "integrity": "sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "aix"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/android-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm/-/android-arm-0.21.5.tgz",
      "integrity": "sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/android-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-arm64/-/android-arm64-0.21.5.tgz",
      "integrity": "sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/android-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/android-x64/-/android-x64-0.21.5.tgz",
      "integrity": "sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "android"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-arm64/-/darwin-arm64-0.21.5.tgz",
      "integrity": "sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/darwin-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/darwin-x64/-/darwin-x64-0.21.5.tgz",
      "integrity": "sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/freebsd-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-arm64/-/freebsd-arm64-0.21.5.tgz",
      "integrity": "sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/freebsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/freebsd-x64/-/freebsd-x64-0.21.5.tgz",
      "integrity": "sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "freebsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-arm": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm/-/linux-arm-0.21.5.tgz",
      "integrity": "sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==",
      "cpu": [
        "arm"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-arm64/-/linux-arm64-0.21.5.tgz",
      "integrity": "sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ia32/-/linux-ia32-0.21.5.tgz",
      "integrity": "sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-loong64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-loong64/-/linux-loong64-0.21.5.tgz",
      "integrity": "sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==",
      "cpu": [
        "loong64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-mips64el": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-mips64el/-/linux-mips64el-0.21.5.tgz",
      "integrity": "sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==",
      "cpu": [
        "mips64el"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-ppc64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-ppc64/-/linux-ppc64-0.21.5.tgz",
      "integrity": "sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==",
      "cpu": [
        "ppc64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-riscv64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-riscv64/-/linux-riscv64-0.21.5.tgz",
      "integrity": "sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==",
      "cpu": [
        "riscv64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-s390x": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-s390x/-/linux-s390x-0.21.5.tgz",
      "integrity": "sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==",
      "cpu": [
        "s390x"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/linux-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/linux-x64/-/linux-x64-0.21.5.tgz",
      "integrity": "sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "linux"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/netbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/netbsd-x64/-/netbsd-x64-0.21.5.tgz",
      "integrity": "sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "netbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/openbsd-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/openbsd-x64/-/openbsd-x64-0.21.5.tgz",
      "integrity": "sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "openbsd"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/sunos-x64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/sunos-x64/-/sunos-x64-0.21.5.tgz",
      "integrity": "sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==",
      "cpu": [
        "x64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "sunos"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/win32-arm64": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-arm64/-/win32-arm64-0.21.5.tgz",
      "integrity": "sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==",
      "cpu": [
        "arm64"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/esbuild/node_modules/@esbuild/win32-ia32": {
      "version": "0.21.5",
      "resolved": "https://registry.npmjs.org/@esbuild/win32-ia32/-/win32-ia32-0.21.5.tgz",
      "integrity": "sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==",
      "cpu": [
        "ia32"
      ],
      "dev": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "win32"
      ],
      "engines": {
        "node": ">=12"
      }
    },
    "node_modules/vite/node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/vitest": {
      "version": "2.1.9",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "@vitest/expect": "2.1.9",
        "@vitest/mocker": "2.1.9",
        "@vitest/pretty-format": "^2.1.9",
        "@vitest/runner": "2.1.9",
        "@vitest/snapshot": "2.1.9",
        "@vitest/spy": "2.1.9",
        "@vitest/utils": "2.1.9",
        "chai": "^5.1.2",
        "debug": "^4.3.7",
        "expect-type": "^1.1.0",
        "magic-string": "^0.30.12",
        "pathe": "^1.1.2",
        "std-env": "^3.8.0",
        "tinybench": "^2.9.0",
        "tinyexec": "^0.3.1",
        "tinypool": "^1.0.1",
        "tinyrainbow": "^1.2.0",
        "vite": "^5.0.0",
        "vite-node": "2.1.9",
        "why-is-node-running": "^2.3.0"
      },
      "bin": {
        "vitest": "vitest.mjs"
      },
      "engines": {
        "node": "^18.0.0 || >=20.0.0"
      },
      "funding": {
        "url": "https://opencollective.com/vitest"
      },
      "peerDependencies": {
        "@edge-runtime/vm": "*",
        "@types/node": "^18.0.0 || >=20.0.0",
        "@vitest/browser": "2.1.9",
        "@vitest/ui": "2.1.9",
        "happy-dom": "*",
        "jsdom": "*"
      },
      "peerDependenciesMeta": {
        "@edge-runtime/vm": {
          "optional": true
        },
        "@types/node": {
          "optional": true
        },
        "@vitest/browser": {
          "optional": true
        },
        "@vitest/ui": {
          "optional": true
        },
        "happy-dom": {
          "optional": true
        },
        "jsdom": {
          "optional": true
        }
      }
    },
    "node_modules/w3c-xmlserializer": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/w3c-xmlserializer/-/w3c-xmlserializer-5.0.0.tgz",
      "integrity": "sha512-o8qghlI8NZHU1lLPrpi2+Uq7abh4GGPpYANlalzWxyWteJOCsr/P+oPBA49TOLu5FTZO4d3F9MnWJfiMo4BkmA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "xml-name-validator": "^5.0.0"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/webidl-conversions": {
      "version": "8.0.0",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-8.0.0.tgz",
      "integrity": "sha512-n4W4YFyz5JzOfQeA8oN7dUYpR+MBP3PIUsn2jLjWXwK5ASUzt0Jc/A5sAUZoCYFJRGF0FBKJ+1JjN43rNdsQzA==",
      "dev": true,
      "license": "BSD-2-Clause",
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/whatwg-encoding": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-3.1.1.tgz",
      "integrity": "sha512-6qN4hJdMwfYBtE3YBTTHhoeuUrDBPZmbQaxWAqSALV/MeEnR5z1xd8UKud2RAkFoPkmB+hli1TZSnyi84xz1vQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "iconv-lite": "0.6.3"
      },
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/whatwg-mimetype": {
      "version": "4.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-mimetype/-/whatwg-mimetype-4.0.0.tgz",
      "integrity": "sha512-QaKxh0eNIi2mE9p2vEdzfagOKHCcj1pJ56EEHGQOVxp8r9/iszLUUV7v89x9O1p/T+NlTM5W7jW6+cz4Fq1YVg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/whatwg-url": {
      "version": "15.1.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-15.1.0.tgz",
      "integrity": "sha512-2ytDk0kiEj/yu90JOAp44PVPUkO9+jVhyf+SybKlRHSDlvOOZhdPIrr7xTH64l4WixO2cP+wQIcgujkGBPPz6g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "tr46": "^6.0.0",
        "webidl-conversions": "^8.0.0"
      },
      "engines": {
        "node": ">=20"
      }
    },
    "node_modules/why-is-node-running": {
      "version": "2.3.0",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "siginfo": "^2.0.0",
        "stackback": "0.0.2"
      },
      "bin": {
        "why-is-node-running": "cli.js"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/ws": {
      "version": "8.18.3",
      "resolved": "https://registry.npmjs.org/ws/-/ws-8.18.3.tgz",
      "integrity": "sha512-PEIGCY5tSlUt50cqyMXfCzX+oOPqN0vuGqWzbcJ2xvnkzkq46oOpz7dQaTDBdfICb4N14+GARUDw2XV2N4tvzg==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=10.0.0"
      },
      "peerDependencies": {
        "bufferutil": "^4.0.1",
        "utf-8-validate": ">=5.0.2"
      },
      "peerDependenciesMeta": {
        "bufferutil": {
          "optional": true
        },
        "utf-8-validate": {
          "optional": true
        }
      }
    },
    "node_modules/xml-name-validator": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/xml-name-validator/-/xml-name-validator-5.0.0.tgz",
      "integrity": "sha512-EvGK8EJ3DhaHfbRlETOWAS5pO9MZITeauHKJyb8wyajUfQUenkIg2MvLDTZ4T/TgIcm3HU0TFBgWWboAZ30UHg==",
      "dev": true,
      "license": "Apache-2.0",
      "engines": {
        "node": ">=18"
      }
    },
    "node_modules/xmlchars": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/xmlchars/-/xmlchars-2.2.0.tgz",
      "integrity": "sha512-JZnDKK8B0RCDw84FNdDAIpZK+JuJw+s7Lz8nksI7SIuU3UXJJslUthsi+uWBUYOwPFwW7W7PRLRfUKpxjtjFCw==",
      "dev": true,
      "license": "MIT"
    }
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\package-lock.json =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\package.json =====
--- SIZE: 695 bytes ---

{
  "name": "webcall-static-build",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "esbuild app/presentation/static/js/main.js --bundle --minify --outfile=app/presentation/static/js/bundle.js --format=esm --platform=browser --target=es2019 && esbuild app/presentation/static/js/api.js --bundle --minify --outfile=app/presentation/static/js/api.bundle.js --format=esm --platform=browser --target=es2019",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:cov": "vitest run --coverage"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "esbuild": "^0.22.0",
    "jsdom": "^27.0.0",
    "vitest": "^2.0.0"
  }
}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\package.json =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\pyproject.toml =====
--- SIZE: 1656 bytes ---

[tool.poetry]
name = "webcall"
version = "0.1.0"
description = "WebRTC call backend with FastAPI (onion architecture)"
authors = ["You <you@example.com>"]
readme = "README.md"
package-mode = false

[tool.poetry.dependencies]
python = "^3.11"
fastapi = "^0.111.0"
uvicorn = {extras=["standard"], version="^0.30.0"}
pydantic = "^2.8.2"
pydantic-settings = "^2.4.0"
SQLAlchemy = "^2.0.30"
asyncpg = "^0.29.0"
alembic = "^1.13.2"
redis = "^5.0.6"
passlib = {version = "^1.7.4", extras=["bcrypt"]}
python-jose = {version = "^3.3.0", extras=["cryptography"]}
httpx = "^0.27.0"
structlog = "^24.1.0"
pywebpush = "^2.0.0"
prometheus-client = "^0.20.0"
aiosqlite = "^0.20.0"

[tool.poetry.group.dev.dependencies]
pytest = "^8.2.2"
pytest-asyncio = "^0.23.8"
httpx = {version="^0.27.0", extras=["http2"]}
ruff = "^0.6.3"
black = "^24.8.0"
isort = "^5.13.2"
pre-commit = "^3.8.0"
mypy = "^1.11.1"
websockets = "^12.0"

[tool.ruff]
line-length = 100
extend-select = ["I"]

[tool.black]
line-length = 100
target-version = ['py311']

[tool.isort]
profile = "black"
line_length = 100

[tool.mypy]
python_version = "3.11"
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_return_any = true
warn_unreachable = true
strict_equality = true
exclude = ["alembic/", "app/presentation/static/"]

[tool.pytest.ini_options]
asyncio_mode = "auto"
filterwarnings = [
  "ignore::DeprecationWarning",
]

[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\pyproject.toml =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\scripts\alembic_diag.py =====
--- SIZE: 3673 bytes ---

#!/usr/bin/env python
"""Alembic diagnostic & stamping helper.

Usage examples (run inside container or local venv):
  python -m app.scripts.alembic_diag              # show current + heads + history tail
  python -m app.scripts.alembic_diag --stamp 0006_telegram_links  # force single version
  python -m app.scripts.alembic_diag --force-reset 0006_telegram_links  # DELETE all rows then INSERT

It avoids need for psql client; uses direct SQL via SQLAlchemy Engine.
"""
from __future__ import annotations
import argparse
import sys
from typing import Optional
from alembic.config import Config
from alembic.script import ScriptDirectory
from sqlalchemy import create_engine, text
import os


def load_config() -> Config:
    cfg = Config(os.path.join(os.path.dirname(__file__), '..', '..', 'alembic.ini'))
    cfg.set_main_option('script_location', os.path.join(os.path.dirname(__file__), '..', '..', 'alembic'))
    return cfg


def get_engine():
    database_url = os.getenv('DATABASE_URL')
    if not database_url:
        print('ERROR: DATABASE_URL not set', file=sys.stderr)
        sys.exit(2)
    # alembic.ini may also define this, but we prioritize env
    return create_engine(database_url, future=True)


def show_state(engine, script: ScriptDirectory):
    with engine.connect() as conn:
        rows = conn.execute(text('SELECT version_num FROM alembic_version')).fetchall()
    versions_db = [r[0] for r in rows]
    heads = script.get_heads()
    print('--- DB versions (alembic_version table) ---')
    for v in versions_db:
        marker = ' (HEAD?)' if v in heads else ''
        print(f'  {v}{marker}')
    print('\n--- Declared heads from code ---')
    for h in heads:
        print(f'  {h}')
    # history tail
    tail = list(script.walk_revisions())[:10]
    print('\n--- History (top 10 newest) ---')
    for rev in tail:
        print(f'{rev.revision} <- {rev.down_revision}')
    print('\nIf you see more than one head above, you have a split heads situation.')


def stamp(engine, version: str, force_reset: bool):
    with engine.begin() as conn:
        if force_reset:
            conn.execute(text('DELETE FROM alembic_version'))
        # check existing
        existing = {r[0] for r in conn.execute(text('SELECT version_num FROM alembic_version'))}
        if force_reset or len(existing) != 1 or version not in existing:
            if not force_reset and existing and version not in existing:
                print(f'Info: existing versions {existing} do not match target -> replacing with {version}')
                conn.execute(text('DELETE FROM alembic_version'))
            conn.execute(text('INSERT INTO alembic_version (version_num) VALUES (:v)'), {'v': version})
    print(f'Stamped DB alembic_version to {version}')


def main(argv: Optional[list[str]] = None):
    ap = argparse.ArgumentParser()
    ap.add_argument('--stamp', metavar='REV', help='Stamp DB to given revision if mismatch (non-destructive).')
    ap.add_argument('--force-reset', metavar='REV', help='Delete all rows then insert single revision.')
    args = ap.parse_args(argv)

    cfg = load_config()
    script = ScriptDirectory.from_config(cfg)
    engine = get_engine()

    if args.force_reset and args.stamp:
        print('Use either --stamp or --force-reset, not both', file=sys.stderr)
        return 2

    if args.force_reset:
        stamp(engine, args.force_reset, force_reset=True)
    elif args.stamp:
        stamp(engine, args.stamp, force_reset=False)

    show_state(engine, script)


if __name__ == '__main__':  # pragma: no cover
    main()

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\scripts\alembic_diag.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\scripts\legacy\README_legacy.txt =====
--- SIZE: 729 bytes ---

Артефакты резервного дампа (устаревшие):
- project_dump.txt — текстовый снимок структуры/кода (не обновляется автоматически)
- dump.bat — старый скрипт для создания дампа

Перемещены сюда для сохранения истории. В актуальных сценариях используйте:
poetry run alembic revision --autogenerate -m "..."
docker compose exec api pg_dump ... (для реальных бэкапов)

Можно удалить директорию целиком после подтверждения, что эти артефакты не требуются.
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\scripts\legacy\README_legacy.txt =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\test_app.db =====
--- SIZE: 155648 bytes ---

SQLite format 3   @        &                                                             .�   �    ���8�	d�M��{;����w�x���                                                                                                                                                                                                                                                                                CW1 indexsqlite_autoindex_direct_read_states_1direct_read_states� E+�indexix_direct_messages_sender_iddirect_messagesCREATE INDEX ix_direct_messages_sender_id ON direct_messages (sender_id)� E+�indexix_direct_messages_user_a_iddirect_messagesCREATE INDEX ix_direct_messages_user_a_id ON direct_messages (user_a_id)zA+�indexix_direct_messages_sent_atdirect_messagesCREATE INDEX ix_direct_messages_sent_at ON direct_messages (sent_at)� E+�indexix_direct_messages_user_b_iddirect_messagesCREATE INDEX ix_direct_messages_user_b_id ON direct_messages (user_b_id)�6++�#tabledirect_messagesdirect_messagesCREATE TABLE direct_messages (
	id UUID NOT NULL, 
	user_a_id UUID NOT NULL, 
	user_b_id UUID NOT NULL, 
	sender_id UUID NOT NULL, 
	ciphertext TEXT NOT NULL, 
	sent_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_direct_msg_id UNIQUE (id), 
	FOREIGN KEY(user_a_id) REFERENCES users (id), 
	FOREIGN KEY(user_b_id) REFERENCES users (id), 
	FOREIGN KEY(sender_id) REFERENCES users (id)
)=Q+ indexsqlite_autoindex_direct_messages_1direct_messages�G1�!indexix_push_subscriptions_user_idpush_subscriptionsCREATE INDEX ix_push_subscriptions_user_id ON push_subscriptions (user_id)�x11�tablepush_subscriptionspush_subscriptionsCREATE TABLE push_subscriptions (
	id UUID NOT NULL, 
	user_id UUID NOT NULL, 
	endpoint TEXT NOT NULL, 
	p256dh VARCHAR(255) NOT NULL, 
	auth VARCHAR(255) NOT NULL, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_push_user_endpoint UNIQUE (user_id, endpoint), 
	FOREIGN KEY(user_id) REFERENCES users (id)
)CW1 indexsqlite_autoindex_push_subscriptions_2push_subscriptionsCW1 indexsqlite_autoindex_push_subscriptions_1push_subscriptionsp=#�indexix_friendships_user_a_idfriendshipsCREATE INDEX ix_friendships_user_a_id ON friendships (user_a_id)p=#�indexix_friendships_user_b_idfriendshipsCREATE INDEX ix_friendships_user_b_id ON friendships (user_b_id)�f
##�tablefriendshipsfriendshipsCREATE TABLE friendships (
	id UUID NOT NULL, 
	user_a_id UUID NOT NULL, 
	user_b_id UUID NOT NULL, 
	requested_by UUID NOT NULL, 
	status VARCHAR(20) NOT NULL, 
	created_at DATETIME NOT NULL, 
	updated_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_friend_pair UNIQUE (user_a_id, user_b_id), 
	FOREIGN KEY(user_a_id) REFERENCES users (id), 
	FOREIGN KEY(user_b_id) REFERENCES users (id), 
	FOREIGN KEY(requested_by) REFERENCES users (id)
)5I# indexsqlite_autoindex_friendships_2friendships5I# indexsqlite_autoindex_friendships_1friendshipsT	/qindexix_rooms_owner_idrooms
CREATE INDEX ix_rooms_owner_id ON rooms (owner_id)�y�QtableroomsroomsCREATE TABLE rooms (
	id UUID NOT NULL, 
	name VARCHAR(100) NOT NULL, 
	owner_id UUID NOT NULL, 
	is_private BOOLEAN NOT NULL, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(owner_id) REFERENCES users (id)
))= indexsqlite_autoindex_rooms_1rooms	R)sindexix_users_emailusersCREATE UNIQUE INDEX ix_users_email ON users (email)[/indexix_users_usernameusersCREATE UNIQUE INDEX ix_users_username ON users (username)�v�KtableusersusersCREATE TABLE users (
	id UUID NOT NULL, 
	email VARCHAR(254) NOT NULL, 
	username VARCHAR(50) NOT NULL, 
	password_hash VARCHAR(255) NOT NULL, 
	public_key VARCHAR(2000), 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id)
))= indexsqlite_autoindex_users_1users�)++�	tablealembic_versionalembic_versionCREATE TABLE alembic_version (
	version_num VARCHAR(32) NOT NULL, 
	CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
)=Q+ indexsqlite_autoindex_alembic_version_1alembic_version                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              � { ����8�	d�M��{;����w�x� �� J J          7K% indexsqlite_autoindex_participants_1participants�*11�tabledirect_read_statesdirect_read_statesCREATE TABLE direct_read_states (
	owner_id UUID NOT NULL, 
	other_id UUID NOT NULL, 
	last_read_at DATETIME NOT NULL, 
	PRIMARY KEY (owner_id, other_id), 
	FOREIGN KEY(owner_id) REFERENCES users (id), 
	FOREIGN KEY(other_id) REFERENCES users (id)
)��W1 indexsqlite_autoindex_direct_read_states_1direct_read_states� E+�indexix_direct_messages_sender_iddirect_messagesCREATE INDEX ix_direct_messages_sender_id ON direct_messages (sender_id)� E+�indexix_direct_messages_user_a_iddirect_messagesCREATE INDEX ix_direct_messages_user_a_id ON direct_messages (user_a_id)zA+�indexix_direct_messages_sent_atdirect_messagesCREATE INDEX ix_direct_messages_sent_at ON direct_messages (sent_at)� E+�indexix_direct_messages_user_b_iddirect_messagesCREATE INDEX ix_direct_messages_user_b_id ON direct_messages (user_b_id)�6++�#tabledirect_messagesdirect_messagesCREATE TABLE direct_messages (
	id UUID NOT NULL, 
	user_a_id UUID NOT NULL, 
	user_b_id UUID NOT NULL, 
	sender_id UUID NOT NULL, 
	ciphertext TEXT NOT NULL, 
	sent_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_direct_msg_id UNIQUE (id), 
	FOREIGN KEY(user_a_id) REFERENCES users (id), 
	FOREIGN KEY(user_b_id) REFERENCES users (id), 
	FOREIGN KEY(sender_id) REFERENCES users (id)
)� �Q+ indexsqlite_autoindex_direct_messages_1direct_messages�G1�!indexix_push_subscriptions_user_idpush_subscriptionsCREATE INDEX ix_push_subscriptions_user_id ON push_subscriptions (user_id)�x11�tablepush_subscriptionspush_subscriptionsCREATE TABLE push_subscriptions (
	id UUID NOT NULL, 
	user_id UUID NOT NULL, 
	endpoint TEXT NOT NULL, 
	p256dh VARCHAR(255) NOT NULL, 
	auth VARCHAR(255) NOT NULL, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_push_user_endpoint UNIQUE (user_id, endpoint), 
	FOREIGN KEY(user_id) REFERENCES users (id)
)� �W1 indexsqlite_autoindex_push_subscriptions_2push_subscriptionsCW1 indexsqlite_autoindex_push_subscriptions_1push_subscriptionsp=#�indexix_friendships_user_a_idfriendshipsCREATE INDEX ix_friendships_user_a_id ON friendships (user_a_id)p=#�indexix_friendships_user_b_idfriendshipsCREATE INDEX ix_friendships_user_b_id ON friendships (user_b_id)�f
##�tablefriendshipsfriendshipsCREATE TABLE friendships (
	id UUID NOT NULL, 
	user_a_id UUID NOT NULL, 
	user_b_id UUID NOT NULL, 
	requested_by UUID NOT NULL, 
	status VARCHAR(20) NOT NULL, 
	created_at DATETIME NOT NULL, 
	updated_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_friend_pair UNIQUE (user_a_id, user_b_id), 
	FOREIGN KEY(user_a_id) REFERENCES users (id), 
	FOREIGN KEY(user_b_id) REFERENCES users (id), 
	FOREIGN KEY(requested_by) REFERENCES users (id)
)5I# indexsqlite_autoindex_friendships_2friendships5I# indexsqlite_autoindex_friendships_1friendshipsT	/qindexix_rooms_owner_idrooms
CREATE INDEX ix_rooms_owner_id ON rooms (owner_id)�y�QtableroomsroomsCREATE TABLE rooms (
	id UUID NOT NULL, 
	name VARCHAR(100) NOT NULL, 
	owner_id UUID NOT NULL, 
	is_private BOOLEAN NOT NULL, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(owner_id) REFERENCES users (id)
))= indexsqlite_autoindex_rooms_1rooms	R)sindexix_users_emailusersCREATE UNIQUE INDEX ix_users_email ON users (email)[/indexix_users_usernameusersCREATE UNIQUE INDEX ix_users_username ON users (username)�v�KtableusersusersCREATE TABLE users (
	id UUID NOT NULL, 
	email VARCHAR(254) NOT NULL, 
	username VARCHAR(50) NOT NULL, 
	password_hash VARCHAR(255) NOT NULL, 
	public_key VARCHAR(2000), 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id)
))= indexsqlite_autoindex_users_1users�)++�	tablealembic_versionalembic_versionCREATE TABLE alembic_version (
	version_num VARCHAR(32) NOT NULL, 
	CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
)=Q+ indexsqlite_autoindex_alembic_version_1alembic_version                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              � ~ �v�4�r�s
�	�	~�r��<�~                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ]#3yindexix_messages_room_idmessages&CREATE INDEX ix_messages_room_id ON messages (room_id)]"3yindexix_messages_sent_atmessages%CREATE INDEX ix_messages_sent_at ON messages (sent_at)d!7�indexix_messages_author_idmessages$CREATE INDEX ix_messages_author_id ON messages (author_id)�$�tablemessagesmessages"CREATE TABLE messages (
	id UUID NOT NULL, 
	room_id UUID NOT NULL, 
	author_id UUID NOT NULL, 
	content TEXT NOT NULL, 
	sent_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(room_id) REFERENCES rooms (id), 
	FOREIGN KEY(author_id) REFERENCES users (id)
)/ C indexsqlite_autoindex_messages_1messages#       n;%�	indexix_participants_user_idparticipants!CREATE INDEX ix_participants_user_id ON participants (user_id)n;%�	indexix_participants_room_idparticipants CREATE INDEX ix_participants_room_id ON participants (room_id)7K% indexsqlite_autoindex_participants_1participants�`%%�tableparticipantsparticipantsCREATE TABLE participants (
	id UUID NOT NULL, 
	room_id UUID NOT NULL, 
	user_id UUID NOT NULL, 
	role VARCHAR(20) NOT NULL, 
	muted BOOLEAN NOT NULL, 
	joined_at DATETIME NOT NULL, 
	left_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(room_id) REFERENCES rooms (id), 
	FOREIGN KEY(user_id) REFERENCES users (id)
)CW1 indexsqlite_autoindex_direct_read_states_1direct_read_states�*11�tabledirect_read_statesdirect_read_statesCREATE TABLE direct_read_states (
	owner_id UUID NOT NULL, 
	other_id UUID NOT NULL, 
	last_read_at DATETIME NOT NULL, 
	PRIMARY KEY (owner_id, other_id), 
	FOREIGN KEY(owner_id) REFERENCES users (id), 
	FOREIGN KEY(other_id) REFERENCES users (id)
)� E+�indexix_direct_messages_sender_iddirect_messagesCREATE INDEX ix_direct_messages_sender_id ON direct_messages (sender_id)� E+�indexix_direct_messages_user_a_iddirect_messagesCREATE INDEX ix_direct_messages_user_a_id ON direct_messages (user_a_id)zA+�indexix_direct_messages_sent_atdirect_messagesCREATE INDEX ix_direct_messages_sent_at ON direct_messages (sent_at)� E+�indexix_direct_messages_user_b_iddirect_messagesCREATE INDEX ix_direct_messages_user_b_id ON direct_messages (user_b_id)=Q+ indexsqlite_autoindex_direct_messages_1direct_messages�6++�#tabledirect_messagesdirect_messagesCREATE TABLE direct_messages (
	id UUID NOT NULL, 
	user_a_id UUID NOT NULL, 
	user_b_id UUID NOT NULL, 
	sender_id UUID NOT NULL, 
	ciphertext TEXT NOT NULL, 
	sent_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_direct_msg_id UNIQUE (id), 
	FOREIGN KEY(user_a_id) REFERENCES users (id), 
	FOREIGN KEY(user_b_id) REFERENCES users (id), 
	FOREIGN KEY(sender_id) REFERENCES users (id)
)�G1�!indexix_push_subscriptions_user_idpush_subscriptionsCREATE INDEX ix_push_subscriptions_user_id ON push_subscriptions (user_id)CW1 indexsqlite_autoindex_push_subscriptions_2push_subscriptionsCW1 indexsqlite_autoindex_push_subscriptions_1push_subscriptions
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\test_app.db =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\conftest.py =====
--- SIZE: 511 bytes ---

import os, sys

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

# Дублируем переменные окружения для Settings, если не заданы
os.environ.setdefault('JWT_SECRET', 'test-jwt-secret')
os.environ.setdefault('REGISTRATION_SECRET', 'test-registration')
os.environ.setdefault('DATABASE_URL', 'sqlite+aiosqlite:///:memory:')
os.environ.setdefault('REDIS_URL', 'redis://localhost:6379/0')

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\conftest.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_ai_prompt.py =====
--- SIZE: 2122 bytes ---

from __future__ import annotations

import pytest
from httpx import AsyncClient
from app.infrastructure.config import get_settings

DEFAULT_PROMPT = (
    "Ты ассистент, делающий краткую структурированную выжимку группового чата:"\
    " 1) Основные темы 2) Принятые решения 3) Открытые вопросы."\
    " Пиши лаконично на русском, без лишних вступлений."
)

@pytest.mark.asyncio
async def test_ai_prompt_set_and_reset(async_client: AsyncClient, auth_headers):
    # GET initial (should be default)
    r = await async_client.get('/api/v1/ai/prompt', headers=auth_headers)
    assert r.status_code == 200
    data = r.json()
    assert data['is_default'] is True
    assert 'Основные темы' in data['prompt']

    custom = 'Кастомный prompt: выдели 1) решения 2) риски.'
    r2 = await async_client.put('/api/v1/ai/prompt', headers=auth_headers, json={'prompt': custom})
    assert r2.status_code == 200
    d2 = r2.json()
    assert d2['is_default'] is False
    assert d2['prompt'].startswith('Кастомный prompt')

    # Повторный GET возвращает кастомный
    r3 = await async_client.get('/api/v1/ai/prompt', headers=auth_headers)
    assert r3.status_code == 200
    d3 = r3.json()
    assert d3['is_default'] is False
    assert d3['prompt'].startswith('Кастомный prompt')

    # DELETE сбрасывает
    r4 = await async_client.delete('/api/v1/ai/prompt', headers=auth_headers)
    assert r4.status_code == 200
    d4 = r4.json()
    assert d4['is_default'] is True
    assert 'Основные темы' in d4['prompt']

    # Сохранение дефолта явно приводит к очистке кастомного поля
    r5 = await async_client.put('/api/v1/ai/prompt', headers=auth_headers, json={'prompt': DEFAULT_PROMPT})
    assert r5.status_code == 200
    d5 = r5.json()
    assert d5['is_default'] is True

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_ai_prompt.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_health.py =====
--- SIZE: 373 bytes ---

import pytest
from httpx import AsyncClient, ASGITransport

from app.bootstrap.asgi import app


@pytest.mark.asyncio
async def test_healthz():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
        r = await client.get("/healthz")
        assert r.status_code == 200
        assert r.json() == {"status": "ok"}

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_health.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_summary.py =====
--- SIZE: 1103 bytes ---

from __future__ import annotations

import pytest
from app.infrastructure.services.summary import SummaryCollector
from app.infrastructure.services.ai_provider import HeuristicAIProvider


@pytest.mark.asyncio
async def test_summary_collector_basic(monkeypatch):
    collector = SummaryCollector()
    # отключаем AI для предсказуемости
    from app.infrastructure import config as cfg
    s = cfg.get_settings()
    monkeypatch.setattr(s, 'AI_SUMMARY_ENABLED', False, raising=False)

    for i in range(5):
        await collector.add_message('room-x', f'user-{i%2}', f'U{i%2}', f'msg {i}')

    res = await collector.summarize('room-x', HeuristicAIProvider())
    assert res is not None
    assert res.message_count == 5
    assert 'msg 4' in res.summary_text  # последнее сообщение присутствует

    # повторная суммаризация той же комнаты должна вернуть None (очищено)
    res2 = await collector.summarize('room-x', HeuristicAIProvider())
    assert res2 is None

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_summary.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_summary_participants.py =====
--- SIZE: 2497 bytes ---

import pytest
from app.infrastructure.services.summary_v2.orchestrator import get_summary_orchestrator
from app.infrastructure.services.summary_v2.models import SummaryResult
from app.infrastructure.services.ai_provider import HeuristicAIProvider
from app.infrastructure.config import get_settings

@pytest.mark.asyncio
async def test_summary_participant_breakdown(monkeypatch):
    # Включаем флаг breakdown
    settings = get_settings()
    monkeypatch.setattr(settings, 'AI_SUMMARY_ENABLED', False, raising=False)  # чтобы не обращаться к внешнему AI
    monkeypatch.setattr(settings, 'AI_SUMMARY_PARTICIPANT_BREAKDOWN', True, raising=False)
    orch = get_summary_orchestrator()
    room_id = 'r1'
    # Старт окна пользователя u1 и u2
    await orch.start_user_window(room_id, 'u1')
    await orch.start_user_window(room_id, 'u2')
    # Добавляем сообщения
    orch.add_chat(room_id, 'u1', 'User1', 'Привет')
    orch.add_chat(room_id, 'u2', 'User2', 'Здравствуйте')
    orch.add_chat(room_id, 'u1', 'User1', 'Как дела?')
    orch.add_chat(room_id, 'u2', 'User2', 'Отлично, обсуждаем проект')
    orch.add_chat(room_id, 'u1', 'User1', 'Нужно добавить разбивку по участникам')

    provider = HeuristicAIProvider()
    # Генерируем персональный summary для u1
    res1 = await orch.build_personal_summary(room_id=room_id, user_id='u1', ai_provider=provider, db_session=None)
    assert isinstance(res1, SummaryResult)
    assert res1.participants is not None
    # В персональном окне u1 должны быть сообщения u1 и u2 (оба автора после старта)
    authors = { (p.participant_id, p.participant_name) for p in res1.participants }
    assert ('u1', 'User1') in authors and ('u2', 'User2') in authors
    # Проверяем что sample_messages не пустые
    assert any(p.sample_messages for p in res1.participants)

    # Отключаем breakdown и убеждаемся что participants=None
    monkeypatch.setattr(settings, 'AI_SUMMARY_PARTICIPANT_BREAKDOWN', False, raising=False)
    res2 = await orch.build_personal_summary(room_id=room_id, user_id='u1', ai_provider=provider, db_session=None)
    # breakdown отключён
    assert res2.participants is None or res2.participants == []

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_summary_participants.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_summary_threshold.py =====
--- SIZE: 1410 bytes ---

from __future__ import annotations

import pytest
from app.infrastructure.services.summary import SummaryCollector
from app.infrastructure.services.ai_provider import HeuristicAIProvider
from app.infrastructure import config as cfg


@pytest.mark.asyncio
async def test_summary_min_chars_threshold(monkeypatch):
    collector = SummaryCollector()
    settings = cfg.get_settings()
    # Включаем AI и задаём высокий порог чтобы сработало отсечение
    monkeypatch.setattr(settings, 'AI_SUMMARY_ENABLED', True, raising=False)
    monkeypatch.setattr(settings, 'AI_SUMMARY_MIN_CHARS', 200, raising=False)

    # Добавляем короткие сообщения общим объёмом меньше 200 символов
    lines = ["Привет", "Как дела?", "Ок"]
    for i, line in enumerate(lines):
        await collector.add_message('room-t', f'u{i}', f'U{i}', line)

    res = await collector.summarize('room-t', HeuristicAIProvider())
    assert res is not None
    # Ожидаем что сработал текст маркера про слишком короткую сессию
    assert 'слишком короткая' in res.summary_text.lower()
    # Повторно должно вернуть None
    res2 = await collector.summarize('room-t', HeuristicAIProvider())
    assert res2 is None

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\tests\test_summary_threshold.py =====

===== BEGIN FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\vitest.config.mjs =====
--- SIZE: 277 bytes ---

export default {
  test: {
    environment: 'jsdom',
    include: ['app/presentation/static/js/__tests__/**/*.test.mjs'],
    globals: false,
    reporters: 'default',
    setupFiles: ['app/presentation/static/js/__tests__/setup.mjs'],
    restoreMocks: true,
  }
};

===== END FILE: C:\Users\Ярослав\Проекты\webcall\WebCall\webcall\vitest.config.mjs =====

